[{"uri":"/BIO-BTE-06-L-7/index.html","title":"BIO-BTE-06-L-7\n","content":"(**\n# BIO-BTE-06-L-7\n\u003Cbr\u003E\n## Course objective and procedure\n\nA typical modern proteomics workflow reaches from the experiment and measurement over deconvolution, identification, \nquantification, protein assembly and statistical analysis. This shows that independent from the different specialized \nworkflows at hand, the computational part in proteomics is noticeable.\n\nThe objective of this course is to provide insights in both aspects. Now, is time to start the computational proteomics part. In the following notebooks you will learn: \n\n1. How to model growth for a defined cell number to relate the findings in your proteomics experiments to a meaningful basis.\n2. Getting in-silico information about the proteome of interest to be able to make sense out of your experimental measurements.\n3. How to access and look at your measurements from an m/z perspective and what it is that we actually measure.\n4. How does peptide or protein identification work computationally?\n5. What must be done to quantify a peptide?\n\nThe most hands-on approach to provide those insights is to use a combination of explanatory text, images, interactive charts, \nand program code. This will be combined within interactive notebooks, that allow you to play around with the code examples and learn.\n\nIn this course, we want to support your coding literacy by a practical learning approach without the attempt to detail every mechanisms of the \nprogramming language. This means that the focus is on reading, understanding, and learning to manipulate the code not on coding itself.\n\nHowever, in the beginning you will get a rapid introduction into F# programming that should allow you to understand code \nand do some manipulations to achieve your desired outcome.\n\n## Schedule\n\n| Day      | Topic                                 | Notebooks        |\n|----------|---------------------------------------|------------------|\n| 21.02.22 | Getting started; Coding literacy      | 00a; 00b         |\n| 22.02.22 | 1: Growth Model and Cell number       | 01a; 01b         |\n| 23.02.22 | 2: In-silico proteome analysis        | 02a; 02b; 02c    |\n| 24.02.22 | 3: Understanding the Data             | 03a; 03b; 03c    |\n| 25.02.22 | 4: Protein and Peptide identification | 04a; 04b         |\n| 28.02.22 | 5: Peptide quantification             | 05a              |\n| 01.03.22 | Research Data Management              | 06a              |\n| 02.03.22 | Analysing the course Experiment       | 07a              |\n| 03.03.22 | Analysing the course Experiment       | 07b              |\n| 04.03.22 | Analysing the course Experiment       | 07c              |\n\n## Getting started\n\n* Download the latest stable build for [Visual Studio Code](https://code.visualstudio.com/) and install it.\n* Download the recommended [.NET SDK](https://dotnet.microsoft.com/download) and install it.\n* Open Visual Studio Code, navigate to the \u0022Extensions\u0022 tab and install\n    * .NET Interactive Notebooks\n    * Ionide-fsharp\n    \n    ![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/CodeExtensions.png)\n\n* Download the current notebook from the page linked on the left.\n\n    ![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/DownloadNotebook.png)\n\n* In Visual Studio Code press \u0060Strg \u002B Shift \u002B P\u0060 and klick on \u0060.NET Interactive Open notebook\u0060.\n\n    ![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/OpenNotebook.png)\n\n* Navigate to the location of your notebook and open it.\n* Notebooks contain Text- and Codeblocks:\n    * Adding a new Text- or Codeblock can be done by hovering at the upper or lower border of an existing block:\n\n    ![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/AddingBlock.png)\n\n    * Working with Textblocks:\n        You can edit a Textblock by doubleklicking on it. Inside a Textblock you can write plain text or style it with [Markdown](https://en.wikipedia.org/wiki/Markdown).\n        Once you are finished you can press the \u0060Esc\u0060 button.\n    * Working with Codeblocks:\n        You can start editing any Codeblock by clicking in it. In there you can start writing your own code or edit existing code. Once you are done you can execute the Codeblock by pressing \u0060Strg \u002B Alt \u002B Enter\u0060.\n        If you want to execute all codeblocks at once, you can press on the two arrows in the upper right corner of the notebook:\n\n    ![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/ExecuteAll.png)\n*)"},{"uri":"/BIO-BTE-06-L-7/FullFormula.html","title":"FullFormula","content":"let calcAbsoluteAbundance \u03BCgChlorophPerMlCult cellCountPerMlCult \u03BCgChlorophPer\u03BClSample \u03BCgProtPer\u03BClSample \u03BCgQProtSpike \u03BCgloadedProtein molWeightQProt molWeightTargetProt ratio1415N =\n    let chlorophPerCell : float = \u03BCgChlorophPerMlCult / cellCountPerMlCult\n    let cellsPer\u03BClSample = \u03BCgChlorophPer\u03BClSample / chlorophPerCell\n    let \u03BCgProteinPerCell = \u03BCgProtPer\u03BClSample / cellsPer\u03BClSample\n    let molQProtSpike = \u03BCgQProtSpike * 10. ** -6. / molWeightQProt\n    let molProtPerBand = ratio1415N * molQProtSpike\n    let molProtIn1\u03BCgLoadedProt = molProtPerBand / \u03BCgloadedProtein\n    let gTargetProtIn1\u03BCgLoadedProt = molWeightTargetProt * molProtIn1\u03BCgLoadedProt\n    let molProteinPerCell = molProtIn1\u03BCgLoadedProt * \u03BCgProteinPerCell\n    let proteinsPerCell = molProteinPerCell * 6.022 * 10. ** 23.\n    let attoMolProteinPerCell = molProteinPerCell * (10. ** 18.)\n    let attoMolProteinPerBand = molProtPerBand * (10. ** 18.)\n    {|\n        MassTargetProteinInLoadedProtein    = gTargetProtIn1\u03BCgLoadedProt\n        ProteinsPerCell                     = proteinsPerCell\n        AttoMolProteinPerCell               = attoMolProteinPerCell\n        AttoMolProteinPerBand               = attoMolProteinPerBand\n    |}"},{"uri":"/BIO-BTE-06-L-7/NB00b_FSharp_Coding_literacy_Part_II.html","title":"NB00b FSharp Coding literacy part II\n","content":"(**\n# NB00b FSharp Coding literacy part II\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=NB00b_FSharp_Coding_literacy_Part_II.ipynb)\n\n[Download Notebook](https://github.com/CSBiology/BIO-BTE-06-L-7/releases/download/NB00b/NB00b_FSharp_Coding_literacy_Part_II.ipynb)\n\n1. Making sense of sequences\n    1. Strings have their own module \n    2. Bio-collections are F# collections\n    3. All collections have their modules\n    4. Seq module contains the skeleton key functions\n    5. Build a map to associate values with a key \n2. Higher-order functions     \n    1. Functions can consume other functions\n    2. Pipe-forward operator |\u003E \n3. More interesting types \n    1. Tuples are ad hoc data structures \n    2. Record types provide more organization\n\n## Making sense of sequences\n\nSequences are a key part of biology, and therefore, storing, searching, and analyzing protein and nucleic sequences plays an important role in computational biology. \nIn many languages, biological sequences are simply represented as strings. \n\nHere\u2019s a very simple DNA sequence: \n*)\n\nlet mySequence = \u0022atcg\u0022 \n\n(**\nIn F# there are a lot of functions available by default to manipulate strings all of which can be found in the String module. \n\n### Strings have their own module \n\nWe learned previously that modules are simply a container to organize your functionality. To make use of that functionality you need to know the name of the respective \nmodule and be aware that you can access everything with the \u0060.\u0060 operator. The name of the module for \u2018string\u2019 types is \u2018String\u2019 with a capital to distinguish the module \nfrom its type. *- FYI -* this is true for all core types in F#.\n*)\n\nString.length \u0022atcg\u0022\n\n(**\nHere, the \u0060String.Length\u0060 returns the length of the string sequence. If you are using a nice text editor with more sophisticated code completion (intelliSense), you can \nexplore the functionality provided within a module by pressing \u0060Strg \u002B Space\u0060. Otherwise, you need to look it up in one of many [documentations.](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-stringmodule.html)\n\nAnother interesting feature of strings is that their characters can also be accessed according to their numerical position, starting from 0 up to 1 minus the length of the \nstring. You can also slice strings up using a \u0060[from .. to]\u0060 syntax:\n*)\n\n\u0022atcg\u0022.[2]\n\u0022atcg\u0022.[1 .. 2]\n\n(**\nTechnically, strings are specialized collection of characters and we have seen how to represent a nucleotide sequence.\n\n### Bio-collections are F# collections\n\nIn contrast to the alphabet of letters we use in natural language, biological nucleotide and amino acid alphabets have a smaller set of valid characters. This allows us to \nrepresent biological sequence data that encode DNA and proteins more efficiently using BioFSharp.\n*)\n// Get BioFSharp from nuget \n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\nopen BioFSharp \n\nlet adenine = Nucleotides.A\nlet alanine = AminoAcids.Ala\n\n(**\nSequence types or collection types are a series of any items or values rather than only characters. There are different variations of collection types with different properties \nregarding there manipulation and efficiency. To cover all different kinds and their methods to manipulate them would go far beyond the scope of this introduction. So, we will \nfocus on the most important types and methods of manipulation. Collections provide a more flexible way to work with groups of items. In the case of our Bio-collections from \nBioFSharp the items of the biological alphabets. Here is an example of a list of nucleotides: \n*)\nopen BioFSharp.Nucleotides \n\nlet nucs = [ A; T; C; G; ]\n\n(**\nNotice here that we have stored the exact same sequence as in our previous string example, but this time in list format. Notice how the items are separated by a semicolon and\nenclosed in square brackets instead of quotes. Analogously, we can access each item by its index, however, in case of lists this is not very efficient. \n*)\n\n// Accessing position 3 (remember index start at 0)\nnucs.[2]\n// Add elongates the list (very efficient operation on lists)\nlet nucs\u0027 = G::A::nucs\n\n(**\nIf you need a collection type with the opposite properties, meaning fast random access but very inefficient adding or deleting elements an array is what you want to use instead. \nJust add the additional \u0060|\u0060 and you have an array.\n*)\n// The same sequence but as an array\nlet nucsArr = [| A; T; C; G; |]\n\n(**\n### All collections have their modules \n\nWhenever you need functions to manipulate bio-collections, you might find them in the respective module. You can either use intelliSense to browse the available functions or you \ncan have a look at the documentation [here.](https://csbiology.github.io/BioFSharp)\n\nWith functions you find in the Bio-collection modules you can easily compute for example the complementary mRNA sequence or translate it into the corresponding peptide sequence.\n*)\n\n// Reverse complement of a sequence as a BioArray\nBioArray.reverseComplement nucsArr\n\n// Translate to peptide \nBioList.translate 0 [A; U; C; G; C; G]\n\n// Use the Array module to find the index of the first occurring cytosine\nArray.findIndex (fun n -\u003E n = C)  [| A; T; C; G; |]\n\n(**\nHowever, it is worth noticing that the bio-collections are normal F# collections. The Bio* modules just enhance the functionalities of the default modules. In the example, we \napply the \u0060Array.findIndex\u0060 functions from the default array module to a BioArray to find the index of the first occurring cytosine. \n\nA full overview of the default collections and their respective modules can be found [here.](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fsharp-collection-types)\n\n\nThere is one module that you might see quite often when working with collections in F#. It is more generic compared to the others previously discussed as it is able to manipulate \nall enumerable collections. The \u0060Seq.\u0060  module contains functions that can take list collections as well as array collections as input\n (or others that are [enumerable).]( https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fsharp-collection-types).\nIn the following example we apply the same functions to a list and on an array. \n\n### Seq module contains the skeleton key functions\n\nIt is worth mentioning that in the module of F# collections you will find functions to convert from one collection type to another. I believe that you can imagine the reason \nfor such an operation. You know by now that depending on the use case one collection might be advantages compared to the other. For example, if you know that you need to access \nyour sequence multiple times at different position, you want to convert it from a list into an array.\n*)\n\n// Returns the length of the array\nSeq.length [| A; T; C; G; |]\n// Returns the length of the list  \nSeq.length [ A; T; C; G; ]\n// The input is a list type the output an array type \nList.toArray [ A; T; C; G; ]\n\n(**\nDue to those performance issues, certain functionality is only offered on particular collection types and you need to do the conversion first before you can apply this function.\n\n### Build a map to associate values with a key\n\nWe learned that you can access the elements within collections by its numerical position index. To build more complex examples, it might be necessary to have a more sophisticated \nway to associate values with a key. A map is built from a list of key-value pairs using the so-called Map constructor. \n\nThis just means you need to write \u0060Map\u0060 in front of that key-value pair list:\n*)\n\nlet mass = Map [\u0022Hydrogen\u0022,1.0079; \u0022Carbon\u0022, 12.001]\n\n(**\nExtracting a value from a Map work similar to accessing an array using the key instead of the index. \n*)\n\nmass.[\u0022Carbon\u0022]\n\nMap.find \u0022Carbon\u0022 mass\n\n(**\nAnalogously to the List and Array module there is a Map module. \nA full overview of all map function can be found [here]( https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-fsharpmap-2.html).\n\n\n## Higher-order functions     \nIn F# as a functional programming language, you should be able to do with a function whatever you can do with values of the other types and be\n able to do so with a comparable degree of effort. This includes the following:\n* You can bind functions to identifiers and give them names.\n* You can store functions in data structures, e.g. such as in a list.\n* You can pass a function as an argument in a function call. \n* You can return a function from a function call.\nThe last two define what are known as higher-order operations or higher-order functions. A higher-order function is a function that takes another function as a parameter. \nThis is simple but leads to one of the most important concepts of functional programming: *mapping and folding*. \n\n### Functions can consume other functions\n\nMapping is when a function applies computation working on an inner space and then returns the outer space as a result. This sounds complicated, but let\u2019s dive right into it \nand see how this works. We first need a function that will later be the function working on the inner space. The function \u0060monoisoMass\u0060 from the \u0060AminoAcids\u0060 module in \nBioFSharp returns the monoisotopic mass of the given amino acid as the name suggests: \n*)\n\n// Function working on the inner space \nAminoAcids.monoisoMass AminoAcids.Ser\n// Outer or elevated space\nopen AminoAcids\n\nlet peptide = [ Pro; Glu; Pro; Thr; Ile; Asp; Glu; ]\n\n(**\nNow, we want to apply the function \u0060monoisoMass\u0060 to each amino acid in the peptide list. For that we can make use of the \u0060List.map\u0060 function. This is very convenient as the \nrecursive process that steps through the list and builds a list of the results to return. That part is captured in the mapping function. \n*)\n\nList.map AminoAcids.monoisoMass peptide\n\n(**\nThe higher-order function map applies a function working on the normal space to an elevated space. This concept is so important that all collection types (lists, arrays, ...) \nhave a build in map function.  \nIf your higher-order function applies a function to the inner space and the return value is not the outer space, you are folding aka. aggregating. Just to build on the example \nabove, we can compute the sum of all amino acids being elements of the peptide list. \n*)\n\nList.sumBy AminoAcids.monoisoMass peptide\n\n(**\nMaybe it is worth noticing that the mass of water needs to be added to calculate the correct peptide mass.\n\n### Pipe-forward operator |\u003E \n\nF# is all about readability. Here, pipe operators are used to pass parameters to a function in a simple and elegant way. It allows to eliminate intermediate values and \nmake function calls easier to read. It possible to chain function calls and feed the return value of each function to the next using the forward type operator which looks \nlike this: |\u003E . We can literally read it as \u201Cpipe forward\u201D.\n*)\n\n[ Pro; Glu; Pro; Thr; Ile; Asp; Glu; ]\n|\u003E List.map AminoAcids.monoisoMass \n|\u003E List.sum\n\n(**\n\n## More interesting types \n\nWe already learned about type annotation that it defines the kind of the value you and the compiler have to deal with. Therefore, you can think of type annotation as a sort of \ndata modelling tool that allows you to represent a real-world domain in your code. The better the type definitions reflect the real-world domain, the better they will statically  \nencode the rules. This means you will always be warned if you violate the rules you defined. That will help you to avoid mistakes within your code. In practice, if you try to  \nsum binding x \u002B y and x is bound to the number 5 (datatype = int) whereas y is bound to the word \u201CPEPTIDE\u201D (datatype = string) the compiler will not allow it, while if y is \nbound to number 7 you will get 12 as a valid result. \n\nHowever, using only literal or primitive types may be not enough. You most probably want to do something more interesting that is not based solely on numbers or letters. To do \nso you need to be able to produce your own types.   \n\nThe key to understanding the power of types in F# is that most new types are constructed from other types just combing types that already exist. You can think of your own type \ndefinition as an organization or grouping of other types. To do so, every type definition is similar, even though the specific details may vary. All type definitions start with \na \u0022type\u0022 keyword, followed by an name or identifier for the type, which then is followed by any existing type(s). \n\nFor example, here are some type definitions for a variety of types:\n*)\n\ntype A = int * int\n\ntype B = {AminoAcidName: string; Mass: float}\n\n(**\n### Tuples are ad hoc data structures \nTuples have several advantages over other more complex types. They can be used on the fly because they are always available without being defined, and thus are perfect for small, \ntemporary, lightweight structures. Some people think of tuples as small list with a fixed length and different types. If you look at the way to create a list and compare it to a \ntuple, you will see why:\n*)\n// Creating a list\n[ 1.1; 3.5; 2.0 ]\n\n// Creating a tuple by changing the semicolon to a comma and the square brackets to curved brackets\n(  1.1, 3.5, 2.0 )\n\n// Creating another tuple\n( 115.026943, \u0022asp\u0022 )\n\n(**\nHowever, while collections can only contain elements of the same type, with tuples you can combine different types in the same tuple type. Also accessing values from a tuple is quite \ndifferent compared to a collection type. \n\n*)\n// Accessing the value at position 2 of a list\n[ 1.1; 3.5; 2.0 ].[1]\n\n// Accessing the value at position 2 of a tuple\nlet monoMass, threeLetterCode = ( 115.026943, \u0022asp\u0022 )\nthreeLetterCode\n\n(**\nYou notice that accessing a value from a tuple means create a named binding that has the same structure (a process called deconstruction). After this, the individual values have their \nown names and can be used separately. Therefore, it is easy to define functions that can access individual positions of tuple types. \n\nLet\u0027s define a function that returns the three-letter:\n*)\nlet getThreeLetterCode (monoMass, threeLetterCode) =\n    threeLetterCode\n\ngetThreeLetterCode ( 115.026943, \u0022asp\u0022 )\n\n(**\nTuples are also very useful in the common scenario when you want to return multiple values from a function rather than just one.\n*)\n\nlet returnTwoValues () =\n    (\u0027A\u0027,100)\n\n(**\n\n### Record types provide more organization\n\nTuples are useful in many cases. But they have some disadvantages too. Because all tuple types are pre-defined, you can\u0027t distinguish between a string and a float used for an \namino acid mass with one-letter-code say, vs. a similar tuple used for nucleotide. \n\nAnd when tuples have more than a few elements, it is easy to get confused about which element is in which place. In these situations, what you would like to do is label each \nslot in the tuple, which will both document what each element is for and force a distinction between tuples made from the same types. A record type is exactly that: A tuple \nwhere each element is labeled.\n*)\n// Define a record type amino acid\ntype AminoAcidMass = { OneLetterCode: char; Mass: float }\n// Define a record type nucleotide\ntype NucleotideMass = { Symbol: char; Mass: float }\n\n// Bind an amino acid value to a name binding\nlet asp = { OneLetterCode = \u0027D\u0027; Mass = 115.026943 }\n\n(**\nA record type has the standard preamble: \u0060type\u0060 typename = followed by curly braces. Inside the curly braces is a list of label: type pairs, separated by semicolons (notice: We \nwill see later that all lists in F# use semicolon separators -- commas are for tuples).\n\nLet\u0027s compare the \u0022type syntax\u0022 for a record type with a tuple type:\n*)\n\n// Definition of a record type \ntype AminoAcidMassRecord = { OneLetterCode: char; Mass: float }\n// Definition of a tuple type \ntype AminoAcidMassTuple = char * float\n\n(**\nYou see that record types have named fields that make them easily accessible. A Field of a record type can be accessed individually with the dot operator \u0060.Fieldname\u0060\n*)\n\n//Create cysteine  \nlet cys = { OneLetterCode = \u0027C\u0027; Mass = 103.0091848 }\n// Access the one-letter-code of cysteine\ncys.OneLetterCode\n// Access the monoisotopic mass of cysteine and multiply it times 3\ncys.Mass * 3."},{"uri":"/BIO-BTE-06-L-7/changeCSVColumns.html","title":"changeCSVColumns","content":"#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharpAux\u0022\n\nopen Deedle\nopen FSharpAux\n\nlet myPathSDS = @\u0022C:\\Repos\\BIO-BTE-06-L-7\\docs\\downloads\\Quantifications_sds_annotated.txt\u0022\nlet myPathBN = @\u0022C:\\Repos\\BIO-BTE-06-L-7\\docs\\downloads\\Quantifications_bn_annotated.txt\u0022\n\nlet framSDS = Frame.ReadCsv (myPathSDS, separators = \u0022\\t\u0022)\nlet framBN = Frame.ReadCsv (myPathBN, separators = \u0022\\t\u0022)\n\nframSDS.ColumnKeys |\u003E Array.ofSeq\nframBN.ColumnKeys |\u003E Array.ofSeq\n\nlet framSDS\u0027 = framSDS |\u003E Frame.mapColKeys (fun cK -\u003E cK |\u003E String.replace \u00222.5\u0022 \u00222_5\u0022)\nlet framBN\u0027 = framBN |\u003E Frame.mapColKeys (fun cK -\u003E cK |\u003E String.replace \u00222.5\u0022 \u00222_5\u0022)\n\nframSDS\u0027.ColumnKeys |\u003E Array.ofSeq\nframBN\u0027.ColumnKeys |\u003E Array.ofSeq\n\nframSDS\u0027.SaveCsv (myPathSDS |\u003E String.replace \u0022.txt\u0022 \u0022_replaced.txt\u0022, separator = \u0027\\t\u0027, includeRowKeys = false)\nframBN\u0027.SaveCsv (myPathBN |\u003E String.replace \u0022.txt\u0022 \u0022_replaced.txt\u0022, separator = \u0027\\t\u0027, includeRowKeys = false)"},{"uri":"/BIO-BTE-06-L-7/NB00a_FSharp_Coding_literacy_Part_I.html","title":"NB00a FSharp Coding literacy part I\n","content":"(**\n# NB00a FSharp Coding literacy part I\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=NB00a_FSharp_Coding_literacy_Part_I.ipynb)\n\n[Download Notebook](https://github.com/CSBiology/BIO-BTE-06-L-7/releases/download/NB00a/NB00a_FSharp_Coding_literacy_Part_I.ipynb)\n\n1. Getting things done and understand values\n    1. Numeric types\n    2. String or character types\n    3. F# handles your types.\n2. Functions and operators: Do some operations\n    1. Operations and types\n    2. Functions\n3. Namespace and modules\n4. Control flow expressions\n\n\n## Getting things done \n\nThe purpose of this first part is to present the use of F# (pronounced \u201CF Sharp\u201D) programming language to facilitate and automate a wide variety of data manipulation\ntasks typically faced in life science research. Here, we want to support your coding literacy by a practical programming approach without the attempt to detail every \npossible variation of the mechanisms. This offers a rapid introduction to F# programming that should allow you to understand code and do some manipulation to achieve \nyour desired outcome.\n\nThere are many kinds of programming languages, with different purposes, styles, intended uses, etc. However, F# is particularly nice as it is easy to learn in the beginning \nbut also extremely powerful for professional use cases. Simply put, F# is a beautiful language. It is effective for everything from teaching new programmers to advanced\ncomputer science study, from simple scripts to sophisticated advanced applications. Therefore, it is extremely well suited for bioinformatics programming and \napplication in live science.\n\n### Numeric types\n\nDefinitely, F# can be a good friend in your daily work even when you are doing simple calculations, e.g. in the lab. Let\u0027s jump right in and some stuff done:\n*)\n// Define numerical values\nlet co2Oxygens = 2\nlet co2Carbon  = 1\nlet oxygenMass = 15.9994\nlet carbonMass = 12.0107\nlet avogadro = 6.023e23\n(**\nFirst things first: Any text on a line that follows \u0060//\u0060 is handled as a comment and is ignored by the F# compiler. Comments help to write organized code with documentation \nand are therefore not executed as part of your program or script. Additionally, there is also the possibility to write comments that span multiple lines by putting text between \nparenthesis and asterisk \u0060(* \u2026 *)\u0060.\n\nThe example shows the two most common types of numbers used in F#:\n*)\n// integer (\u0060int\u0060)\nlet co2Oxygens = 1\n// floating point numbers (\u0060float\u0060)\nlet oxygenMass = 15.9994\n(**\nOne of the most important action in programming is naming things, which is called binding. Binding is the naming process that associates an identifier (name) to a value or function. \nIn F#, the \u0060let\u0060 keyword is used to do such a binding and bind a name to a value in our example. We can use \u0060let\u0060 binding at various level. It might be worth noting here that this \nprocess is often referred as declaring variables, but using the term \u0022binding\u0022 is much nicer.\nBindings are case sensitive names and can contain letters, numbers as well as the underscore character. They cannot start with a number however and they cannot contain spaces. \n\nThis makes the following three different bindings: \n*)\nlet myvariable = 1\nlet MyVariable = 3.172\nlet MYVARIABLE = \u0022Undefined\u0022\n\n(** \n_But what is a value?_\n\nIn general, computer programs manipulate data. An individual item of data is called a value. F# is a statically typed language and every value has a type that identifies the kind of value it is. \nFor example, the type of \u0060co2Oxygens\u0060 is \u0060int\u0060. Each value can be seen an instance of a particular type, later we will complete this point of view by recognizing that each object is an \ninstance of a particular class (type).\n\n### String or character types\n\nSimilar to declaring numbers in F#, we also can bind text (aka. \u0060string\u0060) or characters to names just by enclosing the declared value in double or single quotes.\n*)\n// Define string or character values\nlet buffer = \u0022Tris\u0022\nlet hydrogenMass = \u00221.00794\u0022\nlet nucleotide = \u0027A\u0027\n(**\nHere, single quotes are used for single character (\u0060char\u0060), while double quotes indicate a string. Importantly, if you would like to use quotes (or other special characters) in a string, you must \nquote the quotes with a backslash \u0060\\\u0060. \n\nOne more way to declare strings in F# that allows you to even include line breaks in the strings. It\u0027s useful, for example, for declaring paragraphs of text as strings. To use it, you have to enclose\nthe string itself in triple quotes.\n*)\nlet poem = \u0022\u0022\u0022\n    Nature\u0027s first green is gold,\n    Her hardest hue to hold.\n    Her early leaf\u0027s a flower;\n    But only so an hour.\n\u0022\u0022\u0022\n(**\nThere are many different specialized primitive types available in F#, [see here](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/literals) for the full overview. However, covering \nBoolean (\u0060bool\u0060) values in the following, we now covered the most common primitive types.\n*)\n\nlet yes = true\nlet no  = false\n\n(**\nVery often, in programming, you will need a data type that can only have one of two values, like: *Yes/No, On/Off or TRUE/FALSE*. A boolean type is declared with the bool keyword and can only take the values \n\u0060true\u0060 or \u0060false\u0060.\n\n### F# handles your types.\nThe F# compiler needs to always know the type of your value. Luckily, this does not mean that you need to specify the type all the time explicitly by yourself. In the process of type inference, the \nF# compiler infers the types of values, variables, parameters and return values.\nThe compiler infers the type based on the context. If the type is not otherwise specified, it is inferred to be generic. If the code uses a value inconsistently, in such a way that there is no single \ninferred type that satisfies all the uses of a value, the compiler reports an error. \n\nWe have seen this happen through all the examples so far, but how does it work and what can you do if it goes wrong?\nIn that case, you can apply explicit type annotations using \u0060: type name\u0060, as shown in the following examples: \n*)\n// Explicitly define the type of on as bool. Brackets () are not necessary\nlet (on : bool) = true\n\n(**\n\n## Functions and operators: Do some operations\n\nIn the beginning, I introduced F# as your friendly pal. Let\u2019s dive into a quick example, that actually does some operations.\n*)\n\nlet co2Oxygens\u0027 = 2\nlet co2Carbon\u0027  = 1\nlet oxygenMass\u0027 = 15.9994\nlet carbonMass\u0027 = 12.0107\n\nlet co2Mass = float co2Oxygens\u0027 * oxygenMass\u0027 \u002B float co2Carbon\u0027 * carbonMass\u0027\n\nprintfn \u0022Molecular weight of CO2 = %f\u0022 co2Mass\n\n\n(**\nHere we use the bindings we did before to calculate the mass of a CO2 molecule and bind the result to the name co2Mass. In the next line \u0060printfn\u0060 is used to output the result to the F# console which is the \ndefault stream for any output from the code. \nIf you run this code into your interactive notebook and saw the output, you just ran your first, small F# program!\n\n### Operations and types\n\nThe F# type system makes sure that you can not mix types during calculation. While it is possible to concatenate two string using the \u0060\u002B\u0060 operator. However, using two different types will cause the compiler \nto point out the error.  \n\nIt is worth to notice, that because \u0060int\u0060 and \u0060float\u0060 are different types even though they are both numbers. Therefore, to calculate the example above it is necessary to explicitly cast between \u0060int\u0060 and \u0060float\u0060 for \noperations such as multiplication.\n\n### Functions \n   \n\nAt this point we have our first functionality, meaning a small F# program that can perform a calculation. In most cases you want to organize the functionalities your code provides into nice building blocks that \ncan be reused and applied multiple times. You can think of functions as exactly those kinds of self-contained building blocks of code that accomplish a specific task. Functions usually consume input data called \nparameter, process it in their function body, and return a result. Once you have a function defined, it can be used over and over and over again. \nThe best way to understand an F# function is to see it in action. Let\u2019s dive into it:\n*)\n\n// Example of indented code\nlet explainIndentedCode () =\n    printfn \u0022This indented line is part of the function\u0022\n    printfn \u0022So is this one\u0022\nprintfn \u0022This unindented line is not a part of the function\u0022\n\n(**\nThis code exemplifies two important point. First, indentation is syntactically meaningful in F# and not just for comfortable reading. It is used to show which particular block of code belongs together. Therefore, \nall code inside a function must be indented to define it as belonging to the function.\n\nSecondly, functions can be called from the inside of other functions. Here, we use the \u0060printfn\u0060 function you already know inside the outer function.  The function \u0060printfn\u0060 is a build in function and is already \ndefined in the core of F#. Thus, we do not need to define it ourselves and can call it as we desire.\n\nWith this knowledge we can do a more meaningful example:\n*)\n\n//A simple function to calculate molar volumes\nlet calculateGasDensity molarMass pressure temperatureK =\n    let gasConstant = 0.082057\n    let density : float = (molarMass * pressure) / (gasConstant * temperatureK)\n    density\n\nlet co2MolarVolume = calculateGasDensity co2Mass 4. 546.\nprintfn \u0022The density of carbon dioxide at 546 K and 4.00 atmospheres pressure is %f g/L\u0022 co2MolarVolume\n\n(**\nAs the biochemistry textbooks tell us, the density of 1 mole of CO2 at 546 Kelvin and 4.00 atmospheres pressure is indeed 3.93 g/L. We make use of the \u0060let\u0060 keyword and define or declare our function, followed by the function call where the result is \nbound to the name \u0060co2MolarVolume\u0060.\n\n*Side note:* Signature of a function\n\nA function signature shows the function prototype. It tells you name, input type(s) and output type of a function. You will later learn that the type defines the kind of the value for functions to act upon (input) \nand return (output). Just by examining a function\u2019s signature, you can often get some idea of what it does.\n\n*Side note:* Lambda expressions\n\nIn F# it is possible to use function without giving them a name and use the keyword \u0060fun\u0060 instead and the \u0060=\u0060 becomes \u0060-\u003E\u0060. This is called anonymous function or referring to lambda calculus lambda expression. \nThis kind of functions are often used for convenience. To write \u0027add1\u0027 as lambda expression \u0060fun x -\u003E x \u002B 1\u0060\n\n## Namespace and modules\n\nSometimes it can be necessary to go a little bit further in terms of code organization. For example, to ship code in a library to other users. Namespaces und Modules are top-level and low-level constructs to \norganize code. You can think of namespaces and modules as containers and sub containers, respectively, in which you can put function and type definitions. The hierarchy is defined that you can have multiple \nmodules in one namespace, also nested modules in a module, but no namespace in another namespace. \n\nThe most important bit is, that you can access namespaces and modules with the \u0060.\u0060 operator. This is also how you find functionality in libraries which you can load from other sources.  This is required because \nit means you do not need to write all code and functionality by yourself.\nIn the following you can see how you can profit from the amazing F# community efforts to provide you with various libraries. It seems obvious that for our example we load BioFSharp.\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n\n// Access adenine without \u0027open\u0027\nBioFSharp.Nucleotides.A\n\n// Access adenine with \u0027open\u0027\nopen BioFSharp\nNucleotides.A\n\n(**\nThe first line automatically pulls the necessary files from the internet and allows you to use the library in your scripting environment. Due to the \u0060open\u0060 statement you can shorten the path to access the modules \nand functions in the library. This just saves you the effort to always type \u0060BioFSharp.\u0060 in front of everything\u2026 \n\n## Control flow expressions\n\nEverything you have seen so far has consisted of sequential execution, in which expressions are always evaluated one after the next, in exactly the order specified. But the world is often more complicated than that. \nFrequently, a program needs to skip over or choose between alternate sets of paths to execute.\nThat is where control structures come in. A control structure directs the order of evaluation of expressions in a program (referred to as the program\u2019s control flow).\n*)\n\n//Function for calculating buffer recipes that uses if-conditionals \nlet bufferRecipe buffer molarity =\n    let grams = \n        if buffer = \u0022Tris\u0022 then\n            121.14\n        elif buffer = \u0022MES\u0022 then\n            217.22 \n        elif buffer = \u0022HEPES\u0022 then\n            238.30 \n        else\n            failwith \u0022Huh???\u0022\n    let gramsPerLiter = grams * molarity \n    gramsPerLiter\n\n(**\nThe function \u0060bufferRecipe\u0060 takes two arguments that specify the name of the \u0060buffer\u0060 and \u0060molarity\u0060 of the stock solution you want to make. Based upon the buffer name that you provide; it then binds the appropriate value \nto the name grams and returns the required weight of buffer (in grams) to make up a 1 L solution.\n\nAs with other programming languages, the equality operator in F# is just one of a bunch of comparison you can do:\n\n* \u0060=\u0060  equals \n* \u0060\u003C\u003E\u0060 not equals\n* \u0060\u003E\u0060 greater than \n* \u0060\u003C\u0060 less than \n* \u0060\u003E=\u0060 greater than OR equals \n* \u0060\u003C=\u0060 less than OR equals\n\nHowever, there is a more powerful control flow construct called Matching expression. You can write the \u0060bufferRecipe\u0060 example from above as follows:\n*)\n\n//Function for calculating buffer recipes that uses match-conditions \nlet bufferRecipe\u0027 buffer molarity =\n    let grams =\n        match buffer with\n        | \u0022Tris\u0022  -\u003E 121.14\n        | \u0022MES\u0022   -\u003E 217.22 \n        | \u0022HEPES\u0022 -\u003E 238.30 \n        | _       -\u003E failwith \u0022Huh???\u0022\n    grams * molarity \n    \n\n(**\nEach \u0060|\u0060 defines a condition, the \u0060-\u003E\u0060 means \u0022if the condition is true, follow this path...\u0022. The \u0060_\u0060 is the default pattern, meaning that it matches anything, sort of like a wildcard. Occasionally, it\u0027s not enough to \nmatch an input against a particular value; we can add filters, or guards, to patterns using the \u0060when\u0060 keyword. We can rewrite our \u0060bufferRecipe\u0060 function once again. \n*)\n\n//Function for calculating buffer recipes that uses match-conditions with guards\nlet bufferRecipe\u0027\u0027 buffer molarity =\n    let grams =\n        match buffer with\n        | x when x = \u0022Tris\u0022  -\u003E 121.14\n        | x when x = \u0022MES\u0022   -\u003E 217.22 \n        | x when x = \u0022HEPES\u0022 -\u003E 238.30 \n        | _       -\u003E failwith \u0022Huh???\u0022\n    grams * molarity \n    \n(**\nMaybe we should notice that in this function we use the function \u0060failwith\u0060 to throw an error, if we do not know the buffer. This is not particular nice, however necessary in our example. \n*)"},{"uri":"/BIO-BTE-06-L-7/NB01b_Plant_Systems_Biology.html","title":"NB01b Plant Systems Biology\n","content":"(** \n# NB01b Plant Systems Biology\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=NB01b_Plant_Systems_Biology.ipynb)\n\n[Download Notebook](https://github.com/CSBiology/BIO-BTE-06-L-7/releases/download/NB01a_NB01b/NB01b_Plant_Systems_Biology.ipynb)\n\n1. Plant Systems Biology\n2. Modeling growth\n1. Insert growth data and display as chart\n2. Calculation of growth rate and doubling time for cell cultures\n3. Fitting biological growth curves\n    1. Theory\n    2. Model selection\n4. Calculate cell doubling time\n5. Questions\n6. References\n\n*)\n\n(** \n## Plant Systems Biology\n\nThe general paradigm of Systems Biology clearly applies to plants, as they represent complex biological systems. \nThe functioning of a plant as a biological system is the result of a combination of multiple intertwined and dynamic interactions between its components. \nIn addition, most plants are sessile systems that have to face fluctuating environmental conditions, including biotic and abiotic stresses (Ruffel et al. 2010).\nThe process of a biological system responding to changes in environmental conditions is termed acclimation. These molecular physiological responses represent a complex \ndynamic adjustment of the interplay between genes, proteins and metabolites that allows the organism to acclimate to the changing environment. \nThe ability to acclimate ensures the survival of all living organisms and is therefore fundamental for the understanding of biological systems. \nDetailed knowledge about how plants acclimate to a changing environment is crucial especially in times of global climate changes, \nas plants are of great importance for our quality of life as a key source of food, shelter, fiber, medicine, and fuel (Minorsky 2003).\n\nThe prominent model plant *Arabidopsis thaliana* is well suited for plant Systems Biology studies because sophisticated experimental tools and extensive data \ncollections are readily available (Van Norman et al. 2009). However, the importance of a model organism is not only coined by the availability of molecular \ntools to manipulate the organism, but also by its agricultural and economic impact like in the cases of tobacco, rice, maize or \nbarley (P\u00E3curar 2009). Also microalgae are of special economic interest due to their potential as biofuel producers (Cagnon et al. 2013). \nAdditionally, the use of organisms with lower biological complexity facilitates the feasibility of System Biology studies and is an important factor to consider \nfor the choice of a suitable model organism in Systems Biology.\n\nThe eukaryotic green alga *Chlamydomonas reinhardtii* is particularly well suited for plant Systems Biology approaches. \nThis unicellular freshwater and soil-dwelling alga has a single, cup-shaped chloroplast with a photosynthetic apparatus that is similar to \nthat of higher plants (Eberhard et al. 2008, Merchant et al. 2007). Hence, results gained on photosynthesis processes in *Chlamydomonas* \nare likely to be transferable to higher plants. The nuclear, mitochondrial, and chloroplast genomes have been sequenced and tools for manipulating them \nare available (Merchant et al. 2007). *Chlamydomonas* cells have a size of ~10 \u00B5m and grow under photo-, mixo-, and heterotrophic conditions \nwith a generation time of ~5-8 h (Harris, 2008). *Chlamydomonas* can be maintained under controlled conditions and environmental \nchanges can be applied homogeneously and rapidly to all cells in a liquid culture. In contrast to multicellular organisms there are no influences by \ntissue heterogeneity. Even the influence of different cell cycle stages may be ruled out by performing experiments with asynchronous cell cultures \n(Bruggeman and Westerhoff 2007, Harris 2001). Finally, gene families in *Chlamydomonas* have fewer members than those in higher plants thus facilitating the \ninterpretation of results involving many genes/proteins (Merchant et al. 2007).\n*)\n\n(** \n## Modeling growth\n\nIn order to solve real world tasks more convenient, F# provides a huge collection of additional programming libraries. \nAnything that extends beyond the basics must be written by a user. If the chunk of code is useful to multiple different users, \nit\u0027s often put into a library to make it easily reusable. A library is a collection of related pieces of code that have been compiled \nand stored together in a single file and can than be used an included. The most important libraries in F# for bioinformatics are:\n\n\n* [BioFSharp](https://csbiology.github.io/BioFSharp/): Open source bioinformatics and computational biology toolbox written in F#\n* [FSharp.Stats](https://github.com/fslaborg/FSharp.Stats): F# project for statistical computing\n* [Plotly.NET](https://github.com/plotly/Plotly.NET): .NET interface for plotly.js written in F# \uD83D\uDCC8\n\n\nThe first real world use case of F# in Systems Biology is to model growth for a defined cell number to see possible overexpression effects. \nBiologists often utilize growth experiments to analyze basic properties of a given organism or cellular model. For a solid comparison of data \nobtained from different experiments and to investigate the speci\uFB01c effect of a given experimental set up, modeling the growth is needed after recording the data. \n\nThis notebook introduces the most classical way to model growth of *Chlamydomonas reinhardtii* or any other growth data using F#.\n\nNow, let\u0027s get started by loading the required libraries first.\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.3\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.16\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.16\u0022\n#endif // IPYNB\n\nopen System\nopen Plotly.NET\nopen FSharp.Stats\n\n(** \n## Insert growth data and display as chart\n\nA standard cell culture experiment with cell count measurements will result in data like the following.\nMultiple cell counts (\u0060y_Count\u0060), each related to a specific timepoint (\u0060x_Hours\u0060).\n*)\n// Code-Block 1\n\nlet exmp_x_Hours = [|0.; 19.5; 25.5; 43.; 48.5; 67.75|]\nlet exmp_y_Count = [|1659000.; 4169000.; 6585400.; 16608400.; 17257800.; 18041000.|]\n\n// Such data can easily be display with the following code block.\n// Chart.Point takes a sequence of x-axis-points and a series of y-axis-points as input\nlet example_Chart_1 = \n    Chart.Point(exmp_x_Hours,exmp_y_Count)\n    // some minor styling with title and axis-titles.\n    |\u003E Chart.withTitle \u0022Growth curve of Chlamydomonas reinhardtii cell cultures\u0022\n    |\u003E Chart.withYAxisStyle (\u0022Number of cells\u0022)\n    |\u003E Chart.withXAxisStyle (\u0022Time [hours]\u0022)\n\nexample_Chart_1\n(***hide***)\nexample_Chart_1 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\n## Calculation of growth rate and doubling time for cell cultures\n\nThe standard growth of an in vitro cell culture is defined by three phases. The lag phase in which the cells still acclimate to the growth conditions, the exponential growth, \nalso called log phase, during which cell growth is exponential due to the iterative proliferation of cells into two daughter cells, and the stationary phase in which the growth rate and the \ndeath rate are equal. The stationary phase is typically initiated due to limitations in growth conditions, e.g. depletion of essential nutrients or accumulation of toxic/inhibitory \nexcretions/products. The doubling time (or generation time) defines a time interval in which the quantity of cells doubles.\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/growthCurve.png)\n\nGrowth data always should be visualized in log space. Therefore the count data must be log transformed. When a log2 transform is applied, \na doubling of the original counts is achieved, when the value increase 1 unit. \nKeeping that in mind, the slope of the growth function can be used to calculate the time it takes for the log transformed data to increase 1 unit.\n\nThe corresponding chart of the log transformed count data looks like this:\n\n*)\n// Code-Block 2\n\n// log transform the count data with a base of 2\nlet exmp_y_Count_Log = exmp_y_Count |\u003E Array.map log2\n\nlet example_Chart_2 = \n    Chart.Point(exmp_x_Hours,exmp_y_Count_Log)\n    |\u003E Chart.withTitle \u0022Growth curve of Chlamydomonas reinhardtii cell cultures\u0022\n    |\u003E Chart.withYAxisStyle (\u0022Number of cells [log2]\u0022)\n    |\u003E Chart.withXAxisStyle (\u0022Time [hours]\u0022)\n\nexample_Chart_2\n(***hide***)\nexample_Chart_2 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)  \n\n(**\n\nAfter the log transform the exponential phase becomes linear. Since a y axis difference of 1 corresponds to a doubling of the cells the generation time can simply be estimated by determination of how many hours are required for the data to span one y axis unit.\nIn this case it seems, that the time required to get from y=22 to y=23 takes approximately 10 hours. \n\nAs you may noticed we just determined the cell doubling time per eye. \nThe formalization of this process is trivial. \n\n  - The y-value increment that is required for doubling can be calculated by log_x(2) where x defines the used base. So for log2 transformed data it is 1 (log2(2)).\n\n  - The generation time is calculated by dividing this y-value increment by the growth rate which is the steepest slope of the log transformed data (approximately 0.1 in the given data). The steepest slope in growth curves always occurs at the inflection point of the sigmoidal function shape.\n\nSo all we have to know is the performed log transform and the slope of the function at its steepest point and afterwards apply the following equation.\n\n\n*Equation 1: Calculation of the doubling time. Growth rate is the steepest slope of the log transformed count data.*\n\n![](https://latex.codecogs.com/png.latex?doubling\u0026space;Time\u0026space;=\u0026space;\\frac{log_x(2)}{growthRate})\n\nFor a log2 transform the numerator is 1.\n\n*)\n\n(** \n## Fitting biological growth curves\n\n\u003Cbr\u003E\n\n### Theory\n\nTo derive the slope required for the doubling time calculation, the measured growth data points have to be modelled. \nIn order to obtain a continuous function with known coefficients, a suitable model function is fitted onto the existing data. \nMany models exist, each one of them optimized for a specific task (Kaplan et al. 2018).\n\nLinear model function example: ![](https://latex.codecogs.com/png.latex?f(x)\u0026space;=\u0026space;mx\u0026space;\u0026plus;\u0026space;b)\n \nWhen a model function is fitted onto the data, there are endless possibilities to choose coefficients of the model function. \nIn the case above there are two coefficients to be identified: The slope m and the y-intercept b. But how can the best fitting coefficients be determined?\n\nTherefore a quality measure called ***Residual Sum of Squares (RSS)*** is used. It describes the discrepancy of the measured points \nand the corresponding estimation model. If the discrepancy is small, the RSS is small too.\n\nIn regression analysis the optimal set of coefficients (m and b) that [minimizes the RSS is searched](https://mathworld.wolfram.com/LeastSquaresFitting.html).\n\nIf there is no straightforward way to identify the RSS-minimizing coefficient set, then the problem is part of nonlinear regression. \nHere, initial coefficients are guessed and the RSS is calculated. Thereafter, the coefficients are modified in tiny steps. \nIf the RSS decreases, the direction of the coefficient change seems to be correct. \nBy [iteratively changing coefficients](https://books.google.de/books?id=rs51DwAAQBAJ\u0026pg=PA422\u0026lpg=PA422\u0026dq=rss\u002Bminimizing\u002Bsolver\u0026source=bl\u0026ots=qZ0Y4cYtM-\u0026sig=ACfU3U0rHGWCmTo_kv5wqYMmSo8ZKyj5Pg\u0026hl=de\u0026sa=X\u0026ved=2ahUKEwjKtdf-oaHoAhUUwsQBHX07DTwQ6AEwBHoECAkQAQ#v=onepage\u0026q=rss%20minimizing%20solver\u0026f=false)\n, the optimal coefficient set is determined when no further change leads to an decrease in RSS. \nAlgorithms, that perform such a \u0027gradient descent\u0027 methods to solve nonlinear regression tasks are called ***solver*** \n(e.g. Gauss-Newton algorithm or Levenberg\u2013Marquardt algorithm). [Introduction to RSS and optimization problems.](https://www.youtube.com/watch?v=sDv4f4s2SB8)\n\n### Model selection\n\nDepending on the given problem, different models can be fitted to the data. Several growth models exist, each is specialized for a particular problem. See [Types of growth curve](http://www.pisces-conservation.com/growthhelp/index.html) or [FSharp.Stats - Growth Curve](https://fslab.org/FSharp.Stats/GrowthCurve.html) for more information.\n\nThe selected model should match the theoretical (time) course of the studied signal, but under \nconsideration of Occams razor principle. It states, that a approriate model with a low number of coefficients should be preferred over a \nmodel with many coefficients, since the excessive use of coefficients leads to overfitting.\n\nA often used growth curve model is the four parameter [Gompertz model](https://en.wikipedia.org/wiki/Gompertz_function). \n\nThe function has the form: ![](https://latex.codecogs.com/png.latex?A\u002BCe^{-e^{-B(t-M)}}) [Gibson et al. 1988](https://www.sciencedirect.com/science/article/pii/0168160588900517?via%3Dihub). \n\nwhere:\n\n  - A = curve minimum\n\n  - B = relative growth rate (not to be confused with absolute)\n\n  - C = curve maximum - curve minimum (y range)\n\n  - M = x position of inflection point\n\n  - t = time point\n\nIn the following, we will go through the necessary steps to calculate the generation time with the help of a Gompertz model.\nWhile the curve minimum and maximum are easy to define by eye, to estimate the remaining coefficients is a nontrivial task.\n\nFSharp.Stats provides a function, that estimates the model coefficients from the data and a guess of the expected generation time. For Chlamydomonas the initial guess would be 8 hours.\n\n\n*)\n// Code-Block 3\n\n// open module in FSharp.Stats to perform nonlinear regression\nopen FSharp.Stats.Fitting.NonLinearRegression\n\n// The model we need already exists in FSharp.Stats and can be taken from the \u0022Table\u0022 module.\nlet modelGompertz = Table.GrowthModels.gompertz\n\n// The solver, that iteratively optimizes the coefficients requires an initial guess of the coefficients.\n// The following function was specifically designed to estimate gompertz model coefficients from the data\n// You have to provide the time data, the log transformed count data, the expected generation time, and the used log transform\nlet solverOptions = Table.GrowthModels.getSolverOptionsGompertz exmp_x_Hours exmp_y_Count_Log 8. log2\n\n// sequence of initial guess coefficients\nsolverOptions.InitialParamGuess\n\n(***hide***)\nsolverOptions.InitialParamGuess\n(***include-it-raw***)  \n\n(** \nThe initial coefficient estimations match the expectations. \n\n  - A = 20.7\n  - B = 0.099\n  - C = 3.4\n  - M = 19.5\n  \n*)\n// Code-Block 4\n\n// By solving the nonlinear fitting problem, the optimal model coefficients are determined. \n// The solver iteratively changes the coefficients until the model function fits the data best.\nlet gompertzParams =\n    LevenbergMarquardt.estimatedParams // The Levenberg Marquardt is used as solver\n        modelGompertz    // The gompertz model is used as growth model\n        solverOptions    // The initial guess of the coefficients\n        0.1              // Parameter required from the solver\n        10.              // Parameter required from the solver\n        exmp_x_Hours     // The time data\n        exmp_y_Count_Log // The transformed count data\n\ngompertzParams\n(***hide***)\ngompertzParams\n(***include-it-raw***)\n\n(**\nThe model coefficients were determined to be:\n\n- A = 20.66\n- B = 0.107\n- C = 3.52\n- M = 19.63\n\nThey are pretty close to the initial estimations that were determined in Code-Block 3 With the coefficients at hand, the model function can be filled with coefficients and can be used to create a fit to the data.\n\n*)\n// Code-Block 4\n\n// Create fitting function from optimal coefficients\nlet fittingFunction = modelGompertz.GetFunctionValue gompertzParams\n\n// Fit the optimized model function to all x values from 0 to 70 hours.\nlet fittedValuesGompertz =\n    [0. .. 0.1 .. 70.]\n    |\u003E Seq.map (fun x -\u003E x,fittingFunction x) \n    |\u003E Chart.Line\n    \n\n// combine the raw data and the fit into one chart\nlet fittedChartGompertz = \n    [\n        example_Chart_2      |\u003E Chart.withTraceName \u0022raw data\u0022\n        fittedValuesGompertz |\u003E Chart.withTraceName \u0022gompertz model\u0022\n    ]\n    |\u003E Chart.combine\n\nfittedChartGompertz\n(***hide***)\nfittedChartGompertz |\u003E GenericChart.toChartHTML\n(***include-it-raw***)  \n\n(**\n    \n## Calculate cell doubling time\n\nTo calculate the doubling time it is necessary to determine the growth rate (gr) for *equation 1*.\nAs discussed above the growth rate is the maximal slope of the model function. It always occurs at the inflection point, which we know is at x=19.628. \nAfter calculating the first derivative of the model function, we would be able to calculate the growth rate as the slope at the inflection point.\nLuckily, there is a short cut when using the Gompertz model. It allows the determination of generation times from its parameters (see Gibson et al. 1988 for details).\n\n\n*)\n\nlet getGenTimeFromGompertz (parameterVector: vector) (logTransform: float -\u003E float) =\n    logTransform 2. * Math.E / (parameterVector.[1] * parameterVector.[2])\n\nlet genTime = getGenTimeFromGompertz gompertzParams log2\n\nlet gt = sprintf \u0022The generation time is %.2f hours.\u0022 genTime\n\n(***hide***)\ngt\n(***include-it-raw***)\n\n\n(**\n\u003Cbr\u003E\n## Questions:\n\n1. Why is it useful to use a log2 transform rather than a ln, log10, or any other log transform?\nHint: Define your own exponentially growing cell counts with a generation time of 1 and transform them using different log transforms.\n\n2. Why is it not sufficient to fit the (raw or transformed) data using the possibilities Excel offers? \nHint: Which models are available and why are these not always appropriate?\n\n3. Calculate the generation time of the following data. Compare the time points of maximal slope of the raw data and the transformed data by eye. Without the log transform you are blind for the actual point of maximal growth.\n\n*)\nlet rawX_hours = [|0. .. 12.|]\nlet rawY_count = [|2.;2.2;2.9;5.;9.5;19.;38.;65.;85.;90.;91.;91.;91.;|]\n(**\n\n\n## References\n\n8. Ruffel, S., Krouk, G. \u0026 Coruzzi, G. M. A systems view of responses to nutritional cues in Arabidopsis: toward a paradigm shift for predictive network modeling. Plant physiology 152, 445\u2013452; 10.1104/pp.109.148502 (2010).\n9. Minorsky, P. V. Achieving the in Silico Plant. Systems Biology and the Future of Plant Biological Research. Plant physiology 132, 404\u2013409; 10.1104/pp.900076 (2003).\n10. Van Norman, Jaimie M \u0026 Benfey, P. N. Arabidopsis thaliana as a model organism in systems biology. Wiley interdisciplinary reviews. Systems biology and medicine 1, 372\u2013379; 10.1002/wsbm.25 (2009).\n11. P\u00E3curar, D. I. Model organisms - a journey from the dawn of biological research to the post-genomic era. Romanian Society of Biological Sciences, 4087\u20134094 (2009).\n12. Cagnon, C. et al. Development of a forward genetic screen to isolate oil mutants in the green microalga Chlamydomonas reinhardtii. Biotechnology for biofuels 6, 178; 10.1186/1754-6834-6-178 (2013).\n13. Eberhard, S., Finazzi, G. \u0026 Wollman, F.-A. The dynamics of photosynthesis. Annual review of genetics 42, 463\u2013515; 10.1146/annurev.genet.42.110807.091452 (2008).\n14. Merchant, S. S. et al. The Chlamydomonas genome reveals the evolution of key animal and plant functions. Science (New York, N.Y.) 318, 245\u2013250; 10.1126/science.1143609 (2007).\n15. Harris, E. H. The chlamydomonas sourcebook. 2nd ed. (Academic, London, 2008).\n16. Bruggeman, F. J. \u0026 Westerhoff, H. V. The nature of systems biology. Trends in microbiology 15, 45\u201350; 10.1016/j.tim.2006.11.003 (2007).\n17. Harris, E. H. CHLAMYDOMONAS AS A MODEL ORGANISM. Annual review of plant physiology and plant molecular biology 52, 363\u2013406; 10.1146/annurev.arplant.52.1.363 (2001).\n18. Kaplan, S. et al. Comparison of growth curves using non-linear regression function in Japanese squail. Journal of Applied Animal Research 46, 112-117; 10.1080/09712119.2016.1268965 (2018).\n19. Gibson, A., Bratchell, N., Roberts, T.A., Predicting microbial growth: growth responses of salmonellae in a laboratory medium as affected by pH, sodium chloride and storage temperature, International Journal of Food Microbiology, Volume 6, Issue 2,  https://doi.org/10.1016/0168-1605(88)90051-7 (1988).\n*)"},{"uri":"/BIO-BTE-06-L-7/NB01a_Systems_Biology_FSharp_Introduction.html","title":"NB01a Systems Biology\n","content":"(**\n# NB01a Systems Biology\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=NB01a_Systems_Biology_FSharp_Introduction.ipynb)\n\n[Download Notebook](https://github.com/CSBiology/BIO-BTE-06-L-7/releases/download/NB01a_NB01b/NB01a_Systems_Biology_FSharp_Introduction.ipynb)\n\nThis notebook introduces the field of Systems Biology and explains why programming is a necessary skill to it.\n\n1. Systems Biology: A brief introduction\n\n3. References\n\n## Systems Biology: A brief introduction\n\n\nThe term \u201Csystems theory\u201D was introduced by the biologist L. von Bertalanffy. He defined a system as a set of related components that work together in a particular environment to perform whatever \nfunctions are required to achieve the system\u0027s objective (Bertalanffy 1945). The hierarchical organization orchestrating the interaction of thousands of molecules with individual \nproperties allows complex biological functions. Biological processes like cell division, biomass production, or a systemic response to perturbations are molecular physiological functions \nwhich result from a complex dynamic interplay between genes, proteins and metabolites (Figure 1). To gain a holistic understanding of a biological system, all parts of the \nsystem need to be studied simultaneously by quantitative measures (Sauer et al. 2007). The focus on a system-wide perspective lies on the quantitative understanding of the \norganizational structure, functional state, robustness and dynamics of a biological system and led to the coining of the term \u201CSystems Biology\u201D(Kitano 2002a).\n\nThe current challenges of Systems Biology approaches are mainly along four lines (Sauer et al. 2007, Joyce and Palsson 2006): \n\n - (**i**) - system-wide quantification of transcriptome, proteome (including protein modifications) and metabolome\n \n - (**ii**) - identification of physical interactions between these components\n \n - (**iii**) - inference of structure, type and quantity of found interactions\n \n - (**iv**) - analysis and integration of the resulting large amounts of heterogeneous data. It becomes obvious that an interdisciplinary effort is needed to resolve these challenges in Systems Biology (Aderem 2006). Here Biology dictates which analytical, experimental and computational methods are required.\n\nModern analytical methods to measure the identity and quantity of biomolecules system-wide, summarized under the term \u201Cquantitative omics\u201D-technologies, address the first two \nmentioned challenges of Systems Biology. Among these \u201Comics\u201D-technologies are transcriptomics based on microarrays/next generation sequencing and proteomics/metabolomics based on mass-spectrometry.\n\nTying in with the area of genome sequencing, the focus is set on the accurate profiling of gene/protein expression and metabolite concentrations, as well as on the determination of biological \nprotein modifications and of physical interactions between proteins.\n\nAddressing the abovementioned challenges three and four of Systems Biology, the development of numerous computational approaches reaches out to unravel the \nintrinsic complexity of biological systems (Kahlem and Birney 2006). These computational approaches focus on knowledge discovery and on in silico \nsimulation or modeling (Kitano 2002b). In the latter approach knowledge on a biological process is converted into a mathematical model. \nIn silico simulations based on such a model can provide predictions that may subsequently be tested experimentally. Computation-based knowledge discovery \n(also known as data mining) aims to extract hidden patterns from complex and high-dimensional data to generate hypotheses. Therefore, the first step is to describe \ninformation on a biological system such that it is sustainably stored in a format rendering it readable and manipulable for machines and humans. The second step is \nto integrate the huge amount of differently structured data, often referred to as the \u201Cbig data\u201D challenge. In a last step, statistical or machine learning methods \nare applied to extract the information or underlying principles hidden in the data.\n\nThe most flexible way of working with huge amounts of data is using a lightweight programming language with a succinct syntax. Therefore, it becomes necessary that biologist become familiar with a suitable programming language to solve real world problems in (Systems) Biology.\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/OmicSpace.png)\n\n***Figure 1: A conceptual view of the omic space.***\n\nThe omics space comprises of genomic, transcriptomic, proteomic, metabolomic and phenomic systems level represented as a plane. Complex biological function is the result of the interplay between molecules of one and/or different systems level.\n*)\n\n(**\n\n## References\n\n1. Bertalanffy, L. von. Zu einer allgemeinen Systemlehre. Bl\u00E4tter f\u00FCr deutsche Philosophie 18 (1945).\n2. Sauer, U., Heinemann, M. \u0026 Zamboni, N. Genetics. Getting closer to the whole picture. Science 316, 550\u2013551; 10.1126/science.1142502 (2007).\n3. Kitano, H. Systems biology. a brief overview. Science 295, 1662\u20131664; 10.1126/science.1069492 (2002).\n4. Joyce, A. R. \u0026 Palsson, B. O. The model organism as a system. integrating \u0027omics\u0027 data sets. Nat Rev Mol Cell Bio 7, 198\u2013210; 10.1038/Nrm1857 (2006).\n5. Aderem, A. Systems biology. Its practice and challenges. Cell 121, 511\u2013513; 10.1016/j.cell.2005.04.020 (2005).\n6. Kahlem, P. \u0026 Birney, E. Dry work in a wet world. computation in systems biology. Mol Syst Biol 2 (2006).\n7. Kitano, H. Computational systems biology. Nature 420, 206\u2013210; 10.1038/nature01254 (2002).\n*)"}]