[{"uri":"/BIO-BTE-06-L-7/JP06_Retention_time_and_scan_time.html","title":"JP06 Retention time and scan time\n","content":"(**\n# JP06 Retention time and scan time\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP06_Retention_time_and_scan_time.ipynb)\n\n1. [Retention time and scan time](#Retention-time-and-scan-time)\n    1. [m/z calculation of the digested peptides](#m/z-calculation-of-the-digested-peptides)\n    2. [Determination of peptide hydrophobicity](#Determination-of-peptide-hydrophobicity)\n*)\n\n(**\n## Retention time and scan time\n\u003Ca href=\u0022#Retention-time-and-scan-time\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nIn general, peptides are separated by one or more steps of liquid chromatography (LC). The retention time (RT) is the time when the measured \npeptides were eluting from the column and is therefore influenced by the physicochemical interaction of the particular peptide with the \ncolumn material. Scan time is basically synonym to retention time, but more from the point of view of the device.\n\nThe aim of this notebook is to understand that even though peptides are roughly separated by the LC, multiple peptides elute at the same \nretention time and are recorded within one MS\u003Csup\u003E1\u003C/sup\u003E spectrum. Here, we will simulate a MS\u003Csup\u003E1\u003C/sup\u003E spectrum by random sampling from \nour previously generated peptide-mass distribution. Further, we will try to improve our simulation by incorporating information about the peptide \nhydrophobicity. It is a only a crude model, but considers the fact that less hydrophobic peptides elute faster from the \u003Csup\u003E13\u003C/sup\u003EC LC column.\n\nAs always, we start by loading our famous libraries.\n\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#load @\u0022..\\AuxFsx\\JP06_Retention_time_and_scan_time_Aux.fsx\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen BioFSharp\nopen Plotly.NET\nopen BioFSharp.Elements\nopen JP06_Retention_time_and_scan_time_Aux\n\nopen FSharp.Stats\n\n(**\n## m/z calculation of the digested peptides\n\u003Ca href=\u0022#Retention-time-and-scan-time\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nI think you remember the protein digestion process from the privious notebook (see: \u003Ca href=\u0022JP04_Digestion_and_mass_calculation.ipynb\u0022\u003EJP04 \nDigestion and mass calculation\u003C/a\u003E). This time we also remember the peptide sequence, because we need it later for hydrophobicity calculation. \n\u003C/div\u003E\n*)\n\n// Code-Block 1\n\nlet source = __SOURCE_DIRECTORY__\nlet filePath = source \u002B @\u0022/../AuxFiles/Chlamy_JGI5_5(Cp_Mp).fasta\u0022\n\nlet peptideAndMasses = \n    filePath\n    |\u003E IO.FastA.fromFile BioArray.ofAminoAcidString\n    |\u003E Seq.toArray\n    |\u003E Array.mapi (fun i fastAItem -\u003E\n        Digestion.BioArray.digest Digestion.Table.Trypsin i fastAItem.Sequence\n        |\u003E Digestion.BioArray.concernMissCleavages 0 0\n        )\n    |\u003E Array.concat\n    |\u003E Array.map (fun peptide -\u003E\n        // calculate mass for each peptide\n        peptide.PepSequence, BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n        )\n\npeptideAndMasses |\u003E Array.head\n\n(***include-it***)\n\n(**\nCalculate the single and double charged m/z for all peptides and combine both in a single collection.\n*)\n\n// Code-Block 2\n\n// calculate m/z for each peptide z=1\nlet singleChargedPeptides =\n    peptideAndMasses\n    // we only consider peptides longer than 6 amino acids \n    |\u003E Array.filter (fun (peptide,ucMass) -\u003E peptide.Length \u003E=7)\n    |\u003E Array.map (fun (peptide,ucMass) -\u003E peptide, Mass.toMZ ucMass 1.) \n\n// calculate m/z for each peptide z=2\nlet doubleChargedPeptides =\n    peptideAndMasses\n    // we only consider peptides longer than 6 amino acids \n    |\u003E Array.filter (fun (peptide,ucMass) -\u003E peptide.Length \u003E=7)\n    |\u003E Array.map (fun (peptide,ucMass) -\u003E peptide, Mass.toMZ ucMass 2.) \n\n// combine this two    \nlet chargedPeptides =\n    Array.concat [singleChargedPeptides;doubleChargedPeptides]\n\n\nchargedPeptides.[1]\n\n(***include-it***)\n\n(**\nNow, we can sample our random \u0022MS1\u0022 spectrum from this collection of m/z.\n*)\n\n// Code-Block 3\n\n// initialze a random generator \nlet rnd = new System.Random()\n\n// sample n random peptides from all Chlamydomonas reinhardtii peptides\nlet chargedPeptideChar =\n    Array.sampleWithOutReplacement rnd chargedPeptides 100\n    // we only want the m/z\n    |\u003E Array.map (fun (peptide,mz) -\u003E mz,1.) \n    |\u003E Chart.Column\n    |\u003E Chart.withX_AxisStyle(\u0022m/z\u0022, MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle (\u0022Intensity\u0022, MinMax=(0.,1.3))\n    |\u003E Chart.withSize (900.,400.)\n\n(***hide***)\nchargedPeptideChar |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\nThis looks quite strange. I think you immediately see that we forgot about our isotopic cluster. A peptide doesn\u2019t produce a single peak, \nbut a full isotopic cluster. Therefore, we use our convenience function from the previous notebook \n(see: \u003Ca href=\u0022JP05_Isotopic_distribution.ipynb\u0022\u003EJP05 Isotopic distributiona\u003C/a\u003E).\n\n*)\n\n// Code-Block 4\n\n// Predicts an isotopic distribution of the given formula at the given charge, \n// normalized by the sum of probabilities, using the MIDAs algorithm\nlet generateIsotopicDistribution (charge:int) (f:Formula.Formula) =\n    IsotopicDistribution.MIDA.ofFormula \n        IsotopicDistribution.MIDA.normalizeByMaxProb\n        0.01\n        0.005\n        charge\n        f\n    |\u003E List.toArray\n        \ngenerateIsotopicDistribution\n\n(**\n*)\n\n// Code-Block 5\n\nlet peptidesAndMassesChart =\n    // sample n random peptides from all Chlamydomonas reinhardtii peptides\n    Array.sampleWithOutReplacement rnd peptideAndMasses 500\n    |\u003E Array.map (fun (peptide,mz) -\u003E \n            peptide\n            |\u003E BioSeq.toFormula\n            // peptides are hydrolysed in the mass spectrometer, so we add H2O\n            |\u003E Formula.add Formula.Table.H2O\n            )\n    |\u003E Array.collect (fun formula -\u003E \n        [\n            // generate single charged iones \n            generateIsotopicDistribution 1 formula\n            // generate double charged iones \n            generateIsotopicDistribution 2 formula\n        ] |\u003E Array.concat\n        )\n    |\u003E Chart.Column\n    |\u003E Chart.withX_AxisStyle(\u0022m/z\u0022, MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle (\u0022Intensity\u0022, MinMax=(0.,1.3))\n    |\u003E Chart.withSize (900.,400.)\n\n// HINT: zoom in on peptides\n\n(***hide***)\npeptidesAndMassesChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Determination of peptide hydrophobicity\n\u003Ca href=\u0022#Retention-time-and-scan-time\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nIn a MS\u003Csup\u003E1\u003C/sup\u003E scan, peptides don\u0027t appear randomly. They elute according to their hydrophobicity and other physicochemical properties \nfrom the LC.\n\nTo more accurately represent a MS\u003Csup\u003E1\u003C/sup\u003E spectrum, we determine the hydrophobicity of each peptide. Therefore, we first need a function \nthat maps from sequence to hydrophobicity.\n\u003C/div\u003E\n*)\n\n// Code-Block 6\n\nopen BioFSharp.AminoProperties\n\n// first, define a function that maps from amino acid to hydophobicity\nlet getHydrophobicityIndex =\n    BioFSharp.AminoProperties.initGetAminoProperty AminoProperty.HydrophobicityIndex\n    \n// second, use that function to map from peptide sequence to hydophobicity\nlet toHydrophobicity (peptide:AminoAcids.AminoAcid[]) =\n    peptide\n    |\u003E Array.map AminoAcidSymbols.aminoAcidSymbol\n    |\u003E AminoProperties.ofWindowedBioArray 3 getHydrophobicityIndex\n    |\u003E Array.average\n\ntoHydrophobicity\n\n(**\n*)\n\n// Code-Block 7\n\nlet peptidesFirst200 = \n    chargedPeptides \n    // now we sort according to hydrophobicity\n    |\u003E Array.sortBy (fun (peptide,mass) -\u003E   \n        peptide\n        |\u003E Array.ofList\n        |\u003E toHydrophobicity\n        )\n    |\u003E Array.take 200\n\npeptidesFirst200 |\u003E Array.head\n\n(***include-it***)\n\n(**\nNow, we need to generate the isotopic cluster again and visualize afterwards.\n*)\n\n// Code-Block 8\n\nlet peptidesFirst200Chart =\n    peptidesFirst200\n    |\u003E Array.map (fun (peptide,mz) -\u003E \n            peptide\n            |\u003E BioSeq.toFormula\n            // peptides are hydrolysed in the mass spectrometer, so we add H2O\n            |\u003E Formula.add Formula.Table.H2O\n            )\n    |\u003E Array.collect (fun formula -\u003E \n        [\n            // generate single charged iones \n            generateIsotopicDistribution 1 formula\n            // generate double charged iones \n            generateIsotopicDistribution 2 formula\n        ] |\u003E Array.concat\n        )\n    // Display\n    |\u003E Chart.Column\n    |\u003E Chart.withX_AxisStyle(\u0022m/z\u0022, MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle (\u0022Intensity\u0022, MinMax=(0.,1.3))\n    |\u003E Chart.withSize (900.,400.)\n\n// HINT: zoom in on peptides\n\n(***hide***)\npeptidesFirst200Chart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP05_Isotopic_distribution.html\u0027;\u0022\u003E\u0026#171; JP05\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP07_Signal_detection_and_quantification.html\u0027;\u0022\u003EJP07 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP09_Fragmentation_for_peptide_identification.html","title":"JP09 Fragmentation for peptide identification\n","content":"(**\n# JP09 Fragmentation for peptide identification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP09_Fragmentation_for_peptide_identification.ipynb)\n\n1. [Understanding MS2 spectra: From peptide to fragment](#Understanding-MS2-spectra:-From-peptide-to-fragment)\n2. [Simulate MS2 Fragmentation](#Simulate-MS2-Fragmentation)\u003Cbr\u003E\n2. [References](#References)\n*)\n\n(**\n## Understanding MS2 spectra: From peptide to fragment\n\u003Ca href=\u0022#Fragmentation-for-peptide-identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nThe currency of information for identification in MS-based proteomics is the fragment ion spectrum (MS/MS spectrum) that is typically \nderived from the fragmentation of a specific peptide in the collision cell of a mass spectrometer. Peptides produce fragments that provide \ninformation on their amino acid sequence. The correct assignment of such a spectrum to a peptide sequence is the central step to link \nm/z values and ion intensities to biology\u003Csup\u003E\u003Ca href=\u0022#31\u0022\u003E31\u003C/a\u003E\u003C/sup\u003E. \n\n\u003Cdiv Id=\u0022figure4\u0022 Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 60% ; padding: 15px\u0022\u003E\n    \u003Cimg src=\u0022img/FragmentIonNomenclature.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; margin-top: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\n        \u003Cb\u003EFigure 4: The Roepstorff-Fohlmann-Biemann nomenclature of fragment ions.\u003C/b\u003E\n        N-terminal and C-terminal peptide fragments result of dissociation of electron bonds along the peptide backbone.\n    \u003C/div\u003E\n\u003C/div\u003E    \n\nDuring the unimolecular peptide ion dissociation processes, different chemical reactions can lead to different types \nof product ions. The types of ions observed in MS/MS experiments depend on the physicochemical properties of the amino \nacids and their sequence, on the amount of internal energy, and on the peptide\u2019s charge state. In addition, product ion formation \nis strongly influenced by the fragmentation method\u003Csup\u003E\u003Ca href=\u0022#32\u0022\u003E32\u003C/a\u003E\u003C/sup\u003E. The most widely used fragmentation methods today \nare low-energy collision-induced dissociation (CID)\u003Csup\u003E\u003Ca href=\u0022#33\u0022\u003E33\u003C/a\u003E\u003C/sup\u003E and electron transfer dissociation \n(ETD)\u003Csup\u003E\u003Ca href=\u0022#34\u0022\u003E34\u003C/a\u003E\u003C/sup\u003E. These methods favor fragmentation along the peptide backbone and result in an N-terminal prefix \nfragment and a C-terminal suffix fragment. The standard nomenclature for the C-terminal fragments is x, y and z whereas the corresponding \nN-terminal fragments are denoted as a, b and c depending on the position where the breakage occurs at the peptide backbone level. The numbering \nof each fragment starts from the N-terminus for a,b,c series and from the C-terminus for x,y,z series (\u003Ca href=\u0022#figure4\u0022\u003EFigure 4\u003C/a\u003E). \nOne should keep in mind that during parent ion selection many of the same peptide ions are selected and dissociated into fragments, with the \nresulting fragment ions having different relative abundances according to the preferred fragmentation reaction. In addition to the \nfragmentation along the peptide backbone, fragment ions containing the amino acids R, K, N, or Q can lose ammonia (-17 Da) and are then \ndenoted a*, b* and y*. Fragments containing the amino acids S, T, E, or D may lose water (-18 Da) and are then denoted a\u00B0, b\u00B0 and y\u00B0. \nThese losses do not change the charge of the ions and are observable as natural losses \u003Csup\u003E\u003Ca href=\u0022#35\u0022\u003E35\u003C/a\u003E,\u003Ca href=\u0022#36\u0022\u003E36\u003C/a\u003E\u003C/sup\u003E.\n\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\n\n(**\n## Simulate MS2 Fragmentation\n\u003Ca href=\u0022#Fragmentation-for-peptide-identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\nFor the simulation we first define a short peptide. The peptide we take for this example is from rbcL.\n\n*)\n\n// Code-Block 1\n\nlet peptide = \n    \u0022DTDILAAFR\u0022\n    |\u003E BioList.ofAminoAcidString\n\npeptide\n\n(***include-it***)\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\nIn the \u003Ccode\u003EMz\u003C/code\u003E namespace of \u003Ca href=\u0022https://csbiology.github.io/BioFSharp/\u0022\u003EBioFSharp\u003C/a\u003E, we can find a function that can \ngenerate the theoretical series of y-ions from the given peptide. This function provides a lot of information, but we are only interested \nin the mass. Notice, that we do not know the intesity of the fragment ions and just use \u00271.\u0027 for simulation.\n\u003C/div\u003E\n*)\n\n// Code-Block 2\n\nlet ionSeriesY =\n    peptide\n    |\u003E Mz.Fragmentation.Series.yOfBioList BioItem.initMonoisoMassWithMemP\n    |\u003E List.map (fun aac -\u003E aac.MainPeak.Mass,1.)\n    \nionSeriesY\n\n(***include-it***)\n\n(**\nSimilarly, we can simulate the b-ion series.\n*)\n\n// Code-Block 3\n\nlet ionSeriesB =\n    peptide\n    |\u003E Mz.Fragmentation.Series.bOfBioList BioItem.initMonoisoMassWithMemP\n    |\u003E List.map (fun aac -\u003E aac.MainPeak.Mass,1.)\n\nionSeriesB\n\n(***include-it***)\n\n(**\nNow, we can just plot the simulated data and look at our theoretical spectrum.\n*)\n\n// Code-Block 4\n\nlet ionChart =\n    [    \n        Chart.Column (ionSeriesB, Name=\u0022b ions\u0022)\n        Chart.Column (ionSeriesY, Name=\u0022y ions\u0022)\n    ]\n    |\u003E Chart.Combine\n\n(***hide***)\nionChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP08_Centroidisation.html\u0027;\u0022\u003E\u0026#171; JP08\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP10_Peptide_Identification.html\u0027;\u0022\u003EJP10 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n\n(**\n## References\n\u003Ca href=\u0022#Fragmentation-for-peptide-identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Col\u003E\n\u003Cli Value=\u002231\u0022 Id=\u002231\u0022\u003E Nesvizhskii, A. I., Vitek, O. \u0026 Aebersold, R. Analysis and validation of proteomic data generated by tandem mass spectrometry. Nature methods 4, 787\u2013797; 10.1038/nmeth1088 (2007).\n\u003Cli Id=\u002232\u0022\u003E Medzihradszky, K. F. Peptide sequence analysis. Method Enzymol 402, 209\u2013244; 10.1016/S0076-6879(05)02007-0 (2005).\n\u003Cli Id=\u002233\u0022\u003E Johnson, R. S., Martin, S. A., Biemann, K., Stults, J. T. \u0026 Watson, J. T. Novel fragmentation process of peptides by collision-induced decomposition in a tandem mass spectrometer: differentiation of leucine and isoleucine. Anal. Chem. 59, 2621\u20132625; 10.1021/Ac00148a019 (1987).\n\u003Cli Id=\u002234\u0022\u003E Mikesh, L. M. et al. The utility of ETD mass spectrometry in proteomic analysis. Biochimica et biophysica acta 1764, 1811\u20131822; 10.1016/j.bbapap.2006.10.003 (2006).\n\u003Cli Id=\u002235\u0022\u003E Forner, F., Foster, L. J. \u0026 Toppo, S. Mass spectrometry data analysis in the proteomics era. Curr Bioinform 2, 63\u201393; 10.2174/157489307779314285 (2007).\n\u003Cli Id=\u002236\u0022\u003E Steen, H. \u0026 Mann, M. The ABC\u0027s (and XYZ\u0027s) of peptide sequencing. Nat. Rev. Mol. Cell Biol. 5, 699\u2013711; 10.1038/nrm1468 (2004).\n\u003C/ol\u003E\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP08_Centroidisation.html","title":"JP08 Centroidisation\n","content":"(**\n# JP08 Centroidisation\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP08_Centroidisation.ipynb)\n\n\n1. [Centroidisation](#Centroidisation)\n2. [Peak fitting and picking functions](#Peak-fitting-and-picking-functions)\n3. [Application of the peak picking function](#Application-of-the-peak-picking-function)\n*)\n\n(**\n## Centroidisation\n\u003Ca href=\u0022#Centroidisation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nIn reality, a peak is represented by a collection of signals from a peptide or fragment ion species that are measured by the \nspecific detector. Due to imperfections of the measurement, there is a scatter around the accurate mass. This distribution \nalong the m/z axis of signals from ion species is termed profile peak. The conversion of a peak profile into the corresponding m/z and \nintensity values reduces the complexity, its representation is termed centroiding. To extract the masses for identification in a simple \nand fast way, peak fitting approaches are used. Further, peak fitting algorithms are also needed to extract ion abundancies and therefore \nexplained under quantification in the following section.\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp.Mz\n\n(**\n## Peak fitting and picking functions\n\u003Ca href=\u0022#Centroidisation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nWe declare a function which centroids the given m/z and intensity data. In the scope of the function the m/z and intensity data \nare padded for the wavelet (You will read more about wavelet functions later in \u003Ca href=\u0022JP11_Quantification.ipynb#Quantification-Theorie\u0022\u003EJP11\u003C/a\u003E) \nand the centroided. For the centroidisation, we use a Ricker 2D wavelet.\n\u003C/div\u003E\n*)\n\n// Code-Block 1\n\nlet ms1PeakPicking (mzData:float []) (intensityData: float []) = \n    if mzData.Length \u003C 3 then \n        [||],[||]\n    else\n        let paddYValue = Array.min intensityData\n        // we need to define some padding and wavelet parameters\n        let paddingParams = \n            SignalDetection.Padding.createPaddingParameters paddYValue (Some 7) 0.05 150 95.\n        let waveletParameters = \n            SignalDetection.Wavelet.createWaveletParameters 10 paddYValue 0.1 90. 1. false false\n        \n        let paddedMz,paddedIntensity = \n            SignalDetection.Padding.paddDataBy paddingParams mzData intensityData\n        \n        BioFSharp.Mz.SignalDetection.Wavelet.toCentroidWithRicker2D waveletParameters paddedMz paddedIntensity \n\n\n(**\nWe load a sample MS\u003Csup\u003E1\u003C/sup\u003E from a mgf file.\n*)\n\n// Code-Block 2\n\nlet ms1 = \n    BioFSharp.IO.Mgf.readMgf (__SOURCE_DIRECTORY__ \u002B @\u0022/../AuxFiles/DavesTaskData/ms1MGF.mgf\u0022)\n    |\u003E List.head\n\nms1\n\n(***include-it***)\n\n(**\n## Application of the peak picking function\n\u003Ca href=\u0022#Centroidisation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nWe centroid the MS2 data using the function declared beforehand:\n\u003C/div\u003E\n*)\n\n// Code-Block 3\n\nlet centroidedMs1 = \n    ms1PeakPicking ms1.Mass ms1.Intensity\n\n(**\n*)\n\n// Code-Block 4\n\n//removes low intensity data points for charting\nlet filteredMs1Mass, filteredMs1Intensity =\n    Array.zip ms1.Mass ms1.Intensity\n    |\u003E Array.filter (fun (mass, intensity) -\u003E\n        intensity \u003E 400.\n    )\n    |\u003E Array.unzip\n\nlet filteredChart =\n    [\n        Chart.Point(filteredMs1Mass,filteredMs1Intensity)\n        |\u003E Chart.withTraceName \u0022Uncentroided MS1\u0022\n        Chart.Point(fst centroidedMs1,snd centroidedMs1)\n        |\u003E Chart.withTraceName \u0022Centroided MS1\u0022\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withY_AxisStyle \u0022Intensity\u0022\n    |\u003E Chart.withX_AxisStyle (title = \u0022m/z\u0022, MinMax = (400., 800.))\n    |\u003E Chart.withSize (900.,900.)\n\n(***hide***)\nfilteredChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP07_Signal_detection_and_quantification.html\u0027;\u0022\u003E\u0026#171; JP07\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP09_Fragmentation_for_peptide_identification.html\u0027;\u0022\u003EJP09 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP05_Isotopic_distribution.html","title":"JP05 Isotopic Distribution\n","content":"(**\n# JP05 Isotopic Distribution\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP05_Isotopic_distribution.ipynb)\n\n\n1. [Isotopic Distribution](#Isotopic-Distribution)\n    1. [Simulating Isotopic Clusters for peptides](#Simulating-Isotopic-Clusters-for-peptides)\n    2. [Simulating Isotopic Clusters for peptides with stable isotope labeled variant](#Simulating-Isotopic-Clusters-for-peptides-with-stable-isotope-labeled-variant)\n2. [References](#References)\n*)\n(**\n## Isotopic Distribution\n\u003Ca href=\u0022#Isotopic-Distribution\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nPeptide signals exhibit a characteristic shape in the mass spectrum that depend on their isotopic profile, which is defined by \nthe number of naturally occurring isotopes in the peptide. The occurrence probabilities of natural isotopes are reflected in the mass \nspectrum by the relative heights of the peak series belonging to the respective peptide. The frequency at which natural isotopes occur \nis known and can be used to compute the isotope distribution of a molecule. The isotopic distribution for a given peptide molecule \nC\u003Csub\u003Ev\u003C/sub\u003EH\u003Csub\u003Ew\u003C/sub\u003EN\u003Csub\u003Ex\u003C/sub\u003EO\u003Csub\u003Ey\u003C/sub\u003ES\u003Csub\u003Ez\u003C/sub\u003E is described by the following product of polynomials:\n\n\u003Cdiv class=\u0022container\u0022\u003E\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?\\large\u0026space;\\newline(\u0026space;{}^{12}\\textrm{C}\u0026space;\u0026plus;\u0026space;{}^{13}\\textrm{C})^{v}\u0026space;\\times\u0026space;({}^{1}\\textrm{H}\u0026plus;{}^{2}\\textrm{H})^{w}\u0026space;\\times\u0026space;({}^{14}\\textrm{N}\u0026plus;{}^{15}\\textrm{N})^{x}\\times({}^{16}\\textrm{O}\u0026plus;{}^{17}\\textrm{O}\u0026space;\u0026plus;\u0026space;{}^{18}\\textrm{O})^{y}\\newline\\times({}^{32}\\textrm{S}\u0026plus;{}^{33}\\textrm{S}\u0026plus;{}^{34}\\textrm{S}\u0026plus;{}^{36}\\textrm{S})^{z}\u0022 title=\u0022\\large \\newline( {}^{12}\\textrm{C} \u002B {}^{13}\\textrm{C})^{v} \\times ({}^{1}\\textrm{H}\u002B{}^{2}\\textrm{H})^{w} \\times ({}^{14}\\textrm{N}\u002B{}^{15}\\textrm{N})^{x}\\times({}^{16}\\textrm{O}\u002B{}^{17}\\textrm{O} \u002B {}^{18}\\textrm{O})^{y}\\newline\\times({}^{32}\\textrm{S}\u002B{}^{33}\\textrm{S}\u002B{}^{34}\\textrm{S}\u002B{}^{36}\\textrm{S})^{z}\u0022 Style=\u0022margin: 1rem auto 1rem; display: block\u0022/\u003E\n\u003C/div\u003E\n\nSymbolic expansion of the polynomials results in many product terms, which correspond to different isotopic variants of a molecule. \nEven for molecules of a medium size, the straightforward expansion of the polynomials leads to an explosion regarding the number of product terms. \nDue to this complexity, there was a need to develop algorithms for efficient computation. The different strategies comprise pruning the \npolynomials to discard terms with coefficients below a threshold\u003Csup\u003E\u003Ca href=\u0022#25\u0022\u003E25\u003C/a\u003E\u003C/sup\u003E combined with a recursive \ncomputation\u003Csup\u003E\u003Ca href=\u0022#26\u0022\u003E26\u003C/a\u003E\u003C/sup\u003E, and Fourier Transformation for a more efficient convolution of the isotope distributions of \nindividual elements\u003Csup\u003E\u003Ca href=\u0022#27\u0022\u003E27\u003C/a\u003E\u003C/sup\u003E, or rely on dynamic programming\u003Csup\u003E\u003Ca href=\u0022#28\u0022\u003E28\u003C/a\u003E\u003C/sup\u003E.\n\n\u003Cdiv Style=\u0022text-align: justify ; margin-top: 2rem ; margin-bottom: 2rem ; line-height: 1.3 ; width: 85% ; margin-left: auto ; margin-right: auto ; padding: 10px ; border: 2px dotted #708090 ; color: #708090\u0022\u003E\nMIDAs\u003Csup\u003E\u003Ca href=\u0022#29\u0022\u003E29\u003C/a\u003E\u003C/sup\u003E is one of the more elaborate algorithms to predict an isotope cluster based on a given peptide sequence. \nSimulate the isotopic cluster of the peptide sequence \u2018PEPTIDES\u2019 and \u2018PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u2019 with natural occurring isotope abundances.\n\u003C/div\u003E\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\n(**\n\n## Simulating Isotopic Clusters for peptides\n\u003Ca href=\u0022#Isotopic-Distribution\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nWe will use two artificial peptide sequences and translate them into their elemental composition to simulate their isotopic clusters. \nTherefore, we first define a function that maps from a peptide sequence to its formula: \n\u003C/div\u003E\n*)\n\n// Code-Block 1\n\n// create chemical formula for amino acid and add water to reflect hydrolysed state in mass spectrometer\nlet toFormula bioseq =  \n    bioseq\n    |\u003E BioSeq.toFormula\n    // peptides are hydrolysed in the mass spectrometer, so we add H2O\n    |\u003E Formula.add Formula.Table.H2O\n\n(**\nNext, we will apply our function to receive the elemental composition or chemical formula of the peptides.\n*)\n\n// Code-Block 2\n\n// translate single letter code into amino acids and create chemical formula of it.\nlet peptide_short = \n    \u0022PEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    \nlet peptide_long  = \n    \u0022PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    \nlet peptide_shortString =\n    peptide_short \n    |\u003E Formula.toString\n\n\nlet peptide_longString =\n    peptide_long \n    |\u003E Formula.toString\n\n(*** include-value:peptide_shortString ***)\n\n(*** include-value:peptide_longString ***)\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\nAdditionally, we need a function that maps from Formula (and charge) to the isotopic distribution. Here, we \ncan use \u003Ccode\u003EIsotopicDistribution.MIDA.ofFormula\u003C/code\u003E from the BioFSharp library. However, for convenience \n(to use the same parameter twice), we define our function \u003Ccode\u003EgenerateIsotopicDistribution\u003C/code\u003E:\n\u003C/div\u003E\n*)\n\n// Code-Block 3\n\n// Predicts an isotopic distribution of the given formula at the given charge, \n// normalized by the sum of probabilities, using the MIDAs algorithm\nlet generateIsotopicDistribution (charge:int) (f:Formula.Formula) =\n    IsotopicDistribution.MIDA.ofFormula \n        IsotopicDistribution.MIDA.normalizeByMaxProb\n        0.01\n        0.005\n        charge\n        f\n        \n// create pattern for peptide_short\nlet isoPattern_peptide_short = \n    generateIsotopicDistribution 1 peptide_short\n\n// create pattern for peptide_long\nlet isoPattern_peptide_long = \n    generateIsotopicDistribution 1 peptide_long\n    \nisoPattern_peptide_long\n\n(*** include-it ***)\n\n(** *)\n\n// Code-Block 4\n\n// create one chart for both, short and long peptide isotopic patterns.     \nlet isoPatternChart = \n    [\n        Chart.Column(isoPattern_peptide_short,Name= \u0022peptide_short\u0022 )\n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(885.,895.))\n        Chart.Column(isoPattern_peptide_long,Name= \u0022peptide_long\u0022 )\n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(3230., 3240.))\n    ]\n    |\u003E Chart.Stack 2\n    |\u003E Chart.withSize (900.,600.)\n    |\u003E Chart.withTitle \u0022Isotopeclusters\u0022\n    |\u003E Chart.withY_AxisStyle \u0022intensity\u0022\n\n\n(***hide***)\nisoPatternChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Simulating Isotopic Clusters for peptides with stable isotope labeled variant\n\u003Ca href=\u0022#Isotopic-Distribution\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nIn addition to the natural occurring isotopic distribution, the field of proteomics has benefited greatly from the ability to \nintroduce stable isotopes into peptide sequences. So called isotopic labeling refers to the introduction of a naturally low-abundance \nisotope of carbon, nitrogen, hydrogen and, in some cases, oxygen, into a peptide sequence. The isotopes commonly used are \u003Csup\u003E13\u003C/sup\u003EC, \n\u003Csup\u003E15\u003C/sup\u003EN, \u003Csup\u003E2\u003C/sup\u003EH (deuterium) and \u003Csup\u003E18\u003C/sup\u003EO with natural abundances of 1.10%, 0.366%, 0.015% and 0.200%, \nrespectively\u003Csup\u003E\u003Ca href=\u0022#30\u0022\u003E30\u003C/a\u003E\u003C/sup\u003E. Therefore, the introduction of these isotopes into a peptide sequence can be detected by \nmost modern mass spectrometers leading to a respective mass shift and the ability to separate the same peptide species within the same run.\n \n\u003Cdiv Style=\u0022text-align: justify ; margin-top: 2rem ; margin-bottom: 2rem ; line-height: 1.3 ; width: 85% ; margin-left: auto ; margin-right: auto ; padding: 10px ; border: 2px dotted #708090 ; color: #708090\u0022\u003E\nMIDAs\u003Csup\u003E\u003Ca href=\u0022#29\u0022\u003E29\u003C/a\u003E\u003C/sup\u003E is also able to predict isotope clusters with altered isotope abundances. Simulate the isotopic cluster \nof the peptide sequence \u2018PEPTIDES\u2019 and \u2018PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u2019 with stable isotopes \u003Csup\u003E15\u003C/sup\u003EN labeling. \n\u003C/div\u003E\n\nTherefore, we define a function called \u003Ccode\u003Elabel\u003C/code\u003E. The function maps from a formula to a formula with exchangen nitrogen isotopes. \n(Attention: Don\u0027t get confused a formula is just a FSharpMap.) \n\n\u003C/div\u003E\n*)\n\n// Code-Block 5\n\n/// returns a function that replaces the nitrogen atoms in a formula\n/// with the 15N isotope\nlet label formula =\n    Formula.replaceElement formula Elements.Table.N Elements.Table.Heavy.N15\n\n(** *)\n\n// Code-Block 6\n\nlet N15_peptide_short = \n    \u0022PEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    |\u003E label\n\nlet N15_peptide_long  = \n    \u0022PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    |\u003E label\n\n//result: N15_peptide_short\n(*** include-value:N15_peptide_short ***)\n\n//result: N15_peptide_long\n(*** include-value:N15_peptide_long ***)\n\n(** *)\n\n// Code-Block 7\n\n// create pattern for N15_peptide_short\nlet N15_isoPattern_peptide_short = \n    generateIsotopicDistribution 1 N15_peptide_short\n\n// create pattern for N15_peptide_long\nlet N15_isoPattern_peptid_long = \n    generateIsotopicDistribution 1 N15_peptide_long\n\n(***include-value:N15_isoPattern_peptide_short***)\n(***include-value:N15_isoPattern_peptid_long***)\n\n(** *)\n\n// Code-Block 8\n\n// Create two charts. Each with the related N14 and N15 isotopic clusters. Then stack them two one unit.\nlet isoPatternChart2 = \n    [\n        [\n            Chart.Column(isoPattern_peptide_short,Name= \u0022peptide_short\u0022 )\n            Chart.Column(N15_isoPattern_peptide_short,Name= \u0022N15_peptide_short\u0022 )\n        ] \n        |\u003E Chart.Combine \n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(885., 905.0))\n\n        [\n            Chart.Column(isoPattern_peptide_long,Name= \u0022peptide_long\u0022 )\n            Chart.Column(N15_isoPattern_peptid_long,Name= \u0022N15_peptide_long\u0022 )            \n        ] \n        |\u003E Chart.Combine \n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(3230.0, 3270.0))\n    ]\n    |\u003E Chart.Stack 2\n    |\u003E Chart.withTitle \u0022Isotopeclusters\u0022\n    |\u003E Chart.withY_AxisStyle \u0022intensity\u0022\n\n(***hide***)\nisoPatternChart2 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP04_Digestion_and_mass_calculation.html\u0027;\u0022\u003E\u0026#171; JP04\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP06_Retention_time_and_scan_time.html\u0027;\u0022\u003EJP06 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n\n(**\n## References\n\u003Ca href=\u0022#Isotopic-Distribution\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Col\u003E\n\u003Cli Value=\u002225\u0022 Id=\u002225\u0022\u003E Yergey, J. A. A General-Approach to Calculating Isotopic Distributions for Mass-Spectrometry. Int J Mass Spectrom 52, 337\u2013349; 10.1016/0020-7381(83)85053-0 (1983).\u003C/li\u003E\n\u003Cli Id=\u002226\u0022\u003E Claesen, J., Dittwald, P., Burzykowski, T. \u0026 Valkenborg, D. An efficient method to calculate the aggregated isotopic distribution and exact center-masses. Journal of the American Society for Mass Spectrometry 23, 753\u2013763; 10.1007/s13361-011-0326-2 (2012).\u003C/li\u003E\n\u003Cli Id=\u002227\u0022\u003E Rockwood, A. L., Vanorden, S. L. \u0026 Smith, R. D. Rapid Calculation of Isotope Distributions. Anal Chem 67, 2699\u20132704; 10.1021/Ac00111a031 (1995).\u003C/li\u003E\n\u003Cli Id=\u002228\u0022\u003E Snider, R. K. Efficient calculation of exact mass isotopic distributions. Journal of the American Society for Mass Spectrometry 18, 1511\u20131515; 10.1016/j.jasms.2007.05.016 (2007).\u003C/li\u003E\n\u003Cli Id=\u002229\u0022\u003E Alves, G. \u0026 Yu, Y. K. Robust accurate identification of peptides (RAId). deciphering MS2 data using a structured library search with de novo based statistics. Bioinformatics 21, 3726\u20133732; 10.1093/bioinformatics/bti620 (2005).\u003C/li\u003E\n\u003Cli Id=\u002230\u0022\u003E Becker, G. W. Stable isotopic labeling of proteins for quantitative proteomic applications. Brief Funct Genomic Proteomic 7, 371\u2013382; 10.1093/bfgp/eln047 (2008).\u003C/li\u003E\n\u003C/ol\u003E\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP00_Systems_Biology_FSharp_Introduction.html","title":"JP00 Systems Biology\n","content":"(**\n# JP00 Systems Biology\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP00_Systems_Biology_FSharp_Introduction.ipynb)\n\n\nThis notebook introduces the field of Systems Biology and explains why programming is a necessary skill to it. You will get a short introduction to the programming language F# and some links to resource for further studies.\n\n1. [Systems Biology: A brief introduction](#Systems-Biology-A-brief-introduction)\n2. [Starting with FSharp](#Starting-with-FSharp)\u003Cbr\u003E\n    1. [Functions](#Functions)\u003Cbr\u003E\n    2. [Binding function values and simple values](#Binding-function-values-and-simple-values)\u003Cbr\u003E\n        1. [Side note: Lambda expressions](#Side-note:-Lambda-expressions)\u003Cbr\u003E\n    3. [Simple values](#Simple-values)\n    4. [Lists \u0026 Arrays](#Lists-\u0026-Arrays)\n    5. [Higher-order functions](#Higher-order-functions)\n        1. [Side Note: Pipe-forward operator |\u003E](#Side-Note:-Pipe-forward-operator-|\u003E)\n    6. [Control flow expressions](#Control-flow-expressions)\n        1. [if-then-else](#if-then-else)\n        2. [Pattern Matching](#Pattern-Matching)\n    7. [Complex Data Types](#Complex-Data-Types)\n        1. [Tuples](#Tuples)\n        2. [Record Types](#Record-Types)\n    8. [Code organization](#Code-organization)\n        1. [Namespaces and modules](#Namespaces-and-modules)\n        2. [Comments](#Comments)\n3. [References](#References)\n\n## Systems Biology: A brief introduction\n\n\u003Cdiv class=\u0022columns\u0022\u003E\n\u003Cdiv class=\u0022column is-8\u0022\u003E\nThe term \u201Csystems theory\u201D was introduced by the biologist L. von Bertalanffy. He defined a system as a set of related components that work together in a particular environment to perform whatever functions are required to achieve the system\u0027s objective\u003Csup\u003E\u003Ca href=\u0022#1\u0022 id=\u0022ref1\u0022\u003E1\u003C/a\u003E\u003C/sup\u003E. The hierarchical organization orchestrating the interaction of thousands of molecules with individual properties allows complex biological functions. Biological processes like cell division, biomass production, or a systemic response to perturbations are molecular physiological functions which result from a complex dynamic interplay between genes, proteins and metabolites (\u003Ca href=\u0022#figure1\u0022\u003EFigure 1\u003C/a\u003E). To gain a holistic understanding of a biological system, all parts of the system need to be studied simultaneously by quantitative measures\u003Csup\u003E\u003Ca id=\u0022ref2\u0022 href=\u0022#2\u0022\u003E2\u003C/a\u003E\u003C/sup\u003E. The focus on a system-wide perspective lies on the quantitative understanding of the organizational structure, functional state, robustness and dynamics of a biological system and led to the coining of the term \u201CSystems Biology\u201D\u003Csup\u003E\u003Ca href=\u0022#3\u0022\u003E3\u003C/a\u003E\u003C/sup\u003E.\n\nThe current challenges of Systems Biology approaches are mainly along four lines\u003Csup\u003E\u003Ca href=\u0022#2\u0022\u003E2\u003C/a\u003E,\u003Ca href=\u0022#4\u0022\u003E4\u003C/a\u003E\u003C/sup\u003E: \n\n - (**i**) - system-wide quantification of transcriptome, proteome (including protein modifications) and metabolome\n \n - (**ii**) - identification of physical interactions between these components\n \n - (**iii**) - inference of structure, type and quantity of found interactions\n \n - (**iv**) - analysis and integration of the resulting large amounts of heterogeneous data. It becomes obvious that an interdisciplinary effort is needed to resolve these challenges in Systems Biology\u003Csup\u003E\u003Ca href=\u0022#5\u0022\u003E5\u003C/a\u003E\u003C/sup\u003E. Here Biology dictates which analytical, experimental and computational methods are required.\n\nModern analytical methods to measure the identity and quantity of biomolecules system-wide, summarized under the term \u201Cquantitative omics\u201D-technologies, address the first two mentioned challenges of Systems Biology. Among these \u201Comics\u201D-technologies are transcriptomics based on microarrays/next generation sequencing and proteomics/metabolomics based on mass-spectrometry.\n\nTying in with the area of genome sequencing, the focus is set on the accurate profiling of gene/protein expression and metabolite concentrations, as well as on the determination of biological protein modifications and of physical interactions between proteins.\n\nAddressing the abovementioned challenges three and four of Systems Biology, the development of numerous computational approaches reaches out to unravel the intrinsic complexity of biological systems\u003Csup\u003E\u003Ca href=\u0022#6\u0022\u003E6\u003C/a\u003E\u003C/sup\u003E. These computational approaches focus on knowledge discovery and on in silico simulation or modeling\u003Csup\u003E\u003Ca href=\u0022#7\u0022\u003E7\u003C/a\u003E\u003C/sup\u003E. In the latter approach knowledge on a biological process is converted into a mathematical model. In silico simulations based on such a model can provide predictions that may subsequently be tested experimentally. Computation-based knowledge discovery (also known as data mining) aims to extract hidden patterns from complex and high-dimensional data to generate hypotheses. Therefore, the first step is to describe information on a biological system such that it is sustainably stored in a format rendering it readable and manipulable for machines and humans. The second step is to integrate the huge amount of differently structured data, often referred to as the \u201Cbig data\u201D challenge. In a last step, statistical or machine learning methods are applied to extract the information or underlying principles hidden in the data.\n\nThe most flexible way of working with huge amounts of data is using a lightweight programming language with a succinct syntax. Therefore, it becomes necessary that biologist become familiar with a suitable programming language to solve real world problems in (Systems) Biology.\n\u003C/div\u003E\n\u003Cdiv class=\u0022column is-4\u0022\u003E\n![](img/OmicSpace.png)\n\u003Cb\u003EFigure 1: A conceptual view of the omic space.\u003C/b\u003E The omics space comprises of genomic, transcriptomic, proteomic, metabolomic and phenomic systems level represented as a plane. Complex biological function is the result of the interplay between molecules of one and/or different systems level.\n\u003C/div\u003E\n\u003C/div\u003E\n\n## Starting with FSharp\n\n\nF# (pronounced \u201CF Sharp\u201D) is a simple and expressive programming language. It can be described as statically typed impure functional language that supports functional, imperative and object-oriented paradigm and also several other programming styles including data-driven, event-driven and parallel programming. This makes it an excellent tool for introducing programming as well as programming paradigms.\n\nF# is supported by the \u003Ca href=\u0022http://fsharp.org\u0022\u003EF# Software Foundation\u003C/a\u003E and a worldwide community of contributors. Microsoft and other companies develop professional tooling for F#. The \u003Ca href=\u0022https://docs.microsoft.com/en-us/dotnet/articles/fsharp/\u0022\u003EF# Language Reference\u003C/a\u003E is a reference for the F# language, and the \u003Ca href=\u0022https://docs.microsoft.com/en-us/dotnet/articles/fsharp/\u0022\u003EF# Guide\u003C/a\u003E covers general topics. There are lots of excellent \u003Ca href=\u0022http://fsharp.org/learn.html\u0022\u003EF# learning resources\u003C/a\u003E available online.\n   \nTo learn more about how to use Jupyter notebooks, see the [Jupyter documentation](http://jupyter-notebook.readthedocs.io/) and the [Jupyter keyboard shortcuts](https://www.cheatography.com/weidadeyue/cheat-sheets/jupyter-notebook/). You can find more information baoutthe F# and Jupyter tooling locally using \u003Ca href=\u0022https://github.com/fsprojects/IfSharp\u0022\u003EIfSharp\u003C/a\u003E.\n  \nWith the help of the following FSharp coding information/examples, you will be able to solve all exercises in \u003Ca href=\u0022JP01_FSharpExcercises.ipynb\u0022 style=\u0022color: orange\u0022\u003EJP01_FsharpExcercises\u003C/a\u003E!\n   \nLet\u0027s start with our basic introduction:\n\n## Functions\n\nThe impetus behind functional programming comes from mathematics. Mathematical functions have a number of very nice features that functional languages try to emulate in the real world.\nSo first, let\u2019s start with a mathematical function that adds 1 to a number.\n\n\u0060\u0060\u0060\nAdd1(x) = x\u002B1\n\u0060\u0060\u0060\n\nWhat does this really mean? Well it seems pretty straightforward. It means that there is an operation that starts with a number, and adds one to it.\n   \n**Let\u2019s introduce some terminology:**\n\n - The set of values that can be used as input to the function is called the domain. In this case, it could be the set of real numbers, but to make life simpler for now, let\u2019s restrict it to integers only.\n\n - The set of possible output values from the function is called the range (technically, the image on the codomain). In this case, it is also the set of integers.\n\n - The function is said to map the domain to the range.\n\nA diagram of a general function would be:\n\n![](img/function.png)\n\n\u003Cb\u003EFigure 2: diagram of a general function\u003C/b\u003E\n\n## Binding function values and simple values\n\nThe process of using a name to represent a function or a value is called \u201Cbinding\u201C. A binding is done by using the \u0060let\u0060 keyword in F#. Let\u2019s look at the simple function we used previously:\n\n*)\n\nlet add1 x = x \u002B 1\n// evaluate\nadd1\n\n(**\n\u0060\u0060\u0060\nval add1: \n   x: int \n   -\u003E int\n\u0060\u0060\u0060\n\nWhat does the \u201Cx\u201D mean here? It means:\n\n - Accept some value from the input domain.\n\n - Use the name \u201Dx\u201D to represent that value so that we can refer to it later. The name \u201Cx\u201D is \u0022bound\u0022 to the input value. So if we evaluate the function with the input 5 say, what is happening is that everywhere we see \u201Cx\u201D in the original definition, we replace it with \u201C5\u201D, sort of like search and replace in a word processor\n\n*)\n\nadd1 5\n// replace \u0022x\u0022 with \u00225\u0022\n// add1 5 = 5 \u002B 1 = 6\n// result is 6\n\n(***include-it***)\n\n(**\nIf you think about this a bit more, you will see that the name \u0060add1\u0060 itself is just a binding to _the function that adds one to its input_. \nThe function itself is independent of the name it is bound to. When you type let \u0060add1\u0060 x = x \u002B 1 you are telling the F# compiler \u201Cevery time you see the name add1, \nreplace it with _the function that adds one to its input_\u201D. \u0060add1\u0060 is called a function value. To see that the function is independent of its name, try:\n*)\n\nlet plus1 = add1\nadd1 5 = plus1 5\n\n(***include-it***)\n\n(**\nYou can see that \u0060add1\u0060 and \u0060plus1\u0060 are two names that refer (\u0022bound to\u0022) to the same function. You can always identify a function value because its signature has the standard form domain -\u003E range. \nHere is a generic function value signature:\n\n\u0060\u0060\u0060\nval functionName : domain -\u003E range\n\u0060\u0060\u0060\n\nSide note: Lambda expressions\n\nIn F# it is possible to use function without giving them a name and use the keyword \u0060fun\u0060 instead and the \u0060=\u0060 becomes \u0060-\u003E\u0060. \nThis is called anonymous function, or - referring to lambda calculus - **lambda expression**. This kind of functions are often used for convenience. To write \u0060add1\u0060 as lambda expression:\n*)\n\nfun x -\u003E x \u002B 1\n\n(**\n## Simple values\n\n![](img/valueBinding.png)\n      \nImagine an operation that always returned the integer 5 and didn\u2019t have any input.\n   \nThis would be a \u201Cconstant\u201D operation.\nHow would we write this in F#? We want to tell the F# compiler \u201Cevery time you see the name c, replace it with 5\u201D. Here\u2019s how:\n*)\n\nlet c = 5\n// evaluate\nc\n\n(***include-it***)\n\n(**\nThere is no mapping arrow this time, just a single int. What\u2019s new is an equals sign with the actual value printed after it. The F# compiler knows that this binding has a known value which it will always return, namely the value 5.\nIn other words, we\u2019ve just defined a constant, or in F# terms, a simple value.\n\n## Lists \u0026 Arrays\n\nSquare brackets \u0060[]\u0060 create a list with semicolon \u0060;\u0060 delimiters.\n*)\n\nlet twoToFive = [2; 3; 4; 5]\ntwoToFive\n\n(***include-it***)\n\n(**\n\u0060::\u0060 creates a list with a new element appended to the front of the list.\n*)\n\nlet oneToFive = 1::twoToFive\noneToFive\n\n(***include-it***)\n\n(**\nSquare brackets with dashes \u0060[||]\u0060 create an array with semicolon \u0060;\u0060 delimiters.\n*)\n\nlet oneToFour = [|1; 2; 3; 4|]\n\n(**\nElements can be accessed using dot \u0060.[i]\u0060, where i is the (zero-based) index of the desired element\n*)\n\noneToFour.[0]\n\n(***include-it***)\n\n(**\n_Note_: commas are **never** used as delimiters in collection types, only semicolons!\n\n## Higher-order functions\n\n\u003Cdiv class=\u0022columns\u0022\u003E\n\u003Cdiv class=\u0022column is-8\u0022\u003E\nA higher-order function is a function that takes another function as a parameter. \nThis is simple, but leads to one of the most important concepts of functional programming: The conceptual operation: \u003Cstrong\u003Emap\u003C/strong\u003E\n\nThe higher-order and polytypic function \u0060map\u0060 applies a function working on the normal space to an elevated space.\nThis concept is so important that all collection types (lists, arrays, ...) have a build in \u0060map\u0060 function. \nLet\u0027s look at an example of what that means. Therefore, we first define a function working on the normal space:\n\u003C/div\u003E\n\u003Cdiv class=\u0022column is-4\u0022\u003E\n![](img/map.png)\n\u003Cb\u003EFigure 3: A conceptual view of the \u0060map\u0060 concept.\u003C/b\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n*)\n\nlet square x = x * x\n// evaluate\nsquare 3\n\n(***include-it***)\n\n(**\nNow, let\u0027s apply this function to every number in a list.\n*)\n\nList.map square [3;2;6;7]\n\n(***include-it***)\n\n(**\nBe aware, that this concept of mapping is restricted to the actual function called \u0060map\u0060. A \u0060filter\u0060 function, for example, is also the same kind of operation.\n*)\n\nlet evens list =\n   let isEven x = x%2 = 0\n   List.filter isEven list \n   \n//isEven 5      // the value or constructor isEven is not defined. .. this is because it is only defined inside \n                // of the functional scope of \u0060evens\u0060.\n\n(**\nAdditionaly, you can see in this example how to define a multiline function. Just use indents! No \u0060;\u0060 needed.\nDefine \u0060isEven\u0060 as an inner (\u0022nested\u0022) function. In this case the function \u0060isEven\u0060 is defined in the scope of the function \u0060evens\u0060. It cannot be accessed outside of this scope.\n\u0060List.filter\u0060 is a library function with two parameters: a \u0060predicate\u0060 function, returning \u0060true\u0060 or \u0060false\u0060 depending on the input - and a \u0060list\u0060 to work on.\n*)\n\nevens [1..5]\n\n(***include-it***)\n\n(**\nYou can use \u0060()\u0060 to clarify precedence (think brackets in math). In this example, do \u0060List.map\u0060 first, with two parameters. Then do \u0060List.sum\u0060 on the result. \u0060List.map\u0060 applies a function to all elements in the list.\n*)\n\nlet sumOfSquaresTo100 =\n   List.sum (List.map square [1..100])\n\nsumOfSquaresTo100\n\n(***include-it***)\n\n(**\nWithout the \u0060()\u0060, \u0060List.map\u0060 would be passed as an parameter to \u0060List.sum\u0060.\n\n## Side Note: Pipe-forward operator \u0060|\u003E\u0060\n\nThe Pipe-forward operator lets you pass an intermediate result (value) onto the next function, it\u2019s defined as: \n\n*)\n\nlet (|\u003E) x f = f x \n\n(**\n\nNow, you can pipe the output of one operation to the next using \u0060|\u003E\u0060.\nHere is the same \u0060sumOfSquares\u0060 function written using pipes.\n\n*)\n\nlet sumOfSquaresTo100piped =\n   [1..100] \n   |\u003E List.map square \n   |\u003E List.sum\n\nsumOfSquaresTo100piped\n\n(***include-it***)\n\n(**\nIn this case one often uses anonymous functions using the \u0060fun\u0060 keyword. This saves time to think about a name and the function can be writen inline.\n*)\n\nlet sumOfSquaresTo100withFun =\n   [1..100] \n   |\u003E List.map (fun x -\u003E x * x) \n   |\u003E List.sum\n   \nsumOfSquaresTo100withFun\n\n(***include-it***)\n\n(**\n\u003Cdiv class=\u0022columns\u0022\u003E\n\u003Cdiv class=\u0022column is-8\u0022\u003E\n\nYou already used the \u0060List.sum\u0060 function. It is important to notice that this function doesn\u2019t follow the \u0060map\u0060 concept. There is a second related concept called \u0060fold\u0060.  The higher-order and polytypic function \u0060fold\u0060 applies a function working on the normal space to an elevated space and reduces the elevated space into the normal space. This results in an aggregation. A simple but concreate example would be to sum a list of numeric values.\n\n\u003C/div\u003E\n\u003Cdiv class=\u0022column is-4\u0022\u003E\n\n![](img/fold.png)\n\n\u003Cb\u003EFigure 4: A conceptual view of the \u0060fold\u0060 concept.\u003C/b\u003E\n\n\u003C/div\u003E\n\u003C/div\u003E\n\n## Control flow expressions\n\nControl flow expressions are used to determine the program pathing under multiple possible conditions. These different paths must always lead to the same \u0060Type\u0060 (e.g. \u0060string\u0060).\n\n### if-then-else\n\n\u0060if-then-else\u0060 is an expression and must return a value of a particular type.\nIt evaluates to a different value depending on the \u0060boolean\u0060 expression given.\n\nBoth branches must return the same type!\n\n*)\n\nlet v = if true then \u0022a\u0022 else \u0022b\u0022\nv\n\n(***include-it***)\n\n(**\n\n### Pattern Matching\n\nPattern matchings are one method to apply these control flow expressions. These function similiar to the \u003Ca href=\u0022#if-then-else\u0022\u003Eif then else\u003C/a\u003E expression, but much more powerful.\n\n*)\n\nlet simplePatternMatch x =\n   match x with\n    | \u0022a\u0022 -\u003E printfn \u0022input is a\u0022\n    | \u0022b\u0022 -\u003E printfn \u0022input is b\u0022\n    | _   -\u003E printfn \u0022input is something else\u0022\n\n(**\n\u003Cdiv Style=\u0022text-align: justify ; font-size: 1.8rem ; margin-top: 2rem ; line-height: 1.5\u0022\u003E\n    Underscore \u0060_\u0060 matches anything\n\u003C/div\u003E\n*)\n\nsimplePatternMatch \u0022a\u0022 \n\n(***include-output***)\n\nsimplePatternMatch \u0022I will not match\u0022\n\n(***include-output***)\n\n(**\nIn the following we will use a \u0060printfn\u0060 function. Normally in FSharp only the last output is returned, but side effects, can always be returned. As a rule of thumb: All Unit outputs are side effects. \u003Cbr\u003E\nIn this case, this means, we will print the result and still can keep working with the output.\nAlso you will notice, that the last output is only \u0060f (1=3)\u0060 -\u003E \u0022b\u0022, but we still will get all other results, as we print them below.\n*)\n\nlet f x = \n    if x then \n        printfn \u0022a\u0022;\n        \u0022a\u0022 \n    else\n        printfn \u0022b\u0022\n        \u0022b\u0022\n\nf false\n\n(***include-it***)\n\nf true\n\n(***include-it***)\n\nf (1=1)\n\n(***include-it***)\n\nf (1=3)\n\n(***include-it***)\n\n(**\n## Complex Data Types\n\n### Tuples\n\nTuple types are pairs, triples, and so on of values.\n\nTuples use commas \u0060,\u0060 as delimiter.\n\n*)\n\nlet twoTuple = 1,2\ntwoTuple\n\n(***include-it***)\n\nlet threeTuple = \u0022a\u0022,2,true\nthreeTuple\n\n(***include-it***)\n\n(**\n### Record Types\n\nRecord types have named fields. They use Semicolons \u0060;\u0060 as separators.\n\n*)\n\ntype Person = {FirstName:string; LastName:string}\n\nlet person1 = {FirstName = \u0022John\u0022; LastName = \u0022Doe\u0022}\nperson1\n\n(***include-it***)\n\n(**\nField of a record type can be acessed individually with a dot \u0060.Name\u0060\n*)\n\nperson1.FirstName\n\n(***include-it***)\n\n(**\n## Code organization\n\nSometimes it can be necessary to organize code for example to ship a library to other users. Namespaces und Modules are top-level and low-level constructs to organize code. \n\n### Namespaces and modules\n\nYou can think of namespaces and modules as containers and sub containers, respectively, in which you can put function and type definitions. The hierarchy is defined that you can have multiple modules in one namespace, also nested modules in a module, but no namespace in another namespace. You can acces namespaces and modules with the \u0060.\u0060 operator.\n\n*)\n\n//Module \u201Ccontainer\u201D \nmodule WidgetsModule =\n    let widgetName = \u0022FSharp\u0022\n    let widgetFunction x y =\n        sprintf \u0022%s %s\u0022 x y\n        // printfn \u0022%s %s\u0022 x y\n\n// Calls the function from the module\nWidgetsModule.widgetFunction \u0022Hello\u0022 WidgetsModule.widgetName\n\n(***include-it***)\n\n(**\n### Comments\n\nComments also help to write organized code.\n\n**Comments are text written in code area (often marked green) which will be ignored by the compiler and not be executed.**\n\n\u0060//\u0060 single line comments use a double slash\n\n(* multi-line or in-line comments use \u0060(* . . . *)\u0060 pair -end of multi line comment- *)\n\n*)\n\ntype PersonalInformation =\n    {\n        //First name of a person\n        FirstName  :string\n        //Last name of a person\n        LastName   :string\n        (*Address and\n        phone number of a person*)\n        Address    : (*int*) string\n        PhoneNumber: int\n    }\n\n(**\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP01_FSharpExcercises.html\u0027;\u0022\u003EJP01 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n\n(**\n\n## References\n\n\u003Col\u003E\n\u003Cli Id=\u00221\u0022\u003E Bertalanffy, L. von. Zu einer allgemeinen Systemlehre. Bl\u00E4tter f\u00FCr deutsche Philosophie 18 (1945).\u003C/li\u003E\n\n\u003Cli Id=\u00222\u0022\u003E Sauer, U., Heinemann, M. \u0026 Zamboni, N. Genetics. Getting closer to the whole picture. Science 316, 550\u2013551; 10.1126/science.1142502 (2007).\u003C/li\u003E\n\n\u003Cli Id=\u00223\u0022\u003E Kitano, H. Systems biology. a brief overview. Science 295, 1662\u20131664; 10.1126/science.1069492 (2002).\u003C/li\u003E\n\n\u003Cli Id=\u00224\u0022\u003E Joyce, A. R. \u0026 Palsson, B. O. The model organism as a system. integrating \u0027omics\u0027 data sets. Nat Rev Mol Cell Bio 7, 198\u2013210; 10.1038/Nrm1857 (2006).\u003C/li\u003E\n\n\u003Cli Id=\u00225\u0022\u003E Aderem, A. Systems biology. Its practice and challenges. Cell 121, 511\u2013513; 10.1016/j.cell.2005.04.020 (2005).\u003C/li\u003E\n\n\u003Cli Id=\u00226\u0022\u003E Kahlem, P. \u0026 Birney, E. Dry work in a wet world. computation in systems biology. Mol Syst Biol 2 (2006).\u003C/li\u003E\n\n\u003Cli Id=\u00227\u0022\u003E Kitano, H. Computational systems biology. Nature 420, 206\u2013210; 10.1038/nature01254 (2002). \u003C/li\u003E\n\u003C/ol\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/index.html","title":"The fslab documentation template\n","content":"(**\n# The fslab documentation template\n\nThis template scaffolds the necessary folder structure for FSharp.Formatting \nand adds custom styles in the **fslab** theme. \n\nThe provided stylesheet was compiled from sass (before uploading the nuget package) and\nuses the [Bulma](https://bulma.io/) CSS framework instead of bootstrap which is used by FSharp.Formatting per default.\n\n#### Table of contents \n\n- [Installation](#Installation)\n- [Usage](#Usage)\n- [Quick content rundown](#Quick-content-rundown)\n- [Creating new content](#Creating-new-content)\n- [Customization options](#Customization-options)\n    - [Style sheet options](#Style-sheet-options)\n    - [Inclusion of sample content](#Inclusion-of-sample-content)\n    - [Create notebooks](#Create-notebooks)\n\n\n## Installation\n\nThis template is available as a _dotnet new_ template (from [nuget](https://www.nuget.org/packages/FsLab.DocumentationTemplate/)):\n\n\u0060\u0060\u0060no-highlight\ndotnet new -i FsLab.DocumentationTemplate\n\u0060\u0060\u0060\n\n## Usage\n\nIf not already present, create a _local tool manifest_ in the root of your project that you want to write documentation for:\n\n\u0060\u0060\u0060no-highlight\ndotnet new tool-manifest\n\u0060\u0060\u0060\n\nThen, still in the root of your project, run:\n\n\u0060\u0060\u0060no-highlight\ndotnet new fslab-docs\n\u0060\u0060\u0060\n\n## Quick content rundown:\n\nThe default template initializes the following folder structure when you initialize it in the root of your project.\n\nSee [further below](#Customization-options) for command line customization options of the template.\n\n\u003Cpre\u003E\ndocs\n\u2502   index.fsx\n\u2502   _template.html\n|   _template.ipynb\n|   \n\u2502   0_Markdown-Cheatsheet.md\n\u2502   1_fsharp-code-example.fsx\n\u2502   2_inline-references.fsx\n\u2502   3_notebooks.fsx\n|\n\u251C\u2500\u2500\u2500content\n\u2502   fsdocs-custom.css\n\u2502\n\u251C\u2500\u2500\u2500img\n\u2502       favicon.ico\n\u2502       logo.png\n\u2502\n\u2514\u2500\u2500\u2500reference\n        _template.html\n\u003C/pre\u003E\n\n- \u0060index.fsx\u0060 is the file you are reading just now. It contains the very content you are reading at the moment \nin a markdown block indicated by \u0060(** *)\u0060 guards. It will be rendered as the root \u0060index.html\u0060 file of your documentation.\n\n- \u0060_template.html\u0060 is the root html scaffold (sidebar to the left, script and style loading) where all of the individual docs will be injected into\n\n- \u00600_Markdown-Cheatsheet.md\u0060 is a adaption of [this markdown cheat sheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) that shows how to write markdown and showcases the rendered equivalents. It can also be viewed in all its glory [here](https://fslab.org/docs-template/0_Markdown-Cheatsheet.html).\n\n- \u00601_fsharp-code-example.fsx\u0060 is a script file that showcases the syntax highlighting style for F# snippets. It can also be viewed in all its glory [here](https://fslab.org/docs-template/1_fsharp-code-example.html).\n\n- \u00602_inline-references.fsx\u0060 is a script file that explains how to use inline references and use Plotly.NET for charting. It can also be viewed in all its glory [here](https://fslab.org/docs-template/2_inline-references.html).\n\n- \u00603_notebooks.fsx\u0060 is a script file that showcases conditional content in documentation and how to use that to create dotnet interactive notebooks besides your html documentation. It can also be viewed in all its glory [here](https://fslab.org/docs-template/3_notebooks.html).\n\n- \u0060fsdocs-custom.css\u0060 contains the custom styling that applies the fslab styles.\n\n - the \u0060img\u0060 folder contains the fslab logo and favicon. replace these files (with the same names) to youse sours\n\n - \u0060reference/_template.html\u0060 is a slightly adapted version of the template above for the API documentation\n\n## Creating new content\n\n- run \u0060dotnet fsdocs watch --eval\u0060 to spawn a watcher and dev server that hosts your docs on http://localhost:8901/ (You currently will still have to refresh the page when you make changes to files)\n\n- add a new .md or .fsx file to the \u0060content\u0060 directory (or into a new subdirectory there)\n\n- the sidebar title for the document will be either the file name or, if existent, the first level 1 header in the file\n\n- when writing a .fsx file, code will automatically become syntax-highlighted code snippets. \n\n- use \u0060(** \u003Cmarkdown here\u003E *)\u0060 to guard markdown sections in .fsx files\n\n- use \u0060(*** include-value:\u003Cval name\u003E ***)\u0060 to include the value of a binding\n\n- use \u0060(*** include-it ***)\u0060 to include the evaluation of the previous snippet block \n\nFor more info please refer to the [FSharp.Formatting documentation](http://fsprojects.github.io/FSharp.Formatting/).\n\n\n## Customization options\n\n### Style sheet options\n\n\u0060\u0060\u0060no-highlight\n-s|--styles             Set the type of style content the template will initialize. For the sass file to work, you will have to download bulma\n\n        all             - sass file, compiled csss, and minified css\n\n        sass            - only include the sass file\n\n        minified        - only include the minified css file\n\n        css             - only include the compiled css file\n\n        Default:        css\n\u0060\u0060\u0060\n\n### Inclusion of sample content\n\n\u0060\u0060\u0060no-highlight\n-is|--include-samples   wether to include sample files in the generated content\n\n        bool            - Optional\n\n        Default:        true\n\u0060\u0060\u0060\n\n### Create notebooks\n\n\u0060\u0060\u0060no-highlight\n-in|--include-notebooks  wether to include the notebook template file\n        \n        bool            - Optional\n\n        Default:        true\n\u0060\u0060\u0060\n\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP11_Quantification.html","title":"JP11 Quantification\n","content":"(**\n# JP11 Quantification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP11_Quantification.ipynb)\n\n1. [Quantification Theory](#Quantification-Theory)\u003Cbr\u003E\n    1. [Targeted quantification](#Targeted-quantification)\n    2. [(i) Targeted acquisition at peptide](#(i)-Targeted-acquisition-at-peptide)\n    3. [(ii) Targeted data analysis at peptide ion level](#(ii)-Targeted-data-analysis-at-peptide-ion-level)\n2. [References](#References)\n*)\n\n(**\n## Quantification Theory\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTo estimate the amount of individual proteins in complex mixtures, all peptide signals corresponding to a common protein serve as a \nproxy for their abundance. Peptide information needs to be obtained from multidimensional signal data detected by the mass spectrometer. \nAll signals generated from one peptide ion species, often referred to as peptide feature, need to be grouped to form a three-dimensional peak \nalong the m/z, ion intensity, and retention time dimension. This process is generally defined as peak detection or feature detection. \nPeak detection algorithms are a set of rules defining how neighboring signal points are joined. Whether noise filtering is done before or after \npeak detection strongly depends on the peak detection algorithm. Traditional approaches mainly focused on signal amplitude neglecting \ncharacteristic peak shapes as a common feature of chromatographic or spectroscopic peaks. These algorithms are prone to miss detection of low \nintensity peaks with a signal strength close to the noise level. To overcome these issues, techniques like smoothing, shape-matching and curve \nfitting are often implemented and applied. At the time, the most promising approach to do shape-matching and noise reduction in one step uses the \ncontinuous wavelet transformation (CWT).\n\nIn general, a CWT based approach describes a family of time-frequency-transformations often used in data compression and feature detection. \nThe term is coined by the use of a wavelet, as a basis function which is \u201Ccompared\u201D to the signal. The point of highest correlation between the \nbasis function and the signal reflects the location of the peak present. Due to the fact that MS derived peaks often follow the shape of a \ngaussian distribution, the \u003Ci\u003EMexican Hat\u003C/i\u003E wavelet as the negative normalized second derivative of the Gaussian distribution is perfectly \nsuited to find the peptide feature.\n\n\u003Cdiv Id=\u0022figure5\u0022 Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 70% ; padding: 15px\u0022\u003E\n    \u003Cimg src=\u0022img/Wavelets.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\n        \u003Cb\u003EFigure 5: Schematic representation of the \u2018Haar\u2019-wavelet (blue) and the \u2018Mexican Hat\u2019- wavelet (green). \u003C/b\u003EThe \u2018Haar\u2019-wavelet is \n        named after its discoverer Alfred Haar and represents the first wavelet ever to be described. The \u2018Mexican Hat\u2019- or \u2018Ricker\u2019-wavelet is \n        frequently used in the fields of signal detection and compression.\n    \u003C/div\u003E\n\u003C/div\u003E    \n\nDepending on the quantification approach, the peptide features used for protein quantification might differ. In case of isotopic labeling, \nquantification means pairing features with the proper mass shift according to the utilized label. It is essential to account for the frequency \nof label incorporation when calculating the mass shift for the utilized label. Taking the ICAT method as an example, by which a heavy/light \ndifference of 9 Dalton per cysteine is incorporated, the total mass shift is 9 Dalton times the number of cysteine within the sequence. \nConsequently, pairing peptide features for \u003Csup\u003E15\u003C/sup\u003EN labeling is even more challenging, as the mass shift is less discrete. Using stable \nisotope labeling, different peptide feature pairs belonging to the same protein can be treated as technical replicates and averaged to gain \nprotein quantification. In contrast, the sum of all extracted peptide signals results in a label-free protein quanti\uFB01cation. Spectral counting \ncomputes abundance values from the number of times a peptide was successfully identi\uFB01ed by tandem mass spectrometry (MS/MS) and combines all \nthese events per protein. The spectral counting values can be normalized by the number of peptides theoretically expected from the particular \nprotein. \n\n\u003Cdiv Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 100% ; padding: 15px; max-width: 800px\u0022\u003E\n    \u003Cimg src=\u0022img/ComputationalProteinQuantification.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\n        \u003Cb\u003EFigure 6: Computational strategy of peptide and protein quanti\uFB01cation on based on stable isotope labeling or by label-free \n        quanti\uFB01cation.\u003C/b\u003E (A) Label-free methods compare corresponding peptide abundances over different MS runs. The abundance is either \n        estimated by the elution pro\uFB01le les of the pep de ions or (B) in case of spectral counting, by the number of times a peptide was \n        successfully identi\uFB01ed (MS2). In contrast, methods based on differential stable isotope labeling analyze peptides pairs detected by \n        their characteristic mass di\uFB00erence \u0394m/z. The abundance is estimated by the ratio of their corresponding elution pro\uFB01les (C). Isobaric \n        tagging methods (D) compare the reporter ion abundances in the fragmentation spectrum.\n    \u003C/div\u003E\n\u003C/div\u003E\n\n\u003C/div\u003E\n*)\n\n(**\n### Targeted quantification\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTargeted proteomics has gained significant popularity in mass spectrometry\u2010based protein quantification as a method to detect proteins of \ninterest with high sensitivity, quantitative accuracy and reproducibility. The two major strategies of (i) targeted acquisition at peptide, \nand (ii) targeted data analysis at peptide ion level need to be distinguished.\n\u003C/div\u003E\n*)\n\n(**\n###(i) Targeted acquisition at peptide\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nIn multiple reaction monitoring (MRM or SRM for single/selected reaction monitoring) simply predefined transitions are recorded. \nKnowledge about the targeted transitions from precursor to their corresponding fragment ions are needed and predefined in the mass \nspectrometer. MRM can be performed rapidly and is highly specific even for low abundant peptide ions in complex mixtures, but with the \ndrawback of a necessary bias in the sense that only predefined peptides are measured.\n\u003C/div\u003E\n*)\n\n(**\n### (ii) Targeted data analysis at peptide ion level\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nData\u2010independent acquisition at the peptide level makes it possible to acquire peptide data for virtually all peptide ions present in a sample. \nIn this strategy, a high\u2010resolution mass analyzer\u2014such as an orbitrap or a time\u2010of\u2010flight\u2014is used to constantly sample the full mass range \nat the peptide level during the entire chromatographic gradient. In a subsequent step, precursor ion chromatograms can be extracted by targeted \ndata analysis. Those extracted-ion chromatogram (XIC) can be obtained to calculate the area under the curve and used for peptide quantification.\n\nLet\u2019s start and extract a XIC\u2026\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: System.Data.SQLite, 1.0.113.7\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: MzIO, 0.1.0-beta\u0022\n#r \u0022nuget: MzIO.SQL, 0.1.0-beta\u0022\n#r \u0022nuget: MzIO.Processing, 0.1.0-beta\u0022\n#r \u0022nuget: FS3, 0.0.2-alpha\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen FSharp.Stats\nopen BioFSharp\nopen System.IO\nopen System.Data.SQLite\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\nWe now want to extract the XIC for the peptide where we previously calculated the matching score.\n\nSince we need several mass spectrometry scans to quantify over the retention time, we connect to our database \nand index the entries according to their retention time.\n\u003C/div\u003E\n*)\n(***hide***)\nlet s3Client = FS3.S3Client.initS3UniKl \u0022NVN8Q7U7Y7P09X2YCQD3\u0022 \u0022GhN62eaDzqEV/tVAPrbG4Bz1sbkAWWyYZxo4YsZ8\u0022\n(** *)\n// Code-Block 1\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/sample.mzlite\u0022|]\nlet checkFile =\n    if File.Exists path then ()\n    else\n        Directory.CreateDirectory (Path.GetDirectoryName path)\n        FS3.AccessTransferUtility.objectMultipartDownload s3Client \u0022sample.mzlite\u0022 \u0022bio-bte-06-l-7\u0022 path\nlet runID = \u0022sample=0\u0022\n\nlet mzReader = new MzIO.MzSQL.MzSQL(path)\nlet cn = mzReader.Open()\nlet transaction = mzReader.BeginTransaction()\n\n// Indexes all spectra of the related sample run\nlet idx = MzIO.Processing.Query.getMS1RTIdx mzReader runID\nidx\n\n(***include-it***)\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\n\u003Cb\u003EWe know from the MS\u003Csup\u003E2\u003C/sup\u003E measurement, that our peptide had its match at a retention of around 51.95 min\u003C/b\u003E. We create a query \nto the database to extract the intensities of all peaks that are \u002B/-5 min of our retention time and within 0.04 m/z of our peptide of interest. \nAfter we are done, we close the connection to the database.\n\u003C/div\u003E\n*)\n\n// Code-Block 2\n\nlet retentionTime = 51.95\nlet mzAtCharge2   = 511.2691141\n\nlet rtQuery = MzIO.Processing.Query.createRangeQuery retentionTime 5.\n\nlet mzQuery = MzIO.Processing.Query.createRangeQuery mzAtCharge2 0.04\n\nlet xic = \n    MzIO.Processing.Query.getXIC mzReader idx rtQuery mzQuery  \n    |\u003E Array.map (fun p -\u003E p.Rt , p.Intensity)\n    \ntransaction.Dispose()\n\nlet xicChart =\n    xic\n    |\u003E Chart.Point\n    |\u003E Chart.withX_AxisStyle \u0022Retention Time\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Intensity/Score\u0022\n    |\u003E Chart.withSize (900.,900.)\n\n(***hide***)\nxicChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nWe have now the XIC in our hands and can use the second derivative to identify peaks with our trace.\n*)\n\n// Code-Block 3\n\n// get all peaks\nlet peaks = \n    xic\n    |\u003E Array.unzip\n    |\u003E (fun (ret, intensity) -\u003E\n        FSharp.Stats.Signal.PeakDetection.SecondDerivative.getPeaks 0.1 2 13 ret intensity\n        )\n\npeaks |\u003E Array.head\n\n(***include-it***)\n\n(**\nThe peak model includes numerus information. Therefore we can mark the apices of the peaks we identified.\n*)\n\n// Code-Block 4\n\nlet apices =\n    peaks\n    |\u003E Array.map (fun peak -\u003E peak.Apex.XVal,peak.Apex.YVal)\n\nlet apicesChart=\n    [    \n        Chart.Point(apices, Name=\u0022apices\u0022)\n        |\u003E Chart.withMarkerStyle(Size=15)\n        Chart.Point(xic, Name = \u0022XIC\u0022)\n\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_AxisStyle \u0022Retention Time\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Intensity\u0022\n    |\u003E Chart.withSize (900.,900.)\n\n(***hide***)\napicesChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nWe can then go ahead and characterize our peak and quantify the area under the fitted curve.\n*)\n\n// Code-Block 5\n\n// get peak at \u0022ret=51.95\u0022 from all peaks \u0022peaks\u0022\nlet quantifiedXIC = \n    BioFSharp.Mz.Quantification.HULQ.getPeakBy peaks retentionTime\n    // quantify peak of interest\n    |\u003E BioFSharp.Mz.Quantification.HULQ.quantifyPeak \n    \nquantifiedXIC.Area\n\n(***include-it***)\n\n(**\nThe peak model gives us all the information we need for our peptide of interest. If we want to see what we quantified, we can take an \nexponential modified gaussian function using the parameters given by the peak model and plot it together with the previously extracted XIC.\n*)\n\n// Code-Block 6\n\nlet eval x = \n    Fitting.NonLinearRegression.Table.emgModel.GetFunctionValue (vector quantifiedXIC.EstimatedParams) x\n\neval\n\n(**\n*)\n\n// Code-Block 7\n\nlet quantifiedArea =\n    xic \n    |\u003E Array.map (fun (rt,i) -\u003E rt, eval rt)\n\nlet quantifiedAreaChart =\n    [\n        Chart.Point(xic,Name=\u0022XIC\u0022)\n        Chart.SplineArea(quantifiedArea,Name=\u0022quantified XIC\u0022)\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_AxisStyle (title = \u0022Retention Time\u0022, MinMax = (51.,55.))\n    |\u003E Chart.withY_AxisStyle \u0022Intensity\u0022\n    |\u003E Chart.withSize (900.,900.)\n\n(***hide***)\nquantifiedAreaChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP10_Peptide_Identification.html\u0027;\u0022\u003EJP10 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP10_Peptide_Identification.html","title":"JP10 Peptide Identification\n","content":"\n(**\n# JP10 Peptide Identification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP10_Peptide_Identification.ipynb)\n\n\n1. [Understanding peptide identification from MS\u003Csup\u003E2\u003C/sup\u003E spectra](#Understanding-peptide-identification-from-MS2-spectra)\n2. [Matching and scoring of Tandem MS peptide identification](#Matching-and-scoring-of-Tandem-MS-peptide-identification)\n    3. [Step 1: Data acquisition and preprocessing](#Step-1:-Data-acquisition-and-preprocessing)\n    4. [Step 2: Preselecting the peptides of interest](#Step-2:-Preselecting-the-peptides-of-interest)\n    5. [Step 3\u002B4: Matching and Scoring](#Step-3\u002B4:-Matching-and-Scoring)\n*)\n\n(**\n## Understanding peptide identification from MS\u003Csup\u003E2\u003C/sup\u003E spectra\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nUnder low-energy fragmentation conditions, peptide fragment patterns are reproducible and, in general, predictable, which allows for an \namino acid sequence identification according to a fragmentation expectation. Algorithms for peptide identification perform in principle \nthree basic tasks:\n\n\u003Cb\u003E(i)\u003C/b\u003E a raw data preprocessing step is applied to the MS/MS spectra to obtain clean peak information. The same signal filtering \nand background subtraction methods are used as discussed in the section of low-level processing. Peak detection, however, may be performed \ndifferently. Preprocessing of MS/MS spectra focuses on the extraction of the precise m/z of the peak rather than the accurate peak areas. \nThe conversion of a peak profile into the corresponding m/z and intensity values reduces the complexity, its representation is termed centroiding. \nTo extract the masses for identification in a simple and fast way, peak fitting approaches are used. These approaches take either the most intense \npoint of the peak profile, fit a Lorentzian distribution to the profile, or use a quadratic fit\u003Csup\u003E\u003Ca href=\u0022#37\u0022\u003E37\u003C/a\u003E\u003C/sup\u003E. \n\n\u003Cb\u003E(ii)\u003C/b\u003E Spectrum information and possible amino acid sequences assignments are evaluated. \n\n\u003Cb\u003E(iii)\u003C/b\u003E The quality of the match between spectrum and possible sequences is scored.\n\nEven though the three steps roughly describe the basic principle of algorithms used for peptide sequence identification, most implementations \nshow differences in individual steps which can lead to major changes in the outcome. Therefore, it has been proven useful to utilize more than \none algorithm for a robust and thorough identification. Due to their major difference in identification strategies and prerequisites, \nidentification algorithms are normally classified into three categories: (i) \u003Ci\u003Ede novo\u003C/i\u003E peptide sequencing, (ii) peptide sequence-tag (PST) \nsearching, and (iii) uninterpreted sequence searching. However, in this notebook we focus on the explanation of (iii) uninterpreted sequence \nsearching, the most frequently used methods.\n\u003C/div\u003E\n*)\n\n(**\n## Matching and scoring of Tandem MS peptide identification\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\n\u003Cdiv class=\u0022container\u0022\u003E\n\n\u003Cdiv Id=\u0022figure4\u0022 Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 60% ; padding: 15px\u0022\u003E\n    \u003Cimg src=\u0022img/ComputationalProteinIdentification.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\u003Cb\u003E\n        Figure 4: Process of computational identification of peptides from their fragment spectra\u003C/b\u003E\n    \u003C/div\u003E\n\u003C/div\u003E    \n\nPreviously we learned, that peptides fragment to create patterns characteristic of a specific amino acid sequence. These patterns are reproducible and, in general, predictable taking the applied fragmentation method into account. This can be used for computational identification of peptides from their fragment spectra. This process can be subdivided into 5 main steps: spectrum preprocessing, selection of possible sequences, generating theoretical spectra, matching and scoring (\u003Ca href=\u0022#figure5\u0022 \u003EFigure 4\u003C/a\u003E). The first step is a preprocessing of the experimental spectra and is done to reduce noise. Secondly, all possible amino acid sequences are selected which match the particular precursor peptide mass. The possible peptides can but do not need to be restricted to a particular organism. A theoretical spectrum is predicted for each of these amino acid sequences. Matching and scoring is performed by comparing experimental spectra to their predicted corresponding theoretical spectra. The score function measures the closeness of fit between the experimental acquired and theoretical spectrum. There are many different score functions, which can be considered as the main reason of different identifications considering different identification algorithm. The most natural score function is the cross correlation score (xcorr) used by the commercially available search tool SEQUEST. One of the reasons the xcorr is so sensitive is because it involves a correction factor that assesses the background correlation for each acquired spectrum and the theoretically predicted spectrum from sequences within a database. To compute this correction factor, a measure of similarity is calculated at different offsets between a preprocessed mass spectrum and a theoretical spectrum. The final xcorr is then the correlation at zero offset minus the mean correlation from all the individual offsets.\n\nThus, the correlation function measures the coherence of two signals by, in effect, translating one signal across the other. This can be mathematically achieved using the formula for cross-correlation in the form for discrete input signals:\n\n\u003Ci\u003E\u003Cb\u003EEquation 5\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?\\large\u0026space;R_{\\tau}\u0026space;=\u0026space;\\sum_{i=0}^{n-1}x_{i}\\cdot y_{i\u0026plus;\\tau}\u0022 title=\u0022\\large R_{\uD835\uDF0F} = \\sum_{i=0}^{n-1}x_{i}\\cdot y_{i\u002B\uD835\uDF0F}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nwhere x\u003Csub\u003Ei\u003C/sub\u003E is a peak of the reconstructed spectrum at position i and y\u003Csub\u003Ei\u003C/sub\u003E is a peak of the experimental spectrum. The displacement value \uD835\uDF0F is the amount by which the signal is offset during the translation and is varied over a range of values. If two signals are the same, the correlation function should have its maxima at \uD835\uDF0F=0, where there is no offset. The average of the offset-correlation is seen as the average background correlation and needs to be subtracted from the correlation at \uD835\uDF0F=0. It follows: \n\n\u003Ci\u003E\u003Cb\u003EEquation 6\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?xcorr\u0026space;=\u0026space;R_{0}\u0026space;-\u0026space;\\frac{(\\sum\u0026space;\\begin{matrix}\u0026space;\\tau=\u0026plus;offeset\\\\\u0026space;\\tau=-offeset\\end{matrix}R_{\\tau})}{2*offset\u0026plus;1}\u0022 title=\u0022xcorr = R_{0} - \\frac{(\\sum \\begin{matrix} \\tau=\u002Boffeset\\\\ \\tau=-offeset\\end{matrix}R_{\\tau})}{2*offset\u002B1}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nIn practice many theoretical spectra have to be matched again a single experimental spectrum. Therefore, the calculation can be speed up by reformulating Equation 5 and Equation 6 and introduce a preprocessing step, which is independent of the predicted spectra.\n\n\u003Ci\u003E\u003Cb\u003EEquation 7\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?xcorr\u0026space;=\u0026space;x_{0}\\cdot\u0026space;y_{0}\u0026space;-\u0026space;\\frac{(\\sum\u0026space;\\begin{matrix}\u0026space;\\tau=\u0026plus;offeset\\\\\u0026space;\\tau=-offeset\\end{matrix}x_{0}\\cdot\u0026space;y_{\\tau})}{2*offset\u0026plus;1}\u0022 title=\u0022xcorr = x_{0}\\cdot y_{0} - \\frac{(\\sum \\begin{matrix} \\tau=\u002Boffeset\\\\ \\tau=-offeset\\end{matrix}x_{0}\\cdot y_{\\tau})}{2*offset\u002B1}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nFor the preprocessed experimental spectrum y\u0027 it follows:\n\n\u003Ci\u003E\u003Cb\u003EEquation 8\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?xcorr\u0026space;=\u0026space;x_{0}\\cdot\u0026space;y\u0027\u0022 title=\u0022xcorr = x_{0}\\cdot y\u0027\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nwhere:\n\n\u003Ci\u003E\u003Cb\u003EEquation 9\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?y\u0027\u0026space;=\u0026space;y_{0}\u0026space;-\u0026space;\\frac{(\\sum\u0026space;\\begin{matrix}\u0026space;\\tau=\u0026plus;offeset\\\\\u0026space;\\tau=-offeset\\end{matrix}x_{0}\\cdot\u0026space;y_{\\tau})}{2*offset\u0026plus;1}\u0022 title=\u0022y\u0027 = y_{0} - \\frac{(\\sum \\begin{matrix} \\tau=\u002Boffeset\\\\ \\tau=-offeset\\end{matrix}x_{0}\\cdot y_{\\tau})}{2*offset\u002B1}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\n\u003Cdiv Style=\u0022text-align: justify ; margin-top: 2rem ; margin-bottom: 2rem ; line-height: 1.3 ; width: 85% ; margin-left: auto ; margin-right: auto ; padding: 10px ; border: 2px dotted #708090 ; color: #708090\u0022\u003E\nMatching a measured spectrum against chlamy database\n\u003C/div\u003E\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\n\n(**\n### Step 1: Data acquisition and preprocessing\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\nWe load a single MS\u003Csup\u003E2\u003C/sup\u003E spectrum that is saved in a mgf file.\n*)\n\n// Code-Block 1\n\nlet ms2 = \n    BioFSharp.IO.Mgf.readMgf (__SOURCE_DIRECTORY__ \u002B @\u0022/../AuxFiles/ms2sample.mgf\u0022)\n    |\u003E List.head\n    \nms2\n\n(***include-it***)\n\n(**\nHere, the spectrum is already centroidized as shown in \u003Ca href=\u0022JP08_Centroidisation.ipynb\u0022\u003EJP08_Centroidisation\u003C/a\u003E using the function \n\u003Ccode\u003EmsPeakPicking\u003C/code\u003E. So we just visualize mass and intensity:\n*)\n\n// Code-Block 2\n\nlet ms2Chart = Chart.Column(ms2.Mass, ms2.Intensity)\n\n(***hide***)\nms2Chart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nNow, we will preprocess the experimental spectrum from our example. This is on the one hand to reduce noise, but also to make \nthe measured spectrum more like the once we are able to simulate. \n*)\n\n// Code-Block 3\n\nlet lowerScanLimit = 150.\nlet upperScanLimit = 1000.\n\nlet preprocessedIntesities =\n    Mz.PeakArray.zip ms2.Mass ms2.Intensity\n    |\u003E (fun pa -\u003E Mz.PeakArray.peaksToNearestUnitDaltonBinVector pa lowerScanLimit upperScanLimit)\n    |\u003E (fun pa -\u003E Mz.SequestLike.windowNormalizeIntensities pa 10)\n    \nlet intensityChart = Chart.Column([lowerScanLimit .. upperScanLimit], preprocessedIntesities)\n\n(***hide***)\nintensityChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n### Step 2: Preselecting the peptides of interest\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nEvery MS\u003Csup\u003E2\u003C/sup\u003E spectrum is accompanied by a m/z ratio reported by the instrument. Additionally, we can estimate the charge looking \nat the isotopic cluster. We take the peptide \u0022DTDILAAFR\u0022 from our previous notebook again. Our example has a measured m/z = 511.2691141 and \na charge of z=2.\n\u003C/div\u003E\n*)\n\nlet peptideMass = \n    Mass.ofMZ 511.2691141 2.\n\npeptideMass\n\n(***include-it***)\n\n(**\nFrom our previos notebook \u003Ca href=\u0022JP04_Digestion_and_mass_calculation.ipynb\u0022\u003EJP04 Digestion and mass calculation\u003C/a\u003E, we know how to \ncalculate all peptide masses that we can expect to be present in \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E.\n*)\n\n// Code-Block 4\n\nlet source = __SOURCE_DIRECTORY__\nlet filePath = source \u002B @\u0022/../AuxFiles/Chlamy_JGI5_5(Cp_Mp).fasta\u0022\n\nlet peptideAndMasses = \n    filePath\n    |\u003E IO.FastA.fromFile BioArray.ofAminoAcidString\n    |\u003E Seq.toArray\n    |\u003E Array.mapi (fun i fastAItem -\u003E\n        Digestion.BioArray.digest Digestion.Table.Trypsin i fastAItem.Sequence\n        |\u003E Digestion.BioArray.concernMissCleavages 0 0\n        )\n    |\u003E Array.concat\n    |\u003E Array.map (fun peptide -\u003E\n        // calculate mass for each peptide\n        peptide.PepSequence, BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n        )\n\npeptideAndMasses |\u003E Array.head\n\n(***include-it***)\n\n(**\nHowever, we are only interest in possible amino acid sequences, that match the particular precursor peptide mass of our example spectrum \nwith 1020.523675 Da. Additionaly, we should also consider a small measurement error.\n*)\n\n// Code-Block 5\n\npeptideAndMasses\n|\u003E Array.filter (fun (sequence,mass) -\u003E mass \u003E 1020.52  \u0026\u0026 mass \u003C 1020.53)\n\n(***include-it***)\n\n(**\nIn the previous notebook \u003Ca href=\u0022JP09_Fragmentation_for_peptide_identification.ipynb\u0022\u003EFragmentation for peptide identification\u003C/a\u003E, \nwe used functions that generate the theoretical series of b- and y-ions from the given peptide. Combined with the function \n\u003Ccode\u003EMz.SequestLike.predictOf\u003C/code\u003E that generates theoretical spectra that fit the Sequest scoring algorithm.\n*)\n\n// Code-Block 6\n\nlet predictFromSequence peptide =\n    [\n        peptide\n        |\u003E Mz.Fragmentation.Series. yOfBioList BioItem.initMonoisoMassWithMemP\n        peptide\n        |\u003E Mz.Fragmentation.Series.bOfBioList BioItem.initMonoisoMassWithMemP\n    ]\n    |\u003E List.concat\n    |\u003E Mz.SequestLike.predictOf (lowerScanLimit,upperScanLimit) 2.\n\npredictFromSequence\n\n(**\n### Step 3\u002B4: Matching and Scoring\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\nIn the matching step, we compare theoretical spectra of peptides within our precursor peptide mass range with our measured spectra. \nWe get a score which tells us how well the theoretical spectrum fits the given experimental spectrum.\n*)\n\n// Code-Block 7\n\npeptideAndMasses\n|\u003E Array.filter (fun (sequence,mass) -\u003E\n    mass \u003E 1020.52  \u0026\u0026 mass \u003C 1020.53\n)\n|\u003E Array.map (fun (sequence,mass)    -\u003E\n    sequence,predictFromSequence sequence\n)\n|\u003E Array.map (fun (sequence,theoSpectrum) -\u003E \n    sequence,Mz.SequestLike.scoreSingle theoSpectrum preprocessedIntesities\n)\n|\u003E Array.sortByDescending (fun (sequence,score) -\u003E score)\n\n(***include-it***)\n\n(**\nFinaly, we pick the sequence with the best score and are done for now. Notice however, that in a real world we would need to \nrelate our score to the complete data set to get an idea of the overall quality and which numerical value we could trust. \n*)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP09_Fragmentation_for_peptide_identification.html\u0027;\u0022\u003E\u0026#171; JP09\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP11_Quantification.html\u0027;\u0022\u003EJP11 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP04_Digestion_and_mass_calculation.html","title":"JP04 Digestion and mass calculation\n","content":"(** \n# JP04 Digestion and mass calculation\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP04_Digestion_and_mass_calculation.ipynb)\n\n1. [Digestion and mass calculation](#Digestion-and-mass-calculation)\n    2. [Accessing the protein sequences of \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E](#Accessing-the-protein-sequences-of-Chlamydomonas-reinhardtii)\n    3. [Amino acid distribution for \u003Ci\u003EC. reinhardtii\u003C/i\u003E](#Amino-acid-distribution-for-C.-reinhardtii)\n4. [Calculating the molecular weight for peptides](#Calculating-the-molecular-weight-for-peptides)\n    5. [\u003Ci\u003EIn silico\u003C/i\u003E digestion of FASTA proteins with trypsin](#In-silico-digestion-of-FASTA-proteins-with-trypsin)\n    6. [Calculating peptide masses](#Calculating-peptide-masses)\n    7. [Calculating peptide masses for charge 2](#Calculating-peptide-masses-for-charge-2)\n6. [References](#References)\n*)\n\n(** \n## Digestion and mass calculation\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nThe most widely applied method for protein digestion involves the use of enzymes. Many proteases are available for this purpose, \neach having their own characteristics in terms of specificity, efficiency and optimum digestion conditions. Trypsin is most widely \napplied in bottom-up proteomics and and has a very high degree of specificity, cleaving the peptide bonds C-terminal to the basic residues \nLys and Arg, except when followed by Pro\u003Csup\u003E\u003Ca href=\u0022#23\u0022\u003E23\u003C/a\u003E\u003C/sup\u003E. In general, Lys and Arg are relatively abundant amino acids and are \nusually well distributed throughout a protein\u003Csup\u003E\u003Ca href=\u0022#24\u0022\u003E24\u003C/a\u003E\u003C/sup\u003E. This leads to tryptic peptides with an average length of \u223C14 amino \nacids that carry at least two positive charges, which is ideally suited for CID-MS analysis\u003Csup\u003E\u003Ca href=\u0022#23\u0022\u003E23\u003C/a\u003E\u003C/sup\u003E.\n\nUsing \u003Ci\u003Ein silico\u003C/i\u003E analysis, we want to confirm that the general properties of trypsin digestion also apply for the \nproteome of \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E . First, we load the proteome of \u003Ci\u003EChlamydomonas\u003C/i\u003E in standard fastA format. \nAmino acid composition of the proteome is simply counting each amino acid occurrence and can be visualized by a histogram:\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\n\n(**\n## Accessing the protein sequences of \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nFASTA is a standardized text format, containing gene or protein sequence information. Such FASTAs can be donwloaded \nfrom \u003Ca href=\u0022https://www.uniprot.org/proteomes/UP000006906\u0022\u003EUniProt\u003C/a\u003E for example.\n\nTo gain informations about the amino acid composition of \u003Ci\u003EC. reinhardtii\u003C/i\u003E, we need information about the proteome \nof \u003Ci\u003EChlamydomonas\u003C/i\u003E, which is saved in the .fasta file we are accessing below.\n\u003C/div\u003E\n*)\n\n// __SOURCE_DIRECTORY__ returns the directory in which the current notebook is located\nlet source = __SOURCE_DIRECTORY__\n// with /../ we navigate a directory \nlet filePath = source \u002B \u0022/../AuxFiles/Chlamy_JGI5_5(Cp_Mp).fasta\u0022\nfilePath\n\n(*** include-it ***)\n\n(**\nFunctions to read information from FASTA files exist in the \u003Ca href=\u0022https://csbiology.github.io/BioFSharp/\u0022\u003EBioFSharp\u003C/a\u003E library.\n*)\n\nlet sequences = \n    filePath\n    |\u003E IO.FastA.fromFile BioArray.ofAminoAcidString\n    |\u003E Seq.toArray\n    \n// Display the first element in the array collection\nsequences |\u003E Array.head\n\n(*** include-it ***)\n\n(**\n\n## Amino acid distribution for \u003Ci\u003EC. reinhardtii\u003C/i\u003E\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTo count the amino acid composition, we take the sequence of every protein and count the occurences of each amino acid\n\u003C/div\u003E\n\n*)\n\nlet aminoAcidDistribution =\n    sequences\n    // only access Sequence from each array element.\n    |\u003E Array.collect (fun fastAItem -\u003E fastAItem.Sequence)\n    // count each occurence of all amino acids. \n    |\u003E Array.countBy id\n    \naminoAcidDistribution\n\nlet aaDistributionHis =\n    aminoAcidDistribution\n    |\u003E Array.map (fun (name,count) -\u003E count, string name)\n    // sort by number of occurences\n    |\u003E Array.sortBy fst\n    // create chart\n    |\u003E Chart.Bar\n    // style chart\n    |\u003E Chart.withX_AxisStyle \u0022Count\u0022\n    |\u003E Chart.withTitle \u0022Amino Acid composition of the \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E proteome\u0022\n\n(***hide***)\naaDistributionHis |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n    \n\n(**\n\n## Calculating the molecular weight for peptides\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nThe molecular weight M of a peptide may be estimated by calculating the equation for the molecular weight of a peptide: \n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?M\u0026space;=\u0026space;M_{N}\u0026plus;M_{C}\\sum_{i=0}^{n}N_{i}M_{i}\u0022 title=\u0022M = M_{N}\u002BM_{C}\\sum_{i=0}^{n}N_{i}M_{i}\u0022 Style=\u0022margin: 1rem auto 0; display: block\u0022 /\u003E\n\nwhere N\u003Csub\u003Ei\u003C/sub\u003E are the number, and M\u003Csub\u003Ei\u003C/sub\u003E the average residue molecular weights, of the amino acids. M\u003Csub\u003EN\u003C/sub\u003E \u002B M\u003Csub\u003EC\u003C/sub\u003E \nare added to the total in order to account for the termini: H at the N-terminus and OH at the C-terminus. (Remark: if the termini are modified, \nthese additions are replaced by those of the modifiers.) \n\n\u003Cdiv Style=\u0022text-align: justify ; font-size: 1.5rem ; margin-top: 2rem ; margin-bottom: 2rem ; line-height: 1.3 ; width: 85% ; margin-left: auto ; margin-right: auto ; padding: 10px ; border: 2px dotted #708090 ; color: #708090\u0022\u003E\nThe distribution of all molecular weights for the peptides resulting from the previous proteome digest can be calculated and visualized using a histogram chart: \n\u003C/div\u003E\n\n\u003C/div\u003E\n*)\n\n(**\n## \u003Ci\u003EIn silico\u003C/i\u003E digestion of FASTA proteins with trypsin\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTo gain information about the peptide sequences of each protein, we have to compute the digested sequence, A digest function with \nvariable protease exists in BioFSharp.\n\u003C/div\u003E\n*)\n\nlet digestedProteins =\n    // sequences is the fasta data\n    sequences\n    |\u003E Array.mapi (fun i fastAItem -\u003E\n        // in silico digestion\n        Digestion.BioArray.digest Digestion.Table.Trypsin i fastAItem.Sequence\n        |\u003E Digestion.BioArray.concernMissCleavages 0 1\n    )\n    |\u003E Array.concat\n    \ndigestedProteins |\u003E Array.head\n\n(*** include-it ***)\n\n(**\n## Calculating peptide masses\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nWe calculate the mass of each peptide by calculating the monoisotopic mass of each amino acid and adding the weight \nof an H\u003Csub\u003E2\u003C/sub\u003EO to each peptide weight.\n\u003C/div\u003E\n*)\n\nlet chartDigestedProteins =\n    digestedProteins\n    |\u003E Array.map (fun peptide -\u003E\n        // calculate mass for each peptide\n        BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n        )\n    // visualize distribution of all peptide masses \u003C 5000 Da\n    |\u003E Chart.Histogram\n    |\u003E Chart.withX_AxisStyle (title = \u0022Mass [Da]\u0022,MinMax=(0.,5000.))\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\n\n(***hide***)\nchartDigestedProteins |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n    \n(**\n## Calculating peptide masses for charge 2\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nHowever, in mass spectrometry we are only able to detect ions. Therefore, the measurements report the mass-to-charge ratio. \nThe abbreviation m/z (m = mass; z = charge) is used to denote the dimensionless quantity formed by dividing the molecular weight \nof an ion (M\u002BnH\u003Csup\u003E\u002B\u003C/sup\u003E) by its charge number (n).\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?M_{z}=\\frac{(M\u0026plus;nH^{\u0026plus;})}{n}\u0022 title=\u0022M_{z}=\\frac{(M\u002BnH^{\u002B})}{n}\u0022 Style=\u0022margin: 1rem auto 0; display: block\u0022 /\u003E\n\nIn the following, we will convert the uncharged peptide masses to the m/z ratio with charge two by applaying the Mass.toMZ \nfunction from the BioFSharp library and displax its distribution again. Note that m/z ratio with a charge of two represents \nthe predominant charge species.\n\n\u003C/div\u003E\n*)\n\nlet digestedPeptideMasses =\n    digestedProteins\n    |\u003E Array.map (fun peptide -\u003E\n            BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n        )\n\nlet chartDigestedPeptideMasses =\n    digestedPeptideMasses\n    |\u003E Array.map (fun ucMass -\u003E Mass.toMZ ucMass 2.) \n    |\u003E Chart.Histogram\n    |\u003E Chart.withX_AxisStyle (title = \u0022m/z\u0022,MinMax=(0.,5000.))\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\n\n(***hide***)\nchartDigestedPeptideMasses |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP03_Mass_spectrometry_based_proteomics.html\u0027;\u0022\u003E\u0026#171; JP03\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP05_Isotopic_distribution.html\u0027;\u0022\u003EJP05 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n(**\n## References\n\u003Ca href=\u0022#Digestion-and-mass-calculation\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Col\u003E\n\u003Cli Value=\u002223\u0022 Id=\u002223\u0022\u003E Burkhart, J. M., Schumbrutzki, C., Wortelkamp, S., Sickmann, A. \u0026 Zahedi, R. P. Systematic and quantitative comparison of digest efficiency and specificity reveals the impact of trypsin quality on MS-based proteomics. Journal of proteomics 75, 1454\u20131462; 10.1016/j.jprot.2011.11.016 (2012).\u003C/li\u003E\n\u003Cli Id=\u002224\u0022\u003E Switzar, L., Giera, M. \u0026 Niessen, W. M. A. Protein digestion: an overview of the available techniques and recent developments. J. Proteome Res. 12, 1067\u20131077; 10.1021/pr301201x (2013).\u003C/li\u003E\n\u003C/ol\u003E\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP01_FSharpExcercises.html","title":"JP01 FSharp Introduction Excercises\n","content":"(** \nThis notebook contains introductional excercises for the FSharp programming language and also some small code examples for correct formatting.\nIf you have questions at any point please ask us. We will discuss the first batch (task 1-6) before you can start the rest.\n\n# JP01 FSharp Introduction Excercises\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP01_FSharpExcercises.ipynb)\n\n\n1. [Code Examples](#Code-Examples)\n2. [Excercises](#Excercises)\n    * [Task 1](#Task-1)\n    * [Task 2](#Task-2)\n    * [Task 3](#Task-3)\n    * [Task 4](#Task-4)\n    * [Task 5](#Task-5)\n    * [Task 6](#Task-6)\n    * [Task 7](#Task-7)\n    * [Task 8](#Task-8)\n    * [Task 9](#Task-9)\n    * [Task 10](#Task-10)\n    * [Task 11](#Task-11)\n\n\u003Chr\u003E\n\n## Code Examples\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\nWe will beginn with some minor code examples to show you correct formatting. You can even use these examples to help you understand minor programming logics for your excercises below.\n\n*)\n\n// Define a function \u0027mulitplyBy2\u0027, which should double any input Float.\n\nlet mulitplyBy2 x = x * 2.\n\nmulitplyBy2 3.\n\n(*** include-it ***)\n\n(**\nIf a excercise asks you to bind something to a specific name, keep that name! It might be used later on!\nAlso remember to use camel case for names. This works by having a regular first letter and then have a capital letter at the start of each new word.\n\nexmp: \u003Ccode\u003EthisIsACamelCaseExample\u003C/code\u003E\n\n*)\n\n// Create a function \u0027calculateCylinderVolume\u0027, which should, with a given radius and lenght, \n// calculate and return the volume of a cylinder AND print \u0022The volume of the cylinder is: XX.\u0022 into the console. \u0027XX\u0027 is,\n// of course, the correct volume for the cylinder. (The output of a printfn function is Unit.)\n\nlet calculateCylinderVolume radius length : float =\n   // function body\n   let pi = 3.14159 //or System.Math.PI\n   let volume = length * pi * radius * radius\n   printfn \u0022Das Volumen des Zylinders ist: %f\u0022 volume\n   volume\n\ncalculateCylinderVolume 2. 10.\n   \n(*** include-it ***)\n(*** include-output ***)\n\n(**\n\n\u003Cul\u003E\n    \u003Cli\u003ETry to follow the excercise as close as possible, to not overlook something like \u0022.. calculate (..) the volume of a cylinder AND print ..\u0022 as these small differences migth be a valuable part of the excercise.\u003C/li\u003E\n    \u003Cli\u003ELines of code do not have any cost, don\u0027t be to stingy about them, e.g. have an extra line with a binding of \u003Ccode\u003Elet pi = 3.14159\u003C/code\u003E, so you can just use \u0022pi\u0022 instead of the number. \u003C/li\u003E\n    \u003Cli\u003EThis improves readability and keeps the function modular.\u003C/li\u003E\n    \u003Cli\u003EBy defining pi inside of the scope of \u003Ccode\u003EcalculateCylinderVolume\u003C/code\u003E it cannot be accessed from outside, keeping your overall code nice and clean.\u003C/li\u003E\n\u003C/ul\u003E\n\n*)\n\n// A chessboard is a 8x8 field. The rows and columns have the indices 0 - 7.\n// Create a function, which should return true if two queens can hit each other or false if they can\u0027t.\n// The functions parameters should be two Tuples (int*int).\n\nlet canHit (queen1 : int*int) (queen2 : int*int) =\n    let (posX1, posY1),(posX2, posY2)= (queen1,queen2)\n    if \n        // check if both queens are on the same x-axis\n        (posX1 = posX2) \n        // check if both queens are on the same y-axis\n        || (posY1 = posY2) \n        // check if both queens are on the same diagonal\n        || (abs (posX1 - posX2) = abs (posY1 - posY2))\n    then\n        printfn \u0022Both queens can hit each other\u0022\n        true\n    else \n        printfn \u0022Both queen cannot hit each other\u0022\n        false\n        \ncanHit (3,5) (5,7)\n\n(*** include-it ***)\n(*** include-output ***)\n\n(**\n\u003Chr\u003E\n \n## Excercises \n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n### Task 1\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n*)\n\n// Bind a String of your name (\u0022Name\u0022) to the name \u0027myFirstName\u0027.\n\n// Solution\n\nlet myFirstName = \u0022Kevin\u0022\n\nmyFirstName\n\n(*** include-it ***)\n\n(**\n### Task 2\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Define a variable \u0027myName\u0027, by adding \u0027myFirstName\u0027 to the rest of your name.\n\n// Solution\n\nlet myName = myFirstName \u002B \u0022 Frey\u0022\n\nmyName\n\n(*** include-it ***)\n\n(** \n### Task 3\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Define a variable \u0027summeXY\u0027 as the sum of any two Integer numbers. Do this, by defining x and y as separate \n// let - bindings inside the functional scope of the \u0027summeXY\u0027 function. \n// (The function MUST contain three let - bindings)\n\n// Solution\n\nlet summeXY =\n    let x = 2\n    let y = 34\n    x \u002B y\n\n\n(*** include-value:summeXY ***)\n\n(** \n### Task 4\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Declare a Tuple, consisting of 2 and \u0022February\u0022 and bind the Tuple to the name \u0027tuple1\u0027\n\n// Solution \n\nlet tuple1 = (2,\u0022February\u0022)\n\n(*** include-value:tuple1 ***)\n\n(**\n### Task 5\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Declare a Tuple, consisting of 2, \u0022February\u0022 and \u0022spring\u0022 and bind the Tuple to the name \u0027tuple2\u0027\n\n// Solution \n\nlet tuple2 = (2,\u0022February\u0022,\u0022spring\u0022)\n\n(*** include-value:tuple2 ***)\n\n(**\n### Task 6 \n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Access the second variable of the Tuple \u0027tuple1\u0027.\n// Access the second variable of the Tuple \u0027tuple2\u0027.\n\n// Solution \n\nlet solution1 = snd tuple1\n\nlet solution2 = (fun (x,y,z) -\u003E y) tuple2 // or: let (x,y,z) = tuple2\n\n(*** include-value:solution1 ***)\n(*** include-value:solution2 ***)\n\n(** \n### Task 7\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Create a Record Type with the name \u0027Month\u0027. \u0027Month\u0027 should contain the fields \u0027Number\u0027 (int),\n// \u0027Name\u0027 (string) and \u0027Season\u0027 (string).\n\n// Solution\n\ntype Month =\n    {\n        Number: int\n        Name:   string\n        Season: string\n    }\n    \n(** \n### Task 8\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Declare a function \u0027createMonth\u0027 with three input parameters and which should return a \u0027Month\u0027 - Record Type.\n// Use the values from \u0027tuple2\u0027 and create a month with these as input.  \n\n// Solution\n\nlet createMonth number name season =\n    {\n        Number = number\n        Name   = name\n        Season = season\n    }\n    \nlet feb = createMonth 2 \u0022February\u0022 \u0022spring\u0022\nfeb\n\n(*** include-value:feb ***)\n\n(** \n### Task 9\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Create a function called \u0027myMonthsPrinter\u0027 which should take a \u0027Month\u0027 as input and return a unit output \n// (printfn - command) in the form of \u0022My favorite month is [Month Name]. It is the [Number of Month] month\n// in the year and i especially like this time because it is part of [Season].\u0022\n\n// Solution\n\nlet myMonthsPrinter (month:Month) =\n    printfn \u0022\n        My favorite month is %s. It is the %i month in the year \n        and i especially like this time because it is part of %s.\u0022\n        month.Name\n        month.Number\n        month.Season\n        \nmyMonthsPrinter feb\n\n(*** include-output ***)\n\n(** \n### Task 10\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// We want to put additional emphasis on readability of code ...\n\n// Oh no, the following function is not readable. Write the function new and use pipe operators!\n\nlet unreadableFunc x = (string ((x - 7) * 2) \u002B \u0022Generic\u0022).ToUpper().ToCharArray()\n\n// Solution\n\nlet readableFunc (x:int) = \n    x\n    |\u003E fun x -\u003E x - 7\n    |\u003E fun x -\u003E x * 2\n    |\u003E string\n    |\u003E fun x -\u003E x \u002B \u0022Generic\u0022\n    |\u003E fun x -\u003E x.ToUpper().ToCharArray()\n    \nreadableFunc 4 = unreadableFunc 4\n\n(*** include-it ***)\n\n(** \n### Task 11\n\u003Ca href=\u0022#FSharp-Introduction-Excercises\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n*)\n\n// Create a function \u0027replaceSmallNumbers\u0027, which should replace all \n// integers in a list with a 0 if the integer is smaller than 5.\n\nlet numList = [0 .. 20]\n\n// Solution\n\nlet replaceSmallNumbers (numList:int list) =\n    numList\n    |\u003E List.map (\n        fun x -\u003E\n            if x \u003C 5 then\n                0\n            else x\n        )\n    \nreplaceSmallNumbers numList\n\n(*** include-it ***)\n(**\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP00_Systems_Biology_FSharp_Introduction.html\u0027;\u0022\u003E\u0026#171; JP00\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP02_Plant_Systems_Biology.html\u0027;\u0022\u003EJP02 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP07_Signal_detection_and_quantification.html","title":"JP07 Signal detection and quantification\n","content":"(**\n# JP07 Signal detection and quantification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP07_Signal_detection_and_quantification.ipynb)\n\n1. [Signal detection and quantification](#Signal-detection-and-quantification)\n*)\n\n(**\n## Signal detection and quantification\n\u003Ca href=\u0022#Signal-detection-and-quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nSignals detected during a LC-MS measurement are pairs of m/z value and ion intensity in time. All signals recorded at a particular retention \ntime in a given mass range compose a spectrum. Thus, in its most raw form, a generic spectrum contains the following information: (i) scan \n(spectra) number; (ii) retention time; (iii) vector of m/z values; (iv) vector of ion intensities; (v) scan mode. The scan number is a simple \nenumeration over the measurements. The retention time is the time when the measured peptides were eluting from the column. The m/z values \nrepresent the mass over charge values of the ions and ion intensity values are the corresponding ion abundances. The scan mode denotes the \noperational mode used to record the spectrum. It is either a full scan or the number of the fragmentation scan.\n\n\u003Cdiv Id=\u0022figure3\u0022 Style=\u0022margin-left: auto ; margin-right: auto ; color: #44546a ; width: 80% ; padding: 15px\u0022\u003E\n    \u003Cimg src=\u0022img/MSDerivedDataSpaces.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; text-align: justify ; margin-top: 1rem; font-size: 0.8rem \u0022\u003E\n        \u003Cb\u003EFigure 3: A conceptual view of different spaces of MS derived data sets.\u003C/b\u003E\n        (i) The metadata-space serves as a descriptive layer to order, assign and integrate spectra information. (ii) \n        The MS1-space and the (iii) MS2-space represent two independent entities that differ in signal shape, resolution and their \n        information content (\u2018features\u2019).\n    \u003C/div\u003E\n\u003C/div\u003E    \n\u003C/div\u003E\n*)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP06_Retention_time_and_scan_time.html\u0027;\u0022\u003E\u0026#171; JP06\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP08_Centroidisation.html\u0027;\u0022\u003EJP08 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP02_Plant_Systems_Biology.html","title":"JP02 Plant Systems Biology\n","content":"(** \n# JP02 Plant Systems Biology\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP02_Plant_Systems_Biology.ipynb)\n\n\n1. [Plant Systems Biology](#Plant-Systems-Biology)\n2. [Modeling growth for a defined cell number](#Modeling-growth-for-a-defined-cell-number)\n1. [Insert Growth Data and Display as Chart](#Insert-Growth-Data-and-Display-as-Chart)\n2. [Calculation of growth rate and doubling time for cell cultures](#Calculation-of-growth-rate-and-doubling-time-for-cell-cultures)\n3. [Fitting biological growth curves](#Fitting-biological-growth-curves)\u003Cbr\u003E\n    1. [Theory](#Theory)\u003Cbr\u003E\n    2. [Model selection](#Model-selection)\u003Cbr\u003E\n    3. [Exponential Fit](#Exponential-Fit)\u003Cbr\u003E\n4. [Calculate Doubling Time](#Calculate-Doubling-Time)\n5. [References](#References)\n*)\n\n(** \n## Plant Systems Biology\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nThe general paradigm of Systems Biology clearly applies to plants, as they represent complex biological systems. \nThe functioning of a plant as a biological system is the result of a combination of multiple intertwined and dynamic interactions between its components. \nIn addition, most plants are sessile systems that have to face fluctuating environmental conditions, including biotic and abiotic stresses\u003Csup\u003E\u003Ca href=\u0022#8\u0022\u003E8\u003C/a\u003E\u003C/sup\u003E.\nThe process of a biological system responding to changes in environmental conditions is termed acclimation. These molecular physiological responses represent a complex \ndynamic adjustment of the interplay between genes, proteins and metabolites that allows the organism to acclimate to the changing environment. \nThe ability to acclimate ensures the survival of all living organisms and is therefore fundamental for the understanding of biological systems. \nDetailed knowledge about how plants acclimate to a changing environment is crucial especially in times of global climate changes, \nas plants are of great importance for our quality of life as a key source of food, shelter, fiber, medicine, and fuel\u003Csup\u003E\u003Ca href=\u0022#9\u0022\u003E9\u003C/a\u003E\u003C/sup\u003E.\n\nThe prominent model plant \u003Ci\u003EArabidopsis thaliana\u003C/i\u003E is well suited for plant Systems Biology studies because sophisticated experimental tools and extensive data \ncollections are readily available\u003Csup\u003E\u003Ca href=\u0022#10\u0022\u003E10\u003C/a\u003E\u003C/sup\u003E. However, the importance of a model organism is not only coined by the availability of molecular \ntools to manipulate the organism, but also by its agricultural and economic impact like in the cases of tobacco, rice, maize or \nbarley\u003Csup\u003E\u003Ca href=\u0022#11\u0022\u003E11\u003C/a\u003E\u003C/sup\u003E. Also microalgae are of special economic interest due to their potential as biofuel producers\u003Csup\u003E\u003Ca href=\u0022#12\u0022\u003E12\u003C/a\u003E\u003C/sup\u003E. \nAdditionally, the use of organisms with lower biological complexity facilitates the feasibility of System Biology studies and is an important factor to consider \nfor the choice of a suitable model organism in Systems Biology.\n\nThe eukaryotic green alga \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E is particularly well suited for plant Systems Biology approaches. \nThis unicellular freshwater and soil-dwelling alga has a single, cup-shaped chloroplast with a photosynthetic apparatus that is similar to \nthat of higher plants\u003Csup\u003E\u003Ca href=\u0022#13\u0022\u003E13\u003C/a\u003E,\u003Ca href=\u0022#14\u0022\u003E14\u003C/a\u003E\u003C/sup\u003E. Hence, results gained on photosynthesis processes in \u003Ci\u003EChlamydomonas\u003C/i\u003E \nare likely to be transferable to higher plants. The nuclear, mitochondrial, and chloroplast genomes have been sequenced and tools for manipulating them \nare available\u003Csup\u003E\u003Ca href=\u0022#14\u0022\u003E14\u003C/a\u003E\u003C/sup\u003E. \u003Ci\u003EChlamydomonas\u003C/i\u003E cells have a size of ~10 \u00B5m and grow under photo-, mixo-, and heterotrophic conditions \nwith a generation time of ~5-8 h\u003Csup\u003E\u003Ca href=\u0022#15\u0022\u003E15\u003C/a\u003E\u003C/sup\u003E. \u003Ci\u003EChlamydomonas\u003C/i\u003E can be maintained under controlled conditions and environmental \nchanges can be applied homogeneously and rapidly to all cells in a liquid culture. In contrast to multicellular organisms there are no influences by \ntissue heterogeneity. Even the influence of different cell cycle stages may be ruled out by performing experiments with asynchronous cell cultures \n\u003Csup\u003E\u003Ca href=\u0022#16\u0022\u003E16\u003C/a\u003E,\u003Ca href=\u0022#17\u0022\u003E17\u003C/a\u003E\u003C/sup\u003E. Finally, gene families in Chlamydomonas have fewer members than those in higher plants thus facilitating the \ninterpretation of results involving many genes/proteins\u003Csup\u003E\u003Ca href=\u0022#14\u0022\u003E14\u003C/a\u003E\u003C/sup\u003E.\n\u003C/div\u003E\n*)\n\n(** \n## Modeling growth for a defined cell number\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nIn order to solves real world task more convenient, F# provides a huge collection of additional programming libraries. \nAnything that extends beyond the basics must be written by a user. If the chunk of code is useful to multiple different users, \nit\u0027s often put into a library to make it easily reusable. A library is a collection of related pieces of code that have been compiled \nand stored together in a single file and can than be used an included. The most important libraries in F# for bioinformatics are:\n\n\u003Cul\u003E\n    \u003Cli\u003E\u003Ca href=\u0022https://csbiology.github.io/BioFSharp/\u0022\u003EBioFSharp\u003C/a\u003E: Open source bioinformatics and computational biology toolbox written in F#\u003C/li\u003E\n    \u003Cli\u003E\u003Ca href=\u0022https://csbiology.github.io/FSharp.Stats/\u0022\u003EFSharp.Stats\u003C/a\u003E: F# project for statistical computing \u003C/li\u003E\n    \u003Cli\u003E\u003Ca href=\u0022https://github.com/plotly/Plotly.NET\u0022\u003EPlotly.NET\u003C/a\u003E: .NET interface for plotly.js written in F# \uD83D\uDCC8 \u003C/li\u003E\n\u003C/ul\u003E\n\nThe first real world use case of F# in Systems Biology is to model growth for a defined cell number to see possible overexpression effects. \nBiologists often utilize growth experiments to analyze basic properties of a given organism or cellular model. For a solid comparison of data \nobtain from different experiment and to investigate the speci\uFB01c e\uFB00ect of a given experimental set up, modeling the growth is needed after recording the data. \n\nThis notebook introduces two basic ways to model growth of \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E using F#.\n\nNow, let\u0027s get started by loading our libraries first.\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen FSharp.Stats\nopen FSharp.Stats.Fitting.NonLinearRegression\n\n(** \n## Insert Growth Data and Display as Chart\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\nA normal cell culture experiment with measurements for the growth curve will return data like the following.\nMultiple cell counts (y_Count) each related to a specific timepoint (x_Hours).\n*)\n// Code-Block 1\n\nlet exmp_x_Hours = [|0.; 19.5; 25.5; 43.; 48.5; 51.25; 67.75|]\nlet exmp_y_Count = [|1659000.; 4169000.; 6585400.; 16608400.; 17257800.; nan; 18041000.|]\n\n/// filter out any nans. These could be introduced through missing measurements.\nlet exmp_x_Hours_Filtered,exmp_y_Count_Filtered =\n    Array.zip exmp_x_Hours exmp_y_Count\n    |\u003E Array.filter (fun (x,y) -\u003E isNan y = false \u0026\u0026 isNan x = false )\n    |\u003E Array.unzip\n\n// Such data can easily be display with the following code block.\n// Chart.Point takes a sequence of x-axis-points and a series of y-axis-points as input\nlet example_Chart_1 = \n    Chart.Point(exmp_x_Hours_Filtered,exmp_y_Count_Filtered)\n    // some minor styling with title and axis-titles.\n    |\u003E Chart.withTitle \u0022Growth curve of \u003Ci\u003EClamydomonas reinhardtii\u003C/i\u003E cell cultures\u0022\n    |\u003E Chart.withX_AxisStyle (\u0022Number of cells\u0022)\n    |\u003E Chart.withY_AxisStyle (\u0022Time [hours]\u0022)\n\n(***hide***)\nexample_Chart_1 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Calculation of growth rate and doubling time for cell cultures\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nThe normal growth of an in vitro cell culture is defined through three phases. The lag phase in which the cells still acclimate to the growth conditions, the exponential growth, also called log phase, during which cell growth is exponential due to the proliferation of cells into two daughter cells, and the stationary phase in which the growth rate and the death rate are equal. The stationary phase is typically initiated due to limitations in growth conditions, e.g. depletion of essential nutrients or accumulation of toxic/inhibitory excretions/products. The doubling time defines a time interval in which the quantity of cells doubles and is calculated as seen in Equation 1.\n\n\u003Ci\u003EEquation 1: Calculation of the doubling time. Growth rate is calculates as shown in Equation 2.\u003C/i\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?doubling\u0026space;Time\u0026space;=\u0026space;\\frac{ln(2)}{growthRate}\u0022 title=\u0022doubling Time = \\frac{ln(2)}{growthRate}\u0022 style=\u0022margin: 1rem auto 0; display: block\u0022/\u003E\n\u003C/div\u003E\n\nGrowth rate can then be calculated as shown in Equation 2.\n\n\u003Ci\u003EEquation 2: Calculation of the growth rate. With N(t) = the number of cells at time t, N(0) = number of cells at time 0, gr = growth rate, and t = time.\u003C/i\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?gr=\\frac{ln(\\frac{N(t)}{N(0)})}{t}\u0022 title=\u0022gr=\\frac{ln(\\frac{N(t)}{N(0)})}{t}\u0022 style=\u0022margin: 1rem auto 0; display: block\u0022/\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Chr\u003E\n*)\n\n(** \n## Fitting biological growth curves\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\n### Theory\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTo derive parameters required for e.g. the doubling time calculation, the measured growth data points have to be modelled. \nIn order to obtain a continuous function with known coefficients, a suitable model function is fitted onto the existing data. \nMany models exist, each one of them optimized for a specific task\u003Csup\u003E\u003Ca href=\u0022#18\u0022\u003E18\u003C/a\u003E\u003C/sup\u003E.\n\nLinear model function example: \u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?f(x)\u0026space;=\u0026space;mx\u0026space;\u0026plus;\u0026space;b\u0022 title=\u0022f(x) = mx \u002B b\u0022 /\u003E\n \nWhen a model is fitted onto the data, there are endless possibilities to choose coefficients of the model function. \nIn the case above there are two coefficients to be identified: The slope m and the y-intercept b. But how can the best fitting coefficients be determined?\n\nTherefore a quality measure called \u003Cb\u003EResidual Sum of Squares (RSS)\u003C/b\u003E is used. It describes the discrepancy of the measured points \nand the corresponding estimation model. If the discrepancy is small, the RSS is small too.\n\nIn regression analysis the optimal set of coefficients (m and b) that \u003Ca href= \u0022https://mathworld.wolfram.com/LeastSquaresFitting.html\u0022\u003E minimizes the RSS is searched\u003C/a\u003E.\n\nIf there is no straightforward way to identify the RSS-minimizing coefficient set, then the problem is part of nonlinear regression. \nHere, initial coefficients are guessed and the RSS is calculated. Thereafter, the coefficients are modified in tiny steps. \nIf the RSS decreases, the direction of the coefficient change seems to be correct. \nBy \u003Ca href= \u0022https://books.google.de/books?id=rs51DwAAQBAJ\u0026pg=PA422\u0026lpg=PA422\u0026dq=rss\u002Bminimizing\u002Bsolver\u0026source=bl\u0026ots=qZ0Y4cYtM-\u0026sig=ACfU3U0rHGWCmTo_kv5wqYMmSo8ZKyj5Pg\u0026hl=de\u0026sa=X\u0026ved=2ahUKEwjKtdf-oaHoAhUUwsQBHX07DTwQ6AEwBHoECAkQAQ#v=onepage\u0026q=rss%20minimizing%20solver\u0026f=false\u0022\u003E \niteratively changing coefficients\u003C/a\u003E, the optimal coefficient set is determined when no further change leads to an decrease in RSS. \nAlgorithms, that perform such a \u0027gradient descent\u0027 methods to solve nonlinear regression tasks are called \u003Cb\u003Esolver\u003C/b\u003E \n(e.g. Gauss-Newton algorithm or Levenberg\u2013Marquardt algorithm). \u003Ca href= \u0022https://www.youtube.com/watch?v=sDv4f4s2SB8\u0022\u003E Introduction to RSS and optimization problems. \u003C/a\u003E\n\u003C/div\u003E\n\n### Model selection\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n     \n\u003Cdiv class=\u0022container\u0022\u003E\nUnder certain circumstances, more than one solution may arise out of a optimization process. \nIf the solutions are based on the same data and the same fitting model, the function minimizing the RSS can be selected as best estimator. \n\u003C/div\u003E\n\n### Exponential Fit\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nSince cellular growth behaves in an exponential manner, it seems to make sense to use an exponential fitting function. \n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?f(x)\u0026space;=\u0026space;ae^{bx}\u0022 title=\u0022f(x) = ae^{bx}\u0022 /\u003E\n\nAs seen below, the resulting \u003Ca href=\u0022https://da.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth\u0022\u003E exponential fit\u003C/a\u003E does not represent the data sufficiently, even though it is the best fit, that a exponential model can provide. This is caused by the lag- and stationary phase, both not following an exponential increase. \nIn order to use an exponential function as model, it would be necessary to discard data points from lag- and stationary phases and model the remaining data points. \n\n \nThere are two main problems regarding this workflow: \n\u003Col\u003E\n    \u003Cli value=\u0022(1)\u0022\u003E The assignment of points to lag-, log-, and stationary phases is a nontrivial task.\u003C/li\u003E\n    \u003Cli value=\u0022(2)\u0022\u003E The exponential phase only lasts a short period of time and therefore the number of points that can be assigned to the log phase is (very) low.\u003C/li\u003E \n\u003C/ol\u003E\nConsequential the fitted function is not robust against variance introduced during cell count measurements.\n\n\u003C/div\u003E\n\n*)\n\n// Code-Block 2\n\n// An template exponential function has the form f(x) = a * exp(b * x) with the two unknowns a and b. \n\n// The model we need already exists in FSharp.Stats and can be taken from the \u0022Table\u0022 module.\nlet expModel = Table.expModel\n\n// the solver needs additional information like the initial coefficient guesses or the coefficient accuracy\n// FSharp.Stats assists by estimating the required parameters based on the original input data\nlet solverOptions = Table.expSolverOptions exmp_x_Hours_Filtered exmp_y_Count_Filtered\n\n// The Gauss-Newton solver is used to find the optimal coefficients for an exponential function (expModel)\n// The result is a vector, containing parameter a and b as floats.\nlet coefficientsExp = GaussNewton.estimatedParams expModel solverOptions exmp_x_Hours_Filtered exmp_y_Count_Filtered\n\n// The determined coefficients can be inserted into the exponential template function\nlet fittingExpFunction x = coefficientsExp.[0] * System.Math.Exp(coefficientsExp.[1] * x)\n\n// create a chart with \nlet exp_Chart_1 = \n    [|0. .. (Array.last exmp_x_Hours_Filtered)|]\n    |\u003E Array.map (fun xValue -\u003E xValue,fittingExpFunction xValue) // gives tuples of (xValue,yValue)\n    |\u003E Chart.Line\n    |\u003E Chart.withTraceName \u0022exponential fit\u0022\n\n// styling of the chart axis\nlet templateAxis title = Axis.LinearAxis.init(Title=title,Showgrid=false,Showline=true,Mirror=StyleParam.Mirror.All)       \n\nlet exponentialFitChart =\n    [\n        example_Chart_1\n        |\u003E Chart.withTraceName \u0022data points\u0022\n        exp_Chart_1\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_Axis (templateAxis \u0022time [hours]\u0022)\n    |\u003E Chart.withY_Axis (templateAxis \u0022number of cells\u0022)\n    |\u003E Chart.withSize (900.,600.)\n\n(***hide***)\nexponentialFitChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n    \n(**\n## Logistic regression fit\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nAs seen above, the model selection is a crucial step for obtaining reasonable functions and to derive function properties with \nwhich further studies are examined. The selected model should match the theoretical (time) course of the studied signal, but under \nconsideration of Occams razor principle. It states, that a approriate model with a low number of coefficients should be preferred over a \nmodel with many coefficients, since the excessive use of coefficients leads to overfitting.\n\nA better model that can be used in growth curve fitting, is a \u003Ca href= \u0022https://en.wikipedia.org/wiki/Logistic_function\u0022\u003Elogistic function\u003C/a\u003E. \nIt is defined by a minimum, a maximum, and a sigmoidal transition between those two. Thereby, the lag, log, and stationary phase are covered.\n\nThe function has the form: \u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?f(x)=\\frac{L}{1\u0026plus;e^{-k(x-x_{0})}}\u0026plus;N\u0022 title=\u0022f(x)=\\frac{L}{1\u002Be^{-k(x-x_{0})}}\u002BN\u0022 /\u003E\n\nwhere:\n        \n__L__ = curve maximum\n\n__k__ = steepness\n\n__x0__ = xValue of sigmoid\u0027s midpoint\n\n__N__ = curve minimum\n\nIn the following, we will go through the necessary steps to calculate the doubling time with the help of a logistic fit. \nThis is more complex than the exponential fit, but the given problem requires a more sophisticated method.\n\u003C/div\u003E\n*)\n\n// Code-Block 3\n\n// The model we need already exists in FSharp.Stats and can be taken from the \u0022Table\u0022 module.\nlet modelLogistic = Table.LogisticFunctionVarYAscending\n\n// To fit the logistic function, the solver requires more parameters. Some of them are stored in the solverOption type\nlet lineSolverOptions initialParamGuess = {\n    // defines the stepwidth of the x_value change\n    MinimumDeltaValue       = 0.00001\n    // defines the stepwidth of the parameter change\n    MinimumDeltaParameters  = 0.00001\n    // defines the number of iterations until the solver converges to a solution\n    MaximumIterations       = 10000\n    // initial parameters to start the solving algorithms\n    // vector containing all coefficients of the function: vector [L;k;x0;N]\n    InitialParamGuess       = initialParamGuess\n    }\n\n// Generation of solverOptions with varying steepnesses\nlet initialGuess = \n    // maximum measured intensity/cell count\n    let l  = exmp_y_Count_Filtered |\u003E Array.max\n    // estimate of the xValue of sigmoid\u0027s midpoint\n    let x0 = (exmp_x_Hours_Filtered |\u003E Array.max) / 2.\n    // minimum measured intensity/cell count.\n    let n  = exmp_y_Count_Filtered |\u003E Array.min \n    \n    //since steepness in unknown, a variety of steepnesses is provided \n    let steepnessRange = [|0.01 .. 0.01 .. 1.|]\n    \n    steepnessRange\n    |\u003E Array.map (fun steepness -\u003E lineSolverOptions [|l; steepness; x0; n|])\n\n// Estimate coefficients for a possible solution based on residual sum \n// of squares. Besides the solverOptions, an upper and lower bound for \n// the parameters are required. It is recommended to define them depending \n// on the initial param guess.\n// It reports coefficients tupled with a corresponding RSS value.\nlet estimateCoefficientsRSS =\n    initialGuess\n    |\u003E Array.map (fun solvOpt -\u003E\n        let lowerBound =\n            solvOpt.InitialParamGuess\n            |\u003E Array.map (fun param -\u003E param - (abs param) * 0.2)\n            |\u003E vector\n        let upperBound =\n            solvOpt.InitialParamGuess\n            |\u003E Array.map (fun param -\u003E param \u002B (abs param) * 0.2)\n            |\u003E vector\n        // all parameters are given to the solver and the set of coefficients that minimize the RSS are reported\n        LevenbergMarquardtConstrained.estimatedParamsWithRSS \n            modelLogistic         // logistic function model\n            solvOpt               // solver options with optimization parameters and initial guess\n            0.001                 //\n            10.                   //\n            lowerBound            // lower bound of coefficient space\n            upperBound            // upper bound of coefficient space\n            exmp_x_Hours_Filtered // x data\n            exmp_y_Count_Filtered // y data\n    )\n    |\u003E Array.filter (fun (coeffs,rss) -\u003E not(coeffs |\u003E Vector.exists System.Double.IsNaN)) // discard solutions with nan as coefficients\n    |\u003E Array.minBy snd // minimize all possible solutions based on RSS quality measure\n    |\u003E fun (solCoeffs,rss) -\u003E\n        printfn \u0022Chosen Estimate: %A\u0022 solCoeffs\n        printfn \u0022Equation: (%.1f / (1. \u002B exp(-%.3f * (x - %.3f)))) \u002B %.1f\u0022 solCoeffs.[0] solCoeffs.[1] solCoeffs.[2] solCoeffs.[3]\n        solCoeffs\n        \n// Create fitting function from optimal coefficients\nlet fittingLogisticFunction = modelLogistic.GetFunctionValue estimateCoefficientsRSS\n\n// Code-Block 4\n\n// fit of the optimized logistic function over all x Values\nlet fittedY = \n     [|0. .. exmp_x_Hours |\u003E Array.max|]\n     |\u003E Array.map (fun x -\u003E x, fittingLogisticFunction x) //tupled (xValue,yValue)\n\nlet fittedLogisticFunc =\n    [\n        // raw chart\n        Chart.Point (exmp_x_Hours, exmp_y_Count) |\u003E Chart.withTraceName\u0022data points\u0022\n        // logistic fit\n        Chart.Line fittedY                       |\u003E Chart.withTraceName \u0022logistic fit\u0022\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withY_Axis (templateAxis \u0022cell count\u0022)\n    |\u003E Chart.withX_Axis (templateAxis \u0022time [Hours]\u0022)\n\n(***hide***)\nfittedLogisticFunc |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n    \n## Calculate Doubling Time\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTo calculate the doubling time it is necessary to determine the growth rate (gr) for \u003Ci\u003Eequation 1\u003C/i\u003E.\nTo get gr we make use of the first and second derivative of the logistic function. They can be calculated by hand or with help \nof \u003Ca href=\u0022https://www.ableitungsrechner.net/\u0022\u003Ederivative calculator\u003C/a\u003E.\n\nThe first derivative of the logistic function is: \n\n\u003Cdiv class=\u0022container\u0022\u003E\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?\\dfrac{kl\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u0026plus;1\\right)^2}\u0022 title=\u0022\\dfrac{kl\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u002B1\\right)^2}\u0022 style=\u0022margin: 1rem auto 0; display: block\u0022 /\u003E\n\u003C/div\u003E\n\nThe second derivative of the logistic function is: \n\n\u003Cdiv class=\u0022container\u0022\u003E\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?-\\dfrac{k^2l\\left(\\mathrm{e}^{k\\left(x-m\\right)}-1\\right)\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u0026plus;1\\right)^3}\u0022 title=\u0022-\\dfrac{k^2l\\left(\\mathrm{e}^{k\\left(x-m\\right)}-1\\right)\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u002B1\\right)^3}\u0022 style=\u0022margin: 1rem auto 0; display: block\u0022 /\u003E\n\u003C/div\u003E\n\n\u003C/div\u003E\n*)\n\n// Code-Block 5\n\n// calculate fst derivative of logistic function\nlet fstDerivative x = \n    let l  = estimateCoefficientsRSS.[0]\n    let k  = estimateCoefficientsRSS.[1]\n    let x0 = estimateCoefficientsRSS.[2]\n    let n  = estimateCoefficientsRSS.[3]\n    let exp = System.Math.Exp(k*(x-x0))\n    - (k**2.*l*(exp - 1.)* exp ) / (exp \u002B 1.)**3.\n\n// calculate snd derivative of logistic function \nlet sndDerivative x = \n    let l  = estimateCoefficientsRSS.[0]\n    let k  = estimateCoefficientsRSS.[1]\n    let x0 = estimateCoefficientsRSS.[2]\n    let n  = estimateCoefficientsRSS.[3]\n    let exp = System.Math.Exp(k*(x-x0))\n    (k*l*exp) / (exp \u002B 1.)**2.\n\n// calculate derivatives to corresponding x values\nlet yValuesOfDerivative fkt = \n    [|0. .. 0.5 .. exmp_x_Hours |\u003E Array.max|]\n    |\u003E Array.map (fun x -\u003E x,fkt x)\n    \nlet fitAllLogisticFunc =\n    [\n        Chart.Line (yValuesOfDerivative fstDerivative)|\u003E Chart.withTraceName \u0022fst derivative\u0022\n        Chart.Line (yValuesOfDerivative sndDerivative)|\u003E Chart.withTraceName \u0022snd derivative\u0022\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withY_Axis (templateAxis \u0022slope or curvature\u0022)\n    |\u003E Chart.withX_Axis (templateAxis \u0022time [hours]\u0022)\n\n(***hide***)\nfitAllLogisticFunc |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\nWe define the region between the maximal and minimal curvature (second derivative) as the time period to derive the growth rate from. \nAn alternative is to just use the slope at the midpoint because this is the point of maximal slope (minimal generation time), but since \nthis calculation would be only dependent from this particular point we go for the more conservative approach.\n    \nWhen the xValues of the maximal curvatures are identified (either by calculus or by plotting the derivatives) the generation time calculation\n is straight forward (\u003Ca href=\u0022https://en.wikipedia.org/wiki/Doubling_time\u0022\u003EWikipedia - Doubling time\u003C/a\u003E).\n\u003C/div\u003E\n*)\n\n// Code-Block 6\n\n// The exponential phase is considered to be between the maximal positive curvature\n// and the minimal negative curvature of the fitting functions (other interpretations possible).\nlet xValuesOfMaximalCurvature = [| 23.5 ; 44.0 |]\n\nlet calculateDoublingTimeLogistic fittingFunction =\n\n    //https://en.wikipedia.org/wiki/Doubling_time\n    // -\u003E Cell culture doubling time\n    let growthRate nCells0 nCellsT t =\n        log(nCellsT/nCells0)\n        |\u003E fun x -\u003E x/t\n\n    let doublingTime growthRate =\n        (log(2.))/growthRate\n\n    /// get the corresponding cell counts around the midpoint of the logistic function\n    let rootsYY = xValuesOfMaximalCurvature |\u003E Array.map fittingFunction\n    \n    /// calculate the time difference between both roots\n    let diff = xValuesOfMaximalCurvature.[1] - xValuesOfMaximalCurvature.[0]\n    \n    /// get the minimum measured cell count and the maximum measured cell count\n    let min,max = rootsYY.[0], rootsYY.[1]\n\n    let doublingTime =\n        growthRate min max diff\n        |\u003E doublingTime\n\n    doublingTime\n    \nlet doublingTime = \n    calculateDoublingTimeLogistic fittingLogisticFunction\n    \nsprintf \u0022The doubling time is %.2f hours.\u0022 doublingTime\n\n(*** include-it ***)\n\n(**\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP01_FSharpExcercises.html\u0027;\u0022\u003E\u0026#171; JP01\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP03_Mass_spectrometry_based_proteomics.html\u0027;\u0022\u003EJP03 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n\n(**\n## References\n\u003Ca href=\u0022#Plant-Systems-Biology\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cbr\u003E\n\n\u003Col\u003E\n\u003Cli Value=\u00228\u0022 Id=\u00228\u0022\u003ERuffel, S., Krouk, G. \u0026 Coruzzi, G. M. A systems view of responses to nutritional cues in Arabidopsis: toward a paradigm shift for predictive network modeling. Plant physiology 152, 445\u2013452; 10.1104/pp.109.148502 (2010).\u003C/li\u003E\n\u003Cli Id=\u00229\u0022\u003E Minorsky, P. V. Achieving the in Silico Plant. Systems Biology and the Future of Plant Biological Research. Plant physiology 132, 404\u2013409; 10.1104/pp.900076 (2003). \u003Cdiv\u003E\n\u003Cli Id=\u002210\u0022\u003EVan Norman, Jaimie M \u0026 Benfey, P. N. Arabidopsis thaliana as a model organism in systems biology. Wiley interdisciplinary reviews. Systems biology and medicine 1, 372\u2013379; 10.1002/wsbm.25 (2009).\u003C/li\u003E\n\u003Cli Id=\u002211\u0022\u003EP\u00E3curar, D. I. Model organisms - a journey from the dawn of biological research to the post-genomic era. Romanian Society of Biological Sciences, 4087\u20134094 (2009).\u003C/li\u003E\n\u003Cli Id=\u002212\u0022\u003ECagnon, C. et al. Development of a forward genetic screen to isolate oil mutants in the green microalga Chlamydomonas reinhardtii. Biotechnology for biofuels 6, 178; 10.1186/1754-6834-6-178 (2013).\u003C/li\u003E\n\u003Cli Id=\u002213\u0022\u003EEberhard, S., Finazzi, G. \u0026 Wollman, F.-A. The dynamics of photosynthesis. Annual review of genetics 42, 463\u2013515; 10.1146/annurev.genet.42.110807.091452 (2008).\u003C/li\u003E\n\u003Cli Id=\u002214\u0022\u003EMerchant, S. S. et al. The Chlamydomonas genome reveals the evolution of key animal and plant functions. Science (New York, N.Y.) 318, 245\u2013250; 10.1126/science.1143609 (2007).\u003C/li\u003E\n\u003Cli Id=\u002215\u0022\u003EHarris, E. H. The chlamydomonas sourcebook. 2nd ed. (Academic, London, 2008).\u003C/li\u003E\n\u003Cli Id=\u002216\u0022\u003EBruggeman, F. J. \u0026 Westerhoff, H. V. The nature of systems biology. Trends in microbiology 15, 45\u201350; 10.1016/j.tim.2006.11.003 (2007).\u003C/li\u003E\n\u003Cli Id=\u002217\u0022\u003EHarris, E. H. CHLAMYDOMONAS AS A MODEL ORGANISM. Annual review of plant physiology and plant molecular biology 52, 363\u2013406; 10.1146/annurev.arplant.52.1.363 (2001).\u003C/li\u003E\n\u003Cli Id=\u002218\u0022\u003EKaplan, S. et al. Comparison of growth curves using non-linear regression function in Japanese squail. Journal of Applied Animal Research 46, 112-117; 10.1080/09712119.2016.1268965 (2018).\u003C/li\u003E.\n\u003C/ol\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP03_Mass_spectrometry_based_proteomics.html","title":"JP03 Mass Spectrometry Based Proteomics\n","content":"(** \n\n# JP03 Mass Spectrometry Based Proteomics\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP03_Mass_spectrometry_based_proteomics.ipynb)\n\n1. [Mass spectrometry (MS)-based proteomic](#Mass-spectrometry-(MS)-based-proteomic)\n6. [References](#References)\n*)\n(**\n## Mass spectrometry (MS)-based proteomic\n\u003Ca href=\u0022#Mass-Spectrometry-Based-Proteomics\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\n\n\u003Cdiv Id= \u0022figure2\u0022 Style=\u0022float: right; display: inline-block; color: #44546a; width: 60%; padding: 15px; max-width: 600px\u0022\u003E\n    \u003Cimg src=\u0022img/OmicsWorkflow.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem; padding-right: 1rem; text-align: justify; font-size:0.8rem\u0022\u003E\n        \u003Cb\u003EFigure 2. Summary of a typical proteomics workflow following the bottom-up principle.\u003C/b\u003E During sample preparation proteins are extracted from the samples and digested into peptides using proteases typically trypsin. An optional fractionation or enrichment may be applied at either the protein or peptide level to enhance the scope of identification. Peptides are separated by high-performance liquid chromatography (HPLC) and afterward transferred into the vacuum of the mass spectrometer mostly using electrospray ionization (ESI). Cycles of full MS including all peptide at a time followed by MS/MS of selected peptides are measured. The consecutive measured MS and MS/MS spectra are then used to computationally identify and quantify the peptide sequence and infer the protein.\n    \u003C/div\u003E\n\u003C/div\u003E  \n\nThe proteome is understood as an entire complement of proteins in one cell, tissue or a whole organism. \nProteomics as a scientific field deals with the qualitative and quantitative analysis of protein expression patterns. \nThus, proteomics relies primarily on the ability to unambiguously identify proteins, followed by accurate quantification. \nMass spectrometry-based proteomics refers to the large-scale analysis of\nproteins using mass spectrometry, an analytical method to determine the mass of molecules. In the case of proteomics, the target \nmolecules are whole proteins or peptides.\n\nThe typical proteomics workflow is as follows (\u003Ca href=\u0022#figure2\u0022\u003EFigure 2\u003C/a\u003E): first, proteins are isolated from \ncells or tissues by lysis followed by biochemical fractionation or affinity selection. MS on whole proteins (top-down proteomics) \nis less sensitive and more difficult to handle when compared to MS on peptides (bottom-up proteomics), as the mass of the intact protein by \nitself is insufficient for protein identification\u003Csup\u003E\u003Ca href=\u0022#18\u0022\u003E18\u003C/a\u003E,\u003Ca href=\u0022#19\u0022\u003E19\u003C/a\u003E\u003C/sup\u003E. Therefore, the bottom-up approach is \nstandardly used, which comprises the enzymatic degradation of proteins to peptides using an endopeptidase (trypsin in most cases)\n\u003Csup\u003E\u003Ca href=\u0022#20\u0022\u003E20\u003C/a\u003E\u003C/sup\u003E. Trypsin is advantageous as it generates peptides with C-terminally protonated amino acids to foster\n the detectability of a full ion ladder (series) in a subsequent, optional fragmentation step for sequencing. The peptides are separated by one\n  or more steps of liquid chromatography (LC) and afterwards transferred into the vacuum of the mass spectrometer, where a mass spectrum\n   of the peptides eluting at this time from the LC is taken (MS\u003Csup\u003E1\u003C/sup\u003E spectrum or \u2018normal mass spectrum\u2019). A prioritized list of these peptides\n    for fragmentation is either automatically generated or provided by the operator. These peptide ions are then fragmented by energetic collision with\n     an inert gas and recorded as tandem MS spectra (MS/MS or MS\u003Csup\u003E2\u003C/sup\u003E spectra). The consecutive MS and MS/MS\n      spectra are then used to computationally identify the peptide\u2019s sequence and quantify its abundance\u003Csup\u003E\u003Ca href=\u0022#21\u0022\u003E22\u003C/a\u003E,\n      \u003Ca href=\u0022#22\u0022\u003E22\u003C/a\u003E\u003C/sup\u003E.\n\n\u003C/div\u003E\n\n\u003Chr\u003E\n*)\n(**\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP02_Plant_Systems_Biology.html\u0027;\u0022\u003E\u0026#171; JP02\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP04_Digestion_and_mass_calculation.html\u0027;\u0022\u003EJP04 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n\n(** \n## References\n\u003Ca href=\u0022#Mass-Spectrometry-Based-Proteomics\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Col\u003E\n\u003Cli Value=\u002218\u0022 Id=\u002218\u0022\u003E Breuker, K., Jin, M., Han, X., Jiang, H. \u0026 McLafferty, F. W. Top-down identification and characterization of biomolecules by mass spectrometry. Journal of the American Society for Mass Spectrometry 19, 1045\u20131053; 10.1016/j.jasms.2008.05.013 (2008).\u003C/li\u003E\n\n\u003Cli Id=\u002219\u0022\u003E Reid, G. E. \u0026 McLuckey, S. A. \u0027Top down\u0027 protein characterization via tandem mass spectrometry. Journal of mass spectrometry : JMS 37, 663\u2013675; 10.1002/jms.346 (2002).\u003C/li\u003E\n\n\u003Cli Id=\u002220\u0022\u003E Olsen, J. V., Ong, S.-E. \u0026 Mann, M. Trypsin cleaves exclusively C-terminal to arginine and lysine residues. Molecular \u0026 cellular proteomics : MCP 3, 608\u2013614; 10.1074/mcp.T400003-MCP200 (2004).\u003C/li\u003E\n\n\u003Cli Id=\u002221\u0022\u003E Walther, T. C. \u0026 Mann, M. Mass spectrometry-based proteomics in cell biology. J. Cell Biol. 190, 491\u2013500; 10.1083/jcb.201004052 (2010).\u003C/li\u003E\n\n\u003Cli Id=\u002222\u0022\u003E Aebersold, R. \u0026 Mann, M. Mass spectrometry-based proteomics. Nature 422, 198\u2013207; 10.1038/Nature01511 (2003).\u003C/li\u003E\n\u003C/ol\u003E\n*)\n"}]