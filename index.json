[{"uri":"/BIO-BTE-06-L-7/JP06_Retention_time_and_scan_time.html","title":"JP06 Retention time and scan time\n","content":"(**\n# JP06 Retention time and scan time\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP06_Retention_time_and_scan_time.ipynb)\n\n1. Retention time and scan time\n    1. m/z calculation of the digested peptides\n    2. Determination of peptide hydrophobicity\n\n*)\n\n(**\n## Retention time and scan time\n\nIn general, peptides are separated by one or more steps of liquid chromatography (LC). The retention time (RT) is the time when the measured \npeptides were eluting from the column and is therefore influenced by the physicochemical interaction of the particular peptide with the \ncolumn material. Scan time is basically synonym to retention time, but more from the point of view of the device.\n\nThe aim of this notebook is to understand that even though peptides are roughly separated by the LC, multiple peptides elute at the same \nretention time and are recorded within one MS1 spectrum. Here, we will simulate a MS1 spectrum by random sampling from \nour previously generated peptide-mass distribution. Further, we will try to improve our simulation by incorporating information about the peptide \nhydrophobicity. It is a only a crude model, but considers the fact that less hydrophobic peptides elute faster from the 13C LC column.\n\nAs always, we start by loading our famous libraries.\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.1\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen BioFSharp\nopen Plotly.NET\nopen BioFSharp.Elements\nopen BIO_BTE_06_L_7_Aux\nopen FS3_Aux\nopen Retention_time_and_scan_time_Aux\nopen System.IO\n\nopen FSharp.Stats\n\n(**\n## m/z calculation of the digested peptides\n\nI think you remember the protein digestion process from the privious notebook (see: *JP04_Digestion_and_mass_calculation.ipynb* ). This time we also remember the peptide sequence, because we need it later for hydrophobicity calculation. \n*)\n\n// Code-Block 1\n\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/Chlamy_JGI5_5(Cp_Mp).fasta\u0022|]\ndownloadFile path \u0022Chlamy_JGI5_5(Cp_Mp).fasta\u0022 \u0022bio-bte-06-l-7\u0022\n// with /../ we navigate a directory \npath\n\nlet peptideAndMasses = \n    path\n    |\u003E IO.FastA.fromFile BioArray.ofAminoAcidString\n    |\u003E Seq.toArray\n    |\u003E Array.mapi (fun i fastAItem -\u003E\n        Digestion.BioArray.digest Digestion.Table.Trypsin i fastAItem.Sequence\n        |\u003E Digestion.BioArray.concernMissCleavages 0 0\n        )\n    |\u003E Array.concat\n    |\u003E Array.map (fun peptide -\u003E\n        // calculate mass for each peptide\n        peptide.PepSequence, BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n        )\n\npeptideAndMasses |\u003E Array.head\n\n(***include-it***)\n\n(**\nCalculate the single and double charged m/z for all peptides and combine both in a single collection.\n*)\n\n// Code-Block 2\n\n// calculate m/z for each peptide z=1\nlet singleChargedPeptides =\n    peptideAndMasses\n    // we only consider peptides longer than 6 amino acids \n    |\u003E Array.filter (fun (peptide,ucMass) -\u003E peptide.Length \u003E=7)\n    |\u003E Array.map (fun (peptide,ucMass) -\u003E peptide, Mass.toMZ ucMass 1.) \n\n// calculate m/z for each peptide z=2\nlet doubleChargedPeptides =\n    peptideAndMasses\n    // we only consider peptides longer than 6 amino acids \n    |\u003E Array.filter (fun (peptide,ucMass) -\u003E peptide.Length \u003E=7)\n    |\u003E Array.map (fun (peptide,ucMass) -\u003E peptide, Mass.toMZ ucMass 2.) \n\n// combine this two    \nlet chargedPeptides =\n    Array.concat [singleChargedPeptides;doubleChargedPeptides]\n\n\nchargedPeptides.[1]\n\n(***include-it***)\n\n(**\nNow, we can sample our random \u0022MS1\u0022 spectrum from this collection of m/z.\n*)\n\n// Code-Block 3\n\n// initialze a random generator \nlet rnd = new System.Random()\n\n// sample n random peptides from all Chlamydomonas reinhardtii peptides\nlet chargedPeptideChar =\n    Array.sampleWithOutReplacement rnd chargedPeptides 100\n    // we only want the m/z\n    |\u003E Array.map (fun (peptide,mz) -\u003E mz,1.) \n    |\u003E Chart.Column\n    |\u003E Chart.withX_AxisStyle(\u0022m/z\u0022, MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle (\u0022Intensity\u0022, MinMax=(0.,1.3))\n    |\u003E Chart.withSize (900.,400.)\nchargedPeptideChar\n(***hide***)\nchargedPeptideChar |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\nThis looks quite strange. I think you immediately see that we forgot about our isotopic cluster. A peptide doesn\u2019t produce a single peak, \nbut a full isotopic cluster. Therefore, we use our convenience function from the previous notebook \n(see: *JP05_Isotopic_distribution.ipynb* ).\n\n*)\n\n// Code-Block 4\n\n// Predicts an isotopic distribution of the given formula at the given charge, \n// normalized by the sum of probabilities, using the MIDAs algorithm\nlet generateIsotopicDistribution (charge:int) (f:Formula.Formula) =\n    IsotopicDistribution.MIDA.ofFormula \n        IsotopicDistribution.MIDA.normalizeByMaxProb\n        0.01\n        0.005\n        charge\n        f\n    |\u003E List.toArray\n        \ngenerateIsotopicDistribution\n\n// Code-Block 5\n\nlet peptidesAndMassesChart =\n    // sample n random peptides from all Chlamydomonas reinhardtii peptides\n    Array.sampleWithOutReplacement rnd peptideAndMasses 500\n    |\u003E Array.map (fun (peptide,mz) -\u003E \n            peptide\n            |\u003E BioSeq.toFormula\n            // peptides are hydrolysed in the mass spectrometer, so we add H2O\n            |\u003E Formula.add Formula.Table.H2O\n            )\n    |\u003E Array.collect (fun formula -\u003E \n        [\n            // generate single charged iones \n            generateIsotopicDistribution 1 formula\n            // generate double charged iones \n            generateIsotopicDistribution 2 formula\n        ] |\u003E Array.concat\n        )\n    |\u003E Chart.Column\n    |\u003E Chart.withX_AxisStyle(\u0022m/z\u0022, MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle (\u0022Intensity\u0022, MinMax=(0.,1.3))\n    |\u003E Chart.withSize (900.,400.)\npeptidesAndMassesChart\n// HINT: zoom in on peptides\n\n(***hide***)\npeptidesAndMassesChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Determination of peptide hydrophobicity\n\nIn a MS1 scan, peptides don\u0027t appear randomly. They elute according to their hydrophobicity and other physicochemical properties \nfrom the LC.\n\nTo more accurately represent a MSU\u002B00B9 spectrum, we determine the hydrophobicity of each peptide. Therefore, we first need a function \nthat maps from sequence to hydrophobicity.\n*)\n\n// Code-Block 6\n\nopen BioFSharp.AminoProperties\n\n// first, define a function that maps from amino acid to hydophobicity\nlet getHydrophobicityIndex =\n    BioFSharp.AminoProperties.initGetAminoProperty AminoProperty.HydrophobicityIndex\n    \n// second, use that function to map from peptide sequence to hydophobicity\nlet toHydrophobicity (peptide:AminoAcids.AminoAcid[]) =\n    peptide\n    |\u003E Array.map AminoAcidSymbols.aminoAcidSymbol\n    |\u003E AminoProperties.ofWindowedBioArray 3 getHydrophobicityIndex\n    |\u003E Array.average\n\ntoHydrophobicity\n\n// Code-Block 7\n\nlet peptidesFirst200 = \n    chargedPeptides \n    // now we sort according to hydrophobicity\n    |\u003E Array.sortBy (fun (peptide,mass) -\u003E   \n        peptide\n        |\u003E Array.ofList\n        |\u003E toHydrophobicity\n        )\n    |\u003E Array.take 200\n\npeptidesFirst200 |\u003E Array.head\n\n(***include-it***)\n\n(**\nNow, we need to generate the isotopic cluster again and visualize afterwards.\n*)\n\n// Code-Block 8\n\nlet peptidesFirst200Chart =\n    peptidesFirst200\n    |\u003E Array.map (fun (peptide,mz) -\u003E \n            peptide\n            |\u003E BioSeq.toFormula\n            // peptides are hydrolysed in the mass spectrometer, so we add H2O\n            |\u003E Formula.add Formula.Table.H2O\n            )\n    |\u003E Array.collect (fun formula -\u003E \n        [\n            // generate single charged iones \n            generateIsotopicDistribution 1 formula\n            // generate double charged iones \n            generateIsotopicDistribution 2 formula\n        ] |\u003E Array.concat\n        )\n    // Display\n    |\u003E Chart.Column\n    |\u003E Chart.withX_AxisStyle(\u0022m/z\u0022, MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle (\u0022Intensity\u0022, MinMax=(0.,1.3))\n    |\u003E Chart.withSize (900.,400.)\npeptidesFirst200Chart\n// HINT: zoom in on peptides\n\n(***hide***)\npeptidesFirst200Chart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)"},{"uri":"/BIO-BTE-06-L-7/JP09_Fragmentation_for_peptide_identification.html","title":"JP09 Fragmentation for peptide identification\n","content":"(**\n# JP09 Fragmentation for peptide identification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP09_Fragmentation_for_peptide_identification.ipynb)\n\n1. [Understanding MS2 spectra: From peptide to fragment](#Understanding-MS2-spectra:-From-peptide-to-fragment)\n2. [Simulate MS2 Fragmentation](#Simulate-MS2-Fragmentation)\u003Cbr\u003E\n2. [References](#References)\n*)\n\n(**\n## Understanding MS2 spectra: From peptide to fragment\n\u003Ca href=\u0022#Fragmentation-for-peptide-identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nThe currency of information for identification in MS-based proteomics is the fragment ion spectrum (MS/MS spectrum) that is typically \nderived from the fragmentation of a specific peptide in the collision cell of a mass spectrometer. Peptides produce fragments that provide \ninformation on their amino acid sequence. The correct assignment of such a spectrum to a peptide sequence is the central step to link \nm/z values and ion intensities to biology\u003Csup\u003E\u003Ca href=\u0022#31\u0022\u003E31\u003C/a\u003E\u003C/sup\u003E. \n\n\u003Cdiv Id=\u0022figure4\u0022 Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 60% ; padding: 15px\u0022\u003E\n    \u003Cimg src=\u0022img/FragmentIonNomenclature.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; margin-top: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\n        \u003Cb\u003EFigure 4: The Roepstorff-Fohlmann-Biemann nomenclature of fragment ions.\u003C/b\u003E\n        N-terminal and C-terminal peptide fragments result of dissociation of electron bonds along the peptide backbone.\n    \u003C/div\u003E\n\u003C/div\u003E    \n\nDuring the unimolecular peptide ion dissociation processes, different chemical reactions can lead to different types \nof product ions. The types of ions observed in MS/MS experiments depend on the physicochemical properties of the amino \nacids and their sequence, on the amount of internal energy, and on the peptide\u2019s charge state. In addition, product ion formation \nis strongly influenced by the fragmentation method\u003Csup\u003E\u003Ca href=\u0022#32\u0022\u003E32\u003C/a\u003E\u003C/sup\u003E. The most widely used fragmentation methods today \nare low-energy collision-induced dissociation (CID)\u003Csup\u003E\u003Ca href=\u0022#33\u0022\u003E33\u003C/a\u003E\u003C/sup\u003E and electron transfer dissociation \n(ETD)\u003Csup\u003E\u003Ca href=\u0022#34\u0022\u003E34\u003C/a\u003E\u003C/sup\u003E. These methods favor fragmentation along the peptide backbone and result in an N-terminal prefix \nfragment and a C-terminal suffix fragment. The standard nomenclature for the C-terminal fragments is x, y and z whereas the corresponding \nN-terminal fragments are denoted as a, b and c depending on the position where the breakage occurs at the peptide backbone level. The numbering \nof each fragment starts from the N-terminus for a,b,c series and from the C-terminus for x,y,z series (\u003Ca href=\u0022#figure4\u0022\u003EFigure 4\u003C/a\u003E). \nOne should keep in mind that during parent ion selection many of the same peptide ions are selected and dissociated into fragments, with the \nresulting fragment ions having different relative abundances according to the preferred fragmentation reaction. In addition to the \nfragmentation along the peptide backbone, fragment ions containing the amino acids R, K, N, or Q can lose ammonia (-17 Da) and are then \ndenoted a*, b* and y*. Fragments containing the amino acids S, T, E, or D may lose water (-18 Da) and are then denoted a\u00B0, b\u00B0 and y\u00B0. \nThese losses do not change the charge of the ions and are observable as natural losses \u003Csup\u003E\u003Ca href=\u0022#35\u0022\u003E35\u003C/a\u003E,\u003Ca href=\u0022#36\u0022\u003E36\u003C/a\u003E\u003C/sup\u003E.\n\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\n\n(**\n## Simulate MS2 Fragmentation\n\u003Ca href=\u0022#Fragmentation-for-peptide-identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\nFor the simulation we first define a short peptide. The peptide we take for this example is from rbcL.\n\n*)\n\n// Code-Block 1\n\nlet peptide = \n    \u0022DTDILAAFR\u0022\n    |\u003E BioList.ofAminoAcidString\n\npeptide\n\n(***include-it***)\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\nIn the \u003Ccode\u003EMz\u003C/code\u003E namespace of \u003Ca href=\u0022https://csbiology.github.io/BioFSharp/\u0022\u003EBioFSharp\u003C/a\u003E, we can find a function that can \ngenerate the theoretical series of y-ions from the given peptide. This function provides a lot of information, but we are only interested \nin the mass. Notice, that we do not know the intesity of the fragment ions and just use \u00271.\u0027 for simulation.\n\u003C/div\u003E\n*)\n\n// Code-Block 2\n\nlet ionSeriesY =\n    peptide\n    |\u003E Mz.Fragmentation.Series.yOfBioList BioItem.initMonoisoMassWithMemP\n    |\u003E List.map (fun aac -\u003E aac.MainPeak.Mass,1.)\n    \nionSeriesY\n\n(***include-it***)\n\n(**\nSimilarly, we can simulate the b-ion series.\n*)\n\n// Code-Block 3\n\nlet ionSeriesB =\n    peptide\n    |\u003E Mz.Fragmentation.Series.bOfBioList BioItem.initMonoisoMassWithMemP\n    |\u003E List.map (fun aac -\u003E aac.MainPeak.Mass,1.)\n\nionSeriesB\n\n(***include-it***)\n\n(**\nNow, we can just plot the simulated data and look at our theoretical spectrum.\n*)\n\n// Code-Block 4\n\nlet ionChart =\n    [    \n        Chart.Column (ionSeriesB, Name=\u0022b ions\u0022)\n        Chart.Column (ionSeriesY, Name=\u0022y ions\u0022)\n    ]\n    |\u003E Chart.Combine\nionChart\n(***hide***)\nionChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP08_Centroidisation.html\u0027;\u0022\u003E\u0026#171; JP08\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP10_Peptide_Identification.html\u0027;\u0022\u003EJP10 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)\n\n(**\n## References\n\u003Ca href=\u0022#Fragmentation-for-peptide-identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Col\u003E\n\u003Cli Value=\u002231\u0022 Id=\u002231\u0022\u003E Nesvizhskii, A. I., Vitek, O. \u0026 Aebersold, R. Analysis and validation of proteomic data generated by tandem mass spectrometry. Nature methods 4, 787\u2013797; 10.1038/nmeth1088 (2007).\n\u003Cli Id=\u002232\u0022\u003E Medzihradszky, K. F. Peptide sequence analysis. Method Enzymol 402, 209\u2013244; 10.1016/S0076-6879(05)02007-0 (2005).\n\u003Cli Id=\u002233\u0022\u003E Johnson, R. S., Martin, S. A., Biemann, K., Stults, J. T. \u0026 Watson, J. T. Novel fragmentation process of peptides by collision-induced decomposition in a tandem mass spectrometer: differentiation of leucine and isoleucine. Anal. Chem. 59, 2621\u20132625; 10.1021/Ac00148a019 (1987).\n\u003Cli Id=\u002234\u0022\u003E Mikesh, L. M. et al. The utility of ETD mass spectrometry in proteomic analysis. Biochimica et biophysica acta 1764, 1811\u20131822; 10.1016/j.bbapap.2006.10.003 (2006).\n\u003Cli Id=\u002235\u0022\u003E Forner, F., Foster, L. J. \u0026 Toppo, S. Mass spectrometry data analysis in the proteomics era. Curr Bioinform 2, 63\u201393; 10.2174/157489307779314285 (2007).\n\u003Cli Id=\u002236\u0022\u003E Steen, H. \u0026 Mann, M. The ABC\u0027s (and XYZ\u0027s) of peptide sequencing. Nat. Rev. Mol. Cell Biol. 5, 699\u2013711; 10.1038/nrm1468 (2004).\n\u003C/ol\u003E\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP08_Centroidisation.html","title":"JP08 Centroidisation\n","content":"(**\n# JP08 Centroidisation\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP08_Centroidisation.ipynb)\n\n\n1. Centroidisation\n2. Peak fitting and picking functions\n3. Application of the peak picking function\n\n*)\n\n(**\n## Centroidisation\n\nIn reality, a peak is represented by a collection of signals from a peptide or fragment ion species that are measured by the \nspecific detector. Due to imperfections of the measurement, there is a scatter around the accurate mass. This distribution \nalong the m/z axis of signals from ion species is termed profile peak. The conversion of a peak profile into the corresponding m/z and \nintensity values reduces the complexity, its representation is termed centroiding. To extract the masses for identification in a simple \nand fast way, peak fitting approaches are used. Further, peak fitting algorithms are also needed to extract ion abundancies and therefore \nexplained under quantification in the following section.\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.1\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp.Mz\nopen BIO_BTE_06_L_7_Aux.FS3_Aux\n\n(**\n## Peak fitting and picking functions\n\nWe declare a function which centroids the given m/z and intensity data. In the scope of the function the m/z and intensity data \nare padded for the wavelet (You will read more about wavelet functions later in *JP11_Quantification.ipynb* ) \nand the centroided. For the centroidisation, we use a Ricker 2D wavelet.\n*)\n\n// Code-Block 1\n\nlet ms1PeakPicking (mzData:float []) (intensityData: float []) = \n    if mzData.Length \u003C 3 then \n        [||],[||]\n    else\n        let paddYValue = Array.min intensityData\n        // we need to define some padding and wavelet parameters\n        let paddingParams = \n            SignalDetection.Padding.createPaddingParameters paddYValue (Some 7) 0.05 150 95.\n        let waveletParameters = \n            SignalDetection.Wavelet.createWaveletParameters 10 paddYValue 0.1 90. 1. false false\n        \n        let paddedMz,paddedIntensity = \n            SignalDetection.Padding.paddDataBy paddingParams mzData intensityData\n        \n        BioFSharp.Mz.SignalDetection.Wavelet.toCentroidWithRicker2D waveletParameters paddedMz paddedIntensity \n\n\n(**\nWe load a sample MS1 from a mgf file.\n*)\n\n// Code-Block 2\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/ms1MGF.mgf\u0022|]\ndownloadFile path \u0022ms1MGF.mgf\u0022 \u0022bio-bte-06-l-7\u0022\n\nlet ms1 = \n    BioFSharp.IO.Mgf.readMgf (path)\n    |\u003E List.head\n\nms1\n\n(***include-it***)\n\n(**\n## Application of the peak picking function\n\nWe centroid the MS2 data using the function declared beforehand:\n*)\n\n// Code-Block 3\n\nlet centroidedMs1 = \n    ms1PeakPicking ms1.Mass ms1.Intensity\n\n(**\n*)\n\n// Code-Block 4\n\n//removes low intensity data points for charting\nlet filteredMs1Mass, filteredMs1Intensity =\n    Array.zip ms1.Mass ms1.Intensity\n    |\u003E Array.filter (fun (mass, intensity) -\u003E\n        intensity \u003E 400.\n    )\n    |\u003E Array.unzip\n\nlet filteredChart =\n    [\n        Chart.Point(filteredMs1Mass,filteredMs1Intensity)\n        |\u003E Chart.withTraceName \u0022Uncentroided MS1\u0022\n        Chart.Point(fst centroidedMs1,snd centroidedMs1)\n        |\u003E Chart.withTraceName \u0022Centroided MS1\u0022\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withY_AxisStyle \u0022Intensity\u0022\n    |\u003E Chart.withX_AxisStyle (title = \u0022m/z\u0022, MinMax = (400., 800.))\n    |\u003E Chart.withSize (900.,900.)\nfilteredChart\n(***hide***)\nfilteredChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n"},{"uri":"/BIO-BTE-06-L-7/JP05_Isotopic_distribution.html","title":"JP05 Isotopic Distribution\n","content":"(**\n# JP05 Isotopic Distribution\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP05_Isotopic_distribution.ipynb)\n\n\n1. Isotopic Distribution\n    1. Simulating Isotopic Clusters for peptides\n    2. Simulating Isotopic Clusters for peptides with stable isotope labeled variant\n2. References\n\n*)\n(**\n## Isotopic Distribution\n\nPeptide signals exhibit a characteristic shape in the mass spectrum that depend on their isotopic profile, which is defined by \nthe number of naturally occurring isotopes in the peptide. The occurrence probabilities of natural isotopes are reflected in the mass \nspectrum by the relative heights of the peak series belonging to the respective peptide. The frequency at which natural isotopes occur \nis known and can be used to compute the isotope distribution of a molecule. The isotopic distribution for a given peptide molecule \nC(v)H(w)N(x)O(y)S(z) is described by the following product of polynomials:\n\n![](https://latex.codecogs.com/gif.latex?\\large\u0026space;\\newline(\u0026space;{}^{12}\\textrm{C}\u0026space;\u0026plus;\u0026space;{}^{13}\\textrm{C})^{v}\u0026space;\\times\u0026space;({}^{1}\\textrm{H}\u0026plus;{}^{2}\\textrm{H})^{w}\u0026space;\\times\u0026space;({}^{14}\\textrm{N}\u0026plus;{}^{15}\\textrm{N})^{x}\\times({}^{16}\\textrm{O}\u0026plus;{}^{17}\\textrm{O}\u0026space;\u0026plus;\u0026space;{}^{18}\\textrm{O})^{y}\\newline\\times({}^{32}\\textrm{S}\u0026plus;{}^{33}\\textrm{S}\u0026plus;{}^{34}\\textrm{S}\u0026plus;{}^{36}\\textrm{S})^{z})\n\nSymbolic expansion of the polynomials results in many product terms, which correspond to different isotopic variants of a molecule. \nEven for molecules of a medium size, the straightforward expansion of the polynomials leads to an explosion regarding the number of product terms. \nDue to this complexity, there was a need to develop algorithms for efficient computation. The different strategies comprise pruning the \npolynomials to discard terms with coefficients below a threshold (Yergey 1983) combined with a recursive \ncomputation (Claesen et al. 2012), and Fourier Transformation for a more efficient convolution of the isotope distributions of \nindividual elements (Rockwood et al. 1995), or rely on dynamic programming (Snider 2007).\n\n\u003E MIDAs (Alves and Yu 2005) is one of the more elaborate algorithms to predict an isotope cluster based on a given peptide sequence. \n\u003E Simulate the isotopic cluster of the peptide sequence \u2018PEPTIDES\u2019 and \u2018PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u2019 with natural occurring isotope abundances.\n\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\n(**\n\n## Simulating Isotopic Clusters for peptides\n\nWe will use two artificial peptide sequences and translate them into their elemental composition to simulate their isotopic clusters. \nTherefore, we first define a function that maps from a peptide sequence to its formula:\n*)\n\n// Code-Block 1\n\n// create chemical formula for amino acid and add water to reflect hydrolysed state in mass spectrometer\nlet toFormula bioseq =  \n    bioseq\n    |\u003E BioSeq.toFormula\n    // peptides are hydrolysed in the mass spectrometer, so we add H2O\n    |\u003E Formula.add Formula.Table.H2O\n\n(**\nNext, we will apply our function to receive the elemental composition or chemical formula of the peptides.\n*)\n\n// Code-Block 2\n\n// translate single letter code into amino acids and create chemical formula of it.\nlet peptide_short = \n    \u0022PEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    \nlet peptide_long  = \n    \u0022PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    \nlet peptide_shortString =\n    peptide_short \n    |\u003E Formula.toString\n\n\nlet peptide_longString =\n    peptide_long \n    |\u003E Formula.toString\n\n(*** include-value:peptide_shortString ***)\n\n(*** include-value:peptide_longString ***)\n\n(**\nAdditionally, we need a function that maps from Formula (and charge) to the isotopic distribution. Here, we \ncan use \u0060IsotopicDistribution.MIDA.ofFormula\u0060 from the BioFSharp library. However, for convenience \n(to use the same parameter twice), we define our function \u0060generateIsotopicDistribution\u0060:\n*)\n\n// Code-Block 3\n\n// Predicts an isotopic distribution of the given formula at the given charge, \n// normalized by the sum of probabilities, using the MIDAs algorithm\nlet generateIsotopicDistribution (charge:int) (f:Formula.Formula) =\n    IsotopicDistribution.MIDA.ofFormula \n        IsotopicDistribution.MIDA.normalizeByMaxProb\n        0.01\n        0.005\n        charge\n        f\n        \n// create pattern for peptide_short\nlet isoPattern_peptide_short = \n    generateIsotopicDistribution 1 peptide_short\n\n// create pattern for peptide_long\nlet isoPattern_peptide_long = \n    generateIsotopicDistribution 1 peptide_long\n    \nisoPattern_peptide_long\n\n(*** include-it ***)\n\n\n// Code-Block 4\n\n// create one chart for both, short and long peptide isotopic patterns.     \nlet isoPatternChart = \n    [\n        Chart.Column(isoPattern_peptide_short,Name= \u0022peptide_short\u0022 )\n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(885.,895.))\n        Chart.Column(isoPattern_peptide_long,Name= \u0022peptide_long\u0022 )\n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(3230., 3240.))\n    ]\n    |\u003E Chart.Stack 2\n    |\u003E Chart.withSize (900.,600.)\n    |\u003E Chart.withTitle \u0022Isotopeclusters\u0022\n    |\u003E Chart.withY_AxisStyle \u0022intensity\u0022\nisoPatternChart\n\n(***hide***)\nisoPatternChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Simulating Isotopic Clusters for peptides with stable isotope labeled variant\n\nIn addition to the natural occurring isotopic distribution, the field of proteomics has benefited greatly from the ability to \nintroduce stable isotopes into peptide sequences. So called isotopic labeling refers to the introduction of a naturally low-abundance \nisotope of carbon, nitrogen, hydrogen and, in some cases, oxygen, into a peptide sequence. The isotopes commonly used are 13C, \n15N, 2H (deuterium) and 18O with natural abundances of 1.10%, 0.366%, 0.015% and 0.200%, \nrespectively (Becker 2008). Therefore, the introduction of these isotopes into a peptide sequence can be detected by \nmost modern mass spectrometers leading to a respective mass shift and the ability to separate the same peptide species within the same run.\n\n\u003E MIDAs (Alves and Yu 2005) is also able to predict isotope clusters with altered isotope abundances. Simulate the isotopic cluster \n\u003E of the peptide sequence \u2018PEPTIDES\u2019 and \u2018PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u2019 with stable isotopes 15N labeling. \n\nTherefore, we define a function called \u0060label\u0060. The function maps from a formula to a formula with exchangen nitrogen isotopes. \n(Attention: Don\u0027t get confused a formula is just a FSharpMap.) \n*)\n\n// Code-Block 5\n\n/// returns a function that replaces the nitrogen atoms in a formula\n/// with the 15N isotope\nlet label formula =\n    Formula.replaceElement formula Elements.Table.N Elements.Table.Heavy.N15\n\n(** *)\n\n// Code-Block 6\n\nlet N15_peptide_short = \n    \u0022PEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    |\u003E label\n\nlet N15_peptide_long  = \n    \u0022PEPTIDEPEPTIDEPEPTIDEPEPTIDES\u0022 \n    |\u003E BioSeq.ofAminoAcidString\n    |\u003E toFormula\n    |\u003E label\n\n//result: N15_peptide_short\nN15_peptide_short\n(*** include-value:N15_peptide_short ***)\n\n//result: N15_peptide_long\nN15_peptide_long\n(*** include-value:N15_peptide_long ***)\n\n(** *)\n\n// Code-Block 7\n\n// create pattern for N15_peptide_short\nlet N15_isoPattern_peptide_short = \n    generateIsotopicDistribution 1 N15_peptide_short\n\n// create pattern for N15_peptide_long\nlet N15_isoPattern_peptid_long = \n    generateIsotopicDistribution 1 N15_peptide_long\n\n(***include-value:N15_isoPattern_peptide_short***)\n(***include-value:N15_isoPattern_peptid_long***)\n\n(** *)\n\n// Code-Block 8\n\n// Create two charts. Each with the related N14 and N15 isotopic clusters. Then stack them two one unit.\nlet isoPatternChart2 = \n    [\n        [\n            Chart.Column(isoPattern_peptide_short,Name= \u0022peptide_short\u0022 )\n            Chart.Column(N15_isoPattern_peptide_short,Name= \u0022N15_peptide_short\u0022 )\n        ] \n        |\u003E Chart.Combine \n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(885., 905.0))\n\n        [\n            Chart.Column(isoPattern_peptide_long,Name= \u0022peptide_long\u0022 )\n            Chart.Column(N15_isoPattern_peptid_long,Name= \u0022N15_peptide_long\u0022 )            \n        ] \n        |\u003E Chart.Combine \n        |\u003E Chart.withX_AxisStyle (\u0022m/z\u0022,MinMax=(3230.0, 3270.0))\n    ]\n    |\u003E Chart.Stack 2\n    |\u003E Chart.withTitle \u0022Isotopeclusters\u0022\n    |\u003E Chart.withY_AxisStyle \u0022intensity\u0022\nisoPatternChart2\n(***hide***)\nisoPatternChart2 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## References\n\n25. Yergey, J. A. A General-Approach to Calculating Isotopic Distributions for Mass-Spectrometry. Int J Mass Spectrom 52, 337\u2013349; 10.1016/0020-7381(83)85053-0 (1983).\n26. Claesen, J., Dittwald, P., Burzykowski, T. \u0026 Valkenborg, D. An efficient method to calculate the aggregated isotopic distribution and exact center-masses. Journal of the American Society for Mass Spectrometry 23, 753\u2013763; 10.1007/s13361-011-0326-2 (2012).\n27. Rockwood, A. L., Vanorden, S. L. \u0026 Smith, R. D. Rapid Calculation of Isotope Distributions. Anal Chem 67, 2699\u20132704; 10.1021/Ac00111a031 (1995).\n28. Snider, R. K. Efficient calculation of exact mass isotopic distributions. Journal of the American Society for Mass Spectrometry 18, 1511\u20131515; 10.1016/j.jasms.2007.05.016 (2007).\n29. Alves, G. \u0026 Yu, Y. K. Robust accurate identification of peptides (RAId). deciphering MS2 data using a structured library search with de novo based statistics. Bioinformatics 21, 3726\u20133732; 10.1093/bioinformatics/bti620 (2005).\n30. Becker, G. W. Stable isotopic labeling of proteins for quantitative proteomic applications. Brief Funct Genomic Proteomic 7, 371\u2013382; 10.1093/bfgp/eln047 (2008).\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP12_Targeted_quantification_of_photosynthetic_proteins_LE.html","title":"JP12 Targeted quantification of photosynthetic proteins (Label Efficiency)\n","content":"(**\n# JP12 Targeted quantification of photosynthetic proteins (Label Efficiency)\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP12_Targeted_quantification_of_photosynthetic_proteins_LE.ipynb)\n\n1. [Label Efficiency of 15N QProteins](#Label-Efficiency-of-15N-QProteins)\n2. [Read in .txt as Deedle Frame](#Read-in-.txt-as-Deedle-Frame)\n3. [Verify Limit of Detection](#Verify-Limit-of-Detection)\n    1. [Pearson correlation coefficient](#Pearson-correlation-coefficient)\n4. [Calculate Label Efficiency](#Calculate-Label-Efficiency)\n    1. [Median Label Efficiency](#Median-Label-Efficiency)\n5. [Midas Results](#Midas-Results)\n    1. [Midas Results Var 1](#Midas-Results-Var-1)\n    2. [Midas Results Var 2](#Midas-Results-Var-2)\n6. [Label Efficiency Conclusion Frame](#Label-Efficiency-Conclusion-Frame)\n7. [References](#References)\n*)\n\n(**\n## Label Efficiency of 15N QProteins\n\nThe amount of measured 15N QProtein quantities can, even if you pipette perfectly, vary due to a faulty label efficiency.\nThe label efficiency is an indicator on how many atoms of the designated type (here 15N) are in fact their stable isotope.\nA lower label efficiency will lead to lower quantities of the measured labeled peptides, as they will be detected on other m/z values than the predicted ones.\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.1\u0022\n#r \u0022nuget: Deedle, 2.3.0\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Deedle\nopen BioFSharp\nopen FSharpAux\nopen FSharp.Stats\nopen Plotly.NET\nopen FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear\nopen System.IO\nopen BIO_BTE_06_L_7_Aux.FS3_Aux\n\n(**\nWe will use the same auxiliary functions as in [JP12_WC](JP12_Targeted_quantification_of_photosynthetic_proteins_WC.ipynb).\n*)\n\n// Code-Block 1\n\nlet colorArray = [|\u0022#E2001A\u0022; \u0022#FB6D26\u0022; \u0022#00519E\u0022; \u0022#00e257\u0022;|]\n\nlet colorForMean = \u0022#366F8E\u0022\n\nlet xAxis showGrid title titleSize tickSize = Axis.LinearAxis.init(Title=title,Showgrid=showGrid,Showline=true,Mirror=StyleParam.Mirror.All,Zeroline=false,Tickmode=StyleParam.TickMode.Auto,Ticks= StyleParam.TickOptions.Inside, Tickfont=Font.init(StyleParam.FontFamily.Arial,Size=tickSize),Titlefont=Font.init(StyleParam.FontFamily.Arial,Size=titleSize))\nlet yAxis showGrid title titleSize tickSize = Axis.LinearAxis.init(Title=title,Showgrid=showGrid,Showline=true,Mirror=StyleParam.Mirror.All,Tickmode=StyleParam.TickMode.Auto,Ticks= StyleParam.TickOptions.Inside,Tickfont=Font.init(StyleParam.FontFamily.Arial,Size=tickSize),Titlefont=Font.init(StyleParam.FontFamily.Arial,Size=titleSize))\n\nlet config = Config.init(ShowEditInChartStudio=true, ToImageButtonOptions = ToImageButtonOptions.init(Format = StyleParam.ImageFormat.SVG, Filename = \u0022praktikumsplot.svg\u0022), EditableAnnotations = [AnnotationEditOptions.LegendPosition])\n\n(**\nNext, we need a \u0060map\u0060 of all proteins present in our QconCat proteins with their corresponding peptides.\n*)\n\n// Code block 2\n\nlet peptideProtMapping =\n    [\n    //PS\n    \u0022iRT\u0022   =\u003E  \u0022LGGNEQVTR\u0022\n    \u0022LCI5\u0022  =\u003E  \u0022SALPSNWK\u0022\n    \u0022LCI5\u0022  =\u003E  \u0022SVLPANWR\u0022\n    \u0022rbcL\u0022  =\u003E  \u0022DTDILAAFR\u0022\n    \u0022rbcL\u0022  =\u003E  \u0022EVTLGFVDLMR\u0022\n    \u0022rbcL\u0022  =\u003E  \u0022FLFVAEAIYK\u0022\n    \u0022rbcL\u0022  =\u003E  \u0022LTYYTPDYVVR\u0022\n    \u0022RBCS2\u0022 =\u003E  \u0022AYVSNESAIR\u0022\n    \u0022RBCS2\u0022 =\u003E  \u0022LVAFDNQK\u0022\n    \u0022RBCS2\u0022 =\u003E  \u0022YWTMWK\u0022\n    \u0022RBCS2\u0022 =\u003E  \u0022AFPDAYVR\u0022\n    \u0022RCA1\u0022  =\u003E  \u0022VPLILGIWGGK\u0022\n    \u0022RCA1\u0022  =\u003E  \u0022IGQQLVNAR\u0022\n    \u0022RCA1\u0022  =\u003E  \u0022SLVDEQENVK\u0022\n    \u0022PCY1\u0022  =\u003E  \u0022LGADSGALEFVPK\u0022\n    \u0022PCY1\u0022  =\u003E  \u0022DDYLNAPGETYSVK\u0022\n    \u0022psaB\u0022  =\u003E  \u0022TPLANLVYWK\u0022\n    \u0022psaB\u0022  =\u003E  \u0022ALYGFDFLLSSK\u0022\n    \u0022psaB\u0022  =\u003E  \u0022TNFGIGHR\u0022\n    \u0022atpB\u0022  =\u003E  \u0022LSIFETGIK\u0022\n    \u0022atpB\u0022  =\u003E  \u0022TAPAFVDLDTR\u0022\n    \u0022petA\u0022  =\u003E  \u0022IPAGPDLIVK\u0022\n    \u0022petA\u0022  =\u003E  \u0022NILVVGPVPGK\u0022\n    \u0022petA\u0022  =\u003E  \u0022IVAITALSEK\u0022\n    \u0022petA\u0022  =\u003E  \u0022YPIYFGGNR\u0022\n    \u0022FNR1\u0022  =\u003E  \u0022LYSIASSR\u0022\n    \u0022FNR1\u0022  =\u003E  \u0022LDYALSR\u0022\n    \u0022D1\u0022    =\u003E  \u0022VLNTWADIINR\u0022\n    \u0022D1\u0022    =\u003E  \u0022EWELSFR\u0022\n    \u0022D1\u0022    =\u003E  \u0022NTWADIINR\u0022\n    \u0022D1\u0022    =\u003E  \u0022LIFQYASFNNSR\u0022\n    \u0022LCI5\u0022  =\u003E  \u0022TALPADWR\u0022\n    \u0022psbD\u0022  =\u003E  \u0022LVFPEEVLPR\u0022\n    \u0022psbD\u0022  =\u003E  \u0022NILLNEGIR\u0022\n    \u0022psbD\u0022  =\u003E  \u0022TWFDDADDWLR\u0022\n    //CBC\n    \u0022PGK\u0022   =\u003E  \u0022ADLNVPLDK\u0022\n    \u0022PGK\u0022   =\u003E  \u0022TFNDALADAK\u0022\n    \u0022PGK\u0022   =\u003E  \u0022LSELLGKPVTK\u0022\n    \u0022Gap3\u0022  =\u003E  \u0022AVSLVLPSLK\u0022\n    \u0022Gap3\u0022  =\u003E  \u0022VLITAPAK\u0022\n    \u0022FBA3\u0022  =\u003E  \u0022ALQNTVLK\u0022\n    \u0022FBA3\u0022  =\u003E  \u0022VMFEGILLK\u0022\n    \u0022FBA3\u0022  =\u003E  \u0022SVVSIPHGPSIIAAR\u0022\n    \u0022FBP1\u0022  =\u003E  \u0022VPLFIGSK\u0022\n    \u0022FBP1\u0022  =\u003E  \u0022TLLYGGIYGYPGDAK\u0022\n    \u0022FBP1\u0022  =\u003E  \u0022IYSFNEGNYGLWDDSVK\u0022\n    \u0022SBP\u0022   =\u003E  \u0022LTNITGR\u0022\n    \u0022SBP\u0022   =\u003E  \u0022LLFEALK\u0022\n    \u0022TRK1\u0022  =\u003E  \u0022FLAIDAINK\u0022\n    \u0022TRK1\u0022  =\u003E  \u0022VSTLIGYGSPNK\u0022\n    \u0022TRK1\u0022  =\u003E  \u0022NPDFFNR\u0022\n    \u0022RPE1\u0022  =\u003E  \u0022FIESQVAK\u0022\n    \u0022RPE1\u0022  =\u003E  \u0022GVNPWIEVDGGVTPENAYK\u0022\n    \u0022RPE1\u0022  =\u003E  \u0022SDIIVSPSILSADFSR\u0022\n    \u0022PRK1\u0022  =\u003E  \u0022IYLDISDDIK\u0022\n    \u0022PRK1\u0022  =\u003E  \u0022VAELLDFK\u0022\n    \u0022PRK1\u0022  =\u003E  \u0022GHSLESIK\u0022\n    \u0022TPI1\u0022  =\u003E  \u0022SLFGESNEVVAK\u0022\n    \u0022TPI1\u0022  =\u003E  \u0022LVDELNAGTIPR\u0022\n    \u0022RPI1\u0022  =\u003E  \u0022LANLPEVK\u0022\n    \u0022RPI1\u0022  =\u003E  \u0022LQNIVGVPTSIR\u0022\n    \u0022RPI1\u0022  =\u003E  \u0022TQLSQDELK\u0022\n    \u0022DP12\u0022  =\u003E  \u0022SGQPAVDLNK\u0022\n    \u0022DP12\u0022  =\u003E  \u0022ASGQPAVDLNK\u0022\n    \u0022RMT1\u0022  =\u003E  \u0022AEAALLVR\u0022\n    \u0022RMT1\u0022  =\u003E  \u0022SNSTPLGSR\u0022\n    \u0022FBA1\u0022  =\u003E  \u0022GILASDESNATTGK\u0022\n    \u0022FBA1\u0022  =\u003E  \u0022ALQSSTLK\u0022\n    \u0022FBA2\u0022  =\u003E  \u0022VSAADVAR\u0022\n    \u0022FBA2\u0022  =\u003E  \u0022ALQASVLK\u0022\n    \u0022Cre07.g338451\u0022 =\u003E  \u0022VTEAAALASGR\u0022\n    \u0022FBP1\u0022  =\u003E  \u0022NLALELVR\u0022\n    \u0022CalSciex\u0022  =\u003E  \u0022SAEGLDASASLR\u0022\n    ]\n    |\u003E List.map (fun (x,y) -\u003E y,x)\n    |\u003E Map.ofList\n\npeptideProtMapping\n\n(***include-it***)\n\n(**\nAfter we got our peptide \u0026#8594; protein map, we need a \u0060map\u0060 for the files we want to analyze. For that we need the filename and a description of what \nthe file contains (experiment, spiked in peptide concentration).\nThis will be used as a schema for the .txt reader later on.\n*)\n\n// Code block 3\n\nlet labelEfficiencyNameMapping = \n    [\n    // filename(from QuantifiedPeptides.txt) =\u003E (\u0022LabelEfficiency\u0022, (\u0022Descriptive Text\u0022, Dilution))\n    \u0022G1 q1 zu 0.00032\u0022  =\u003E  (\u0022LabelEfficiency\u0022, (\u002215N Q \u002B 14N Q\u0022,           0.00032 ))\n    \u0022G1 q1 zu 0.0016\u0022   =\u003E  (\u0022LabelEfficiency\u0022, (\u002215N Q \u002B 14N Q\u0022,           0.0016  ))\n    \u0022G1 q1 zu 0.008\u0022    =\u003E  (\u0022LabelEfficiency\u0022, (\u002215N Q \u002B 14N Q\u0022,           0.008   ))\n    \u0022G1 q1 zu 0.04\u0022     =\u003E  (\u0022LabelEfficiency\u0022, (\u002215N Q \u002B 14N Q\u0022,           0.04    ))\n    \u0022G1 q1 zu 0.2\u0022      =\u003E  (\u0022LabelEfficiency\u0022, (\u002215N Q \u002B 14N Q\u0022,           0.2     ))\n    \u0022G1 Q1 zu 1zu 1\u0022    =\u003E  (\u0022LabelEfficiency\u0022, (\u002215N Q \u002B 14N Q \u002B 13C Q\u0022,   1.      ))\n    ]\n    |\u003E Map.ofList\n\nlabelEfficiencyNameMapping\n\n(***include-it***)\n\n(**\n## Read in .txt as Deedle Frame \nIn the first step we will just read in the data with the correct data types and assign it with descriptive rowKeys\n*)\n\n// Code block 4\n\nlet readQConcatResultFrame p : Frame\u003Cstring*(bool*int),string\u003E=\n    // read in .txt as deedle frame\n    let schemaFrame =\n        Frame.ReadCsv(path = p,separators=\u0022\\t\u0022)\n    // when creating deedle frames from files, the program can not always assume the correct type for all entries.\n    // Therefore we give it a list of all type defitions for all columns.\n    let schema =\n        schemaFrame.ColumnKeys\n        // only three tables are not float and these are the ones we filter out in the next step\n        |\u003E Seq.filter (fun x -\u003E not (x = \u0022StringSequence\u0022 || x = \u0022GlobalMod\u0022 || x = \u0022Charge\u0022))\n        // add float definition to all columns\n        |\u003E Seq.map (sprintf \u0022%s=float\u0022)\n        // specify the previously filtered out columns with the correct type defitions\n        |\u003E Seq.append [\u0022StringSequence=string\u0022;\u0022GlobalMod=bool\u0022;\u0022Charge=int\u0022]\n        |\u003E String.concat \u0022,\u0022\n    // read in the file again, this time with the correct types indicates as by schema\n    Frame.ReadCsv(path = p,schema=schema,separators=\u0022\\t\u0022)\n    // schemaFrames rows are labeled with increasing numbers, we want to give them unique descriptive keys.\n    // In this case we will use their peptideSequence (for example \u0022LVFPEEVLPR\u0022), the global modifier and charge\n    |\u003E Frame.indexRowsUsing (fun os -\u003E (os.GetAs\u003Cstring\u003E(\u0022StringSequence\u0022),((os.GetAs\u003Cbool\u003E(\u0022GlobalMod\u0022),(os.GetAs\u003Cint\u003E(\u0022Charge\u0022))))))\n    // as we now have the information about seq, global mod and charge in the row keys we can drop the origin columns.\n    |\u003E Frame.dropCol \u0022StringSequence\u0022\n    |\u003E Frame.dropCol \u0022GlobalMod\u0022\n    |\u003E Frame.dropCol \u0022Charge\u0022\n    |\u003E Frame.sortRowsByKey\n\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/Group1/G1_Q1_zu_1zu_1_QuantifiedPeptides.txt\u0022|]\ndownloadFile path \u0022G1_Q1_zu_1zu_1_QuantifiedPeptides.txt\u0022 \u0022bio-bte-06-l-7/Group1\u0022\n    \n/// DO NOT CHANGE THIS NAME! This value will be used in further code blocks.\n/// Insert your path to your QuantifiedPeptides.txt file for your label efficiency (only QProteins) here.\nlet qConCatResults =\n    readQConcatResultFrame path\n    \n// This part is only meant to show you the current state of your data  \nqConCatResults\n|\u003E Frame.sliceCols (qConCatResults.ColumnKeys |\u003E Array.ofSeq |\u003E fun x -\u003E x.[0..2])\n|\u003E fun x -\u003E x.Print()\n\nqConCatResults\n\n(***include-it***)\n\n(**\nNext we apply all our label \u0060map\u0060s to the data and filter to reduce the information to only include necessary data for these functions.\nPay attention to the all caps comment in the code below!\n*)\n\n// Code block 5\n\nlet labelEfficiencyResults : Frame\u003Cstring*(string*(string*float)),(string*(string*int))\u003E = \n    qConCatResults\n    // first use our \u0022labelEfficiencyNameMapping\u0022 to correctly label all columns\n    |\u003E Frame.mapColKeys \n        (fun (ck:string) -\u003E \n            let newCK = Map.find (ck.Split(\u0027_\u0027).[1 ..] |\u003E String.concat \u0022_\u0022) labelEfficiencyNameMapping\n            ck.Split(\u0027_\u0027).[0] , newCK\n        )\n    |\u003E Frame.sortColsByKey\n    // filter out all extra information noted in the file, but not needed for now.\n    |\u003E Frame.filterCols (fun ck _ -\u003E (fst ck).Contains(\u0022Quant\u0022) || (fst ck).Contains(\u0022N15MZ\u0022) || (fst ck).Contains(\u0022N15Minus1MZ\u0022))\n    // get mean values for all peptides, for which we found different charged versions.\n    |\u003E Frame.applyLevel (fun (sequence,(gmod,charge)) -\u003E sequence,charge) Stats.mean\n    // swap rows and columns\n    |\u003E Frame.transpose\n    // map over \u0022peptideProtMapping\u0022 to assign a related protein to all peptide sequences.\n    |\u003E Frame.mapColKeys\n        (fun ck -\u003E\n            match Map.tryFind (fst ck) peptideProtMapping with\n            |Some prot  -\u003E prot,ck\n            |None       -\u003E \u0022NotFound\u0022,ck\n        )\n    // THE FOLLOWING PART IS ONLY MEANT TO EASE ACCESS TO THESE FUNCTIONS AS FILTERING FOR ONLY \n    // RBCL GREATLY REDUCES THE COMPUTATION TIME. PLEASE REMOVE THIS FUNCTION AFTER YOU FAMILIARIZED \n    // YOURSELF WITH THE CODE AND OUTPUT TO ANALYZE ALL PROTEINS \n    |\u003E Frame.filterCols (fun ck cs -\u003E fst ck = \u0022rbcL\u0022)\n    \n// This part is only meant to show you the current state of your data  \nlabelEfficiencyResults\n|\u003E Frame.sliceCols (labelEfficiencyResults.ColumnKeys |\u003E Array.ofSeq |\u003E fun x -\u003E x.[0..1])\n//|\u003E Frame.filterCols (fun ck cs -\u003E fst ck = \u0022rbcL\u0022 \u0026\u0026 ((snd \u003E\u003E fst) ck = \u0022FLFVAEAIYK\u0022 || (snd \u003E\u003E fst) ck = \u0022EVTLGFVDLMR\u0022))\n|\u003E fun x -\u003E x.Print()\n\nlabelEfficiencyResults\n\n(***include-it***)\n\n(**\nIn the following we define helper functions and record types to increase readability/accessability for our code.\n*)\n\n// Code block 6\n\nopen Isotopes\nopen Elements\n\nlet initlabelN15Partial n15Prob =\n    ///Diisotopic representation of nitrogen with abundancy of N14 and N15 swapped\n    let n14Prob = 1. - n15Prob\n    let N15 = Di (createDi \u0022N15\u0022 (Isotopes.Table.N15,n15Prob) (Isotopes.Table.N14,n14Prob) )\n    fun f -\u003E Formula.replaceElement f Elements.Table.N N15\n\n//let labelFullN15 =\n//    let N15 = Elements.Table.Heavy.N15\n//    fun f -\u003E Formula.replaceElement f Elements.Table.N N15\n\nlet generateIsotopicDistributionOfFormulaBySum (charge:int) (f:Formula.Formula) =\n    IsotopicDistribution.MIDA.ofFormula \n        IsotopicDistribution.MIDA.normalizeByProbSum\n        0.01\n        0.001\n        charge\n        f\n\nlet generateIsotopicDistributionOfFormulaByMax (charge:int) (f:Formula.Formula) =\n    IsotopicDistribution.MIDA.ofFormula \n        IsotopicDistribution.MIDA.normalizeByMaxProb\n        0.01\n        0.001\n        charge\n        f\n\ntype LabelEffCollector = \n    {\n        Dilution: float\n        N15Minus1Quant: float\n        N15Quant:float\n        N15Minus1MOverZ: float\n        N15MOverZ: float\n    }\n    \n    static member create n15Minus1quant n15quant n15Minus1MOverZ n15MOverZ dilution = {\n        Dilution            = dilution\n        N15Minus1Quant      = n15Minus1quant\n        N15Quant            = n15quant\n        N15Minus1MOverZ     = n15Minus1MOverZ\n        N15MOverZ           = n15MOverZ\n    }\n    \ntype LabelEffCollectorLinearity = \n    {\n        Dilution        : float []\n        N14ToN15Quant   : float []\n        Protein         : string\n        Peptide         : string\n        Charge          : int\n        PCoEff          : Vector\u003Cfloat\u003E option\n        PFitVals        : float [] option\n        PDetermination  : float option\n    }\n    \n    static member create dil n14n15 prot pept charge coeff fitvals deter =\n        {\n            Dilution        = dil\n            N14ToN15Quant   = n14n15\n            Protein         = prot\n            Peptide         = pept \n            Charge          = charge\n            PCoEff          = coeff\n            PFitVals        = fitvals\n            PDetermination  = deter\n        }\n\n(**\n## Verify Limit of Detection\n\u0060getLabelData\u0060 filters the data for the given dilutions and returns relative quantifications for each peptide. \nAdditionally, it also tells us the corresponding protein and the charge of the peptide.\n*)\n\n// Code block 7\n\nlet dilutionArr = [|0.00032;0.0016;0.008;0.04;0.2;1.|]\n\nlet getLabelData dilutionArr= \n    labelEfficiencyResults\n    // drop all columns with missing values\n    |\u003E Frame.dropSparseCols\n    // filter for dilutions of interest\n    |\u003E Frame.filterRows (fun (prot,(_,(fileName,dilution))) rs -\u003E Array.exists (fun x -\u003E x = dilution) dilutionArr)\n    // break frame format and start working on arrays\n    |\u003E fun x -\u003E \n        x\n        |\u003E Frame.toArray2D\n        |\u003E Array2D.toJaggedArray\n        |\u003E JaggedArray.transpose\n        |\u003E Array.zip (x.ColumnKeys |\u003E Array.ofSeq)\n        //Calculate fully/uncompletely labeled peak ratio\n        |\u003E Array.map \n            (fun ((prot,(pepSeq,charge)),values) -\u003E \n                // we use multiple dilutions of 15N and we can calculate a label efficiency for each of them and\n                // take the mean in the end, as all originate from the same QProtein sample. This could also\n                // show differences in measured label efficiency for high or low sample quantities.\n                let quant, dil =\n                    Array.init\n                        dilutionArr.Length\n                        (fun ind -\u003E\n                            [|for num in ind .. dilutionArr.Length .. values.Length-1 do\n                                yield values.[num]|]\n                        )\n                    |\u003E Array.mapi (fun i values -\u003E \n                        // 14N/15N, dilution\n                        values.[0]/values.[4], 1./dilutionArr.[i]\n                    )\n                    |\u003E Array.sortBy snd\n                    |\u003E Array.unzip\n                LabelEffCollectorLinearity.create dil quant prot pepSeq charge None None None\n            )\n    \n/// DO NOT CHANGE THIS NAME! This value will be used in further code blocks.\n/// Insert a dilution array with the dilutions you want to include\nlet labelData = getLabelData dilutionArr\n\n// This part is only meant to show you the current state of your data  \nlabelData\n\n(***include-it***)\n\n(**\n### Pearson correlation coefficient\nTesting the limit of detection can be done with a dilution array and the [pearson coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient).\n As you should assume a rather low pipetting error you can check the mass spectrometry detection for all \n QProtein peptides with this experiment. If for any peptide the pearson coefficient is not high (so the relation would be non-linear) \n the mass spectrometry was not able to detect the small quantities for some of the given dilutions and therefore underestimated the real amount of QProtein.\n*)\n\n// Code block 8\n\n// Use the \u0022labelData\u0022 to calculate the pearson coefficient for the measured data points for all dilutions for each peptide\nlet lEInfo =\n    labelData\n    |\u003E Array.map (fun peptVal -\u003E\n        peptVal.N14ToN15Quant\n        |\u003E fun strainVals -\u003E\n            // RBCL Regression of relative quantification values\n            let RBCLcoeff = Univariable.coefficient (vector peptVal.Dilution) (vector strainVals)\n            let RBCLfitFunc = Univariable.fit RBCLcoeff\n            let RBCLfitVals = peptVal.Dilution |\u003E Array.map RBCLfitFunc\n            let RBCLdetermination = FSharp.Stats.Fitting.GoodnessOfFit.calculateDeterminationFromValue strainVals RBCLfitVals\n            let RBCLpearson = FSharp.Stats.Correlation.Seq.pearson strainVals peptVal.Dilution\n            printfn \u0022Pearson WholeCell [%s]-%s @ z=%i: %f\u0022 peptVal.Protein peptVal.Peptide peptVal.Charge RBCLpearson\n            {peptVal with \n                PCoEff = Some RBCLcoeff; \n                PFitVals = Some RBCLfitVals; \n                PDetermination = Some RBCLdetermination}\n    )\n\nlEInfo\n\n(***include-it***)\n\n(**\nThose graphs shows the linearity of the peptides for our protein by displaying the single data points and their linear fit.\n*)\n\n// Code block 9\n\nlet showLinearity  =\n\n    lEInfo\n    |\u003E Array.groupBy (fun x -\u003E x.Protein)\n    |\u003E Array.map (fun (_,valArr) -\u003E\n        valArr\n        |\u003E Array.map (fun peptVal -\u003E\n            [\n                Chart.Point (Array.zip peptVal.Dilution peptVal.N14ToN15Quant,Name = sprintf \u0022[%s]-%s @z=%i Quantified Ratios\u0022 peptVal.Protein peptVal.Peptide peptVal.Charge)\n                |\u003E Chart.withMarkerStyle(Size=10,Symbol = StyleParam.Symbol.Cross)\n                Chart.Line(Array.zip peptVal.Dilution peptVal.PFitVals.Value,Name = (sprintf \u0022%s linear regression: %.2f x \u002B (%2f);\u003Cbr\u003E R\u003Csup\u003E2\u003C/sup\u003E = %.4f\u0022 peptVal.Peptide peptVal.PCoEff.Value.[1] peptVal.PCoEff.Value.[0] peptVal.PDetermination.Value))\n                |\u003E Chart.withLineStyle(Color=\u0022lightblue\u0022,Dash=StyleParam.DrawingStyle.DashDot)\n            ] \n            |\u003E Chart.Combine\n        )\n        |\u003E Chart.Combine\n        |\u003E Chart.withTitle ((Array.head valArr).Protein \u002B \u0022 N15 QProtein Dilution\u0022)\n        |\u003E Chart.withY_Axis (yAxis false \u0022N14 / N15 Peak instensity ratio\u0022 20 16)\n        |\u003E Chart.withX_Axis (xAxis false \u0022Dilution of N15 Q Protein\u0022 20 16)\n        |\u003E Chart.withConfig config\n        |\u003E Chart.withMargin (Margin.init(Right=400))\n        |\u003E Chart.withSize (900.,600.)\n    )\n    \nshowLinearity\n|\u003E Array.head\n\n(***hide***)\nshowLinearity |\u003E Array.head |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Calculate Label Efficiency\n\u0060prepareLabelEfficiencyResults\u0060 extracts all the information needed for label efficiency determination from our read-in mass \nspectrometry results for the given dilutions.\n*)\n\n// Code block 10\n\nlet prepareLabelEfficiencyResults (dilutionArr:float []) =\n    labelEfficiencyResults\n    |\u003E Frame.filterRows \n        (fun (rk,_) _ -\u003E not (rk.Contains(\u0022N14\u0022)))\n    |\u003E Frame.dropSparseCols\n    |\u003E fun x -\u003E \n        x\n        |\u003E Frame.toArray2D\n        |\u003E Array2D.toJaggedArray\n        |\u003E JaggedArray.transpose\n        |\u003E Array.zip (x.ColumnKeys |\u003E Array.ofSeq)\n        //Calculate fully/uncompletely labeled peak ratio\n        //|\u003E Array.find (fun x -\u003E (fst \u003E\u003E fst) x = \u0022rbcL\u0022)\n        |\u003E Array.map \n        //|\u003E\n            (fun (key,values) -\u003E \n                key,\n                // we use multiple dilutions of N15 and we can calculate a label efficiency for each of them and\n                // take the mean in the end, as all originate from the same QProtein sample. This could also\n                // show differences in measured label efficiency for high or low sample quantities.\n                Array.init\n                    dilutionArr.Length\n                    (fun ind -\u003E\n                        [|for num in ind .. dilutionArr.Length .. values.Length-1 do\n                            yield values.[num]|]\n                    )\n                |\u003E Array.mapi (fun i values -\u003E \n                    LabelEffCollector.create values.[1] values.[3] values.[0] values.[2] dilutionArr.[i]\n                )\n            )\n            \nlet preparedLabelEfficiencyResults =\n    prepareLabelEfficiencyResults dilutionArr\n\npreparedLabelEfficiencyResults\n|\u003E Array.head\n\n(***include-it***)\n\n(**\nHere MIDAS calculates a label efficiency with corresponding isotopic distribution for our peptides.\n*)\n\n// Code block 11\n\n// This function may take several minutes with up to an hour depending on the number of peptides and dilutions of interest\n// Here, theoretical isotopic spectra are created and compared with the measured spectra.\nlet labelEfficiency =\n    preparedLabelEfficiencyResults\n    |\u003E Array.collect \n        (fun ((prot,(peptideSequence,charge)),labelEffCollectorArr) -\u003E\n\n            let calculateLabelEffs (labelEffCollect:LabelEffCollector) =\n            \n                // ratio between the N15 peak and the N15-1 peak\n                let peakRatio = labelEffCollect.N15Minus1Quant / labelEffCollect.N15Quant\n                //printfn \u0022peakRatio: %A\u0022 peakRatio\n                \n                // get chemical information about petide sequence\n                let peptide =\n                    peptideSequence\n                    |\u003E BioArray.ofAminoAcidString\n                    |\u003E BioSeq.toFormula\n                //printfn \u0022peptide: %A\u0022 peptide\n\n                // create theoretical isotopic distributions for label efficiency 0.5 .. 0.001 .. 0.999\n                let theoreticalIsotopicDistributions =\n                    [for le in 0.5 .. 0.001 .. 0.999 do\n                         yield\n                             le,\n                             peptide\n                             |\u003E initlabelN15Partial le\n                             |\u003E Formula.add Formula.Table.H2O\n                             |\u003E generateIsotopicDistributionOfFormulaByMax charge\n                    ]\n\n                \n                let theoreticalRatios =\n                    theoreticalIsotopicDistributions\n                    // get all theoretical probabilities for the N15 and N15-1 peak\n                    |\u003E List.map \n                        (fun (le,dist) -\u003E\n                            let n15Prob = \n                                dist\n                                // get the value from the list, for which the theoretical mz is closest to the\n                                // measured m/z\n                                |\u003E List.minBy \n                                    (fun (mz,prob) -\u003E\n                                        abs (labelEffCollect.N15MOverZ - mz)\n                                    )\n                                // get probabilitie for the closest theoretical peak\n                                |\u003E snd\n                            \n                            let n15Minus1Prob = \n                                dist\n                                // get the value from the list, for which the theoretical mz is closest to the\n                                // measured m/z\n                                |\u003E List.minBy \n                                    (fun (mz,prob) -\u003E\n                                        //old: abs (n15Minus1MZ - mz)\n                                        abs (labelEffCollect.N15Minus1MOverZ - mz)\n                                    )\n                                // get probabilitie for the closest theoretical peak\n                                |\u003E snd\n                            // return le and dist and the theoretical probability (n15Minus1Prob / n15Prob)\n                            le,(n15Minus1Prob / n15Prob), dist\n                        )\n\n                // get the theoretical le,ratio,dist that features the lowest difference in N15-1/N15 \n                // peak ratio between the theoretical and the measured distributions\n                let bestLE = \n                    theoreticalRatios\n                    |\u003E List.minBy\n                        (fun (le,ratio,dist) -\u003E\n                            abs (peakRatio - ratio)\n                        )\n                // header information about protein, peptide, charge\n                (prot,(peptideSequence,charge)),\n                // LabelEffCollector Record type; saved information from measured data\n                labelEffCollect,\n                // found best fitting theoretical le, ratio and isotopic distribution\n                bestLE\n            labelEffCollectorArr\n            |\u003E Array.map calculateLabelEffs\n        )\n\nlabelEfficiency |\u003E Array.head\n\n(***include-it***)\n\n(**\n### Median Label Efficiency\nIn the following, we will determine outlier borders for our calculated label efficiencies. \nWe will do this via [tukey outlier calculation](https://en.wikipedia.org/wiki/Outlier).\n*)\n\n// Code block 12\n\n// Drop all information except protein, peptide, dilution and le.\nlet allPredictedLE =\n    labelEfficiency\n    |\u003E Array.map \n        (fun ((prot,(peptideSequence,charge)),experimentalDist,(le,ratio,dist)) -\u003E\n            (prot,peptideSequence,experimentalDist.Dilution),le\n        )\n        \n// calculate outlier borders with tukey (n=3)\nlet outlierBorders = FSharp.Stats.Testing.Outliers.tukey 3. (allPredictedLE |\u003E Array.map snd)\n\nallPredictedLE\n\n(***include-it***)\n\noutlierBorders\n\n(***include-it***)\n\n// Code block 13\n\n//Boxplot with outlier borders\nlet showLEsBoxPlot =\n    allPredictedLE\n    |\u003E Array.unzip\n    |\u003E fun (header,leValues) -\u003E \n        [\n            Chart.BoxPlot(\n                x = (\n                    allPredictedLE\n                    |\u003E Array.filter (fun (keys,eff) -\u003E eff \u003C outlierBorders.Upper \u0026\u0026 eff \u003E outlierBorders.Lower)\n                    |\u003E Array.map snd\n                ),\n                Jitter = 0.3,\n                Boxpoints=StyleParam.Boxpoints.All,\n                Name=\u0022Measured Label \u003Cbr\u003E Efficiencies\u0022\n                )\n            Chart.BoxPlot(x=leValues,Jitter = 0.3,Boxpoints=StyleParam.Boxpoints.All,Name=\u0022Measured Label \u003Cbr\u003E Efficiencies - \u003Cbr\u003E without outliers\u0022)\n            |\u003E Chart.withShapes \n                [\n                    (Shape.init(StyleParam.ShapeType.Line, X0 = outlierBorders.Upper, X1 = outlierBorders.Upper, Y0 = -0.4, Y1 = 1.4))\n                    (Shape.init(StyleParam.ShapeType.Line, X0 = outlierBorders.Lower, X1 = outlierBorders.Lower, Y0 = -0.4, Y1 = 1.4))\n                ]\n        ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_Axis (yAxis false \u0022N15 / N15 - 1 m/z Peak instensity ratio\u0022 20 16)\n    |\u003E Chart.withY_Axis (xAxis false \u0022\u0022 20 16)\n    |\u003E Chart.withMargin (Margin.init(Left=200))\n    |\u003E Chart.withTitle \u0022Label efficiency - Outlier detection\u0022\n    // adjust chart size\n    |\u003E Chart.withSize (1200.,600.)\n    |\u003E Chart.withConfig config\n\n// You can use this function to find peptides of a specific LE of interest, which you found on the box blot.\nlet findPeptideOfLE le =\n    let foundVals =\n        allPredictedLE\n        |\u003E Array.filter (fun x -\u003E snd x = le)\n    if foundVals |\u003E Array.isEmpty then failwithf \u0022We could not find any label efficiency at the given value: %.3f\u0022 le\n    else foundVals\n\nfindPeptideOfLE 0.972 \n\n(***include-it***)\n\n///// Use this function for an added description below the chart\n//showLEs\n//|\u003E Chart.ShowWithDescription\n//    {Heading = \u0022Borders From tukey outlier detection with k = 3:\u0022; Text = sprintf \u0022Upper: %.3f \u003Cbr\u003E\u003C/br\u003ELower: %.3f\u0022 outlierBorders.Upper outlierBorders.Lower}\n\nshowLEsBoxPlot\n\n(***hide***)\nshowLEsBoxPlot |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n// Code block 14\n\n// Calculate the median label efficiency for all LE inside the borders given by the tukey outlier test\nlet filteredOverallPredictedLabelEfficiency =\n    allPredictedLE\n    |\u003E Array.filter (fun (keys,eff) -\u003E eff \u003C outlierBorders.Upper \u0026\u0026 eff \u003E outlierBorders.Lower)\n    |\u003E Array.map snd\n    |\u003E Seq.median \n\nfilteredOverallPredictedLabelEfficiency\n\n(***include-it***)\n\n(**\n## Midas Results\nFrom here on you will find functions for charts displaying midas results on a single peptide basis. \nThe two available options differ in complexity and it is not necessary to understand 100% of the code used. \nBut it can be useful to change parameters for the chart creation and adjust them for your needs.\n*)\n(**\n### Midas Results Var 1\nThis Variant shows basic information to the midas label efficiency calculation for all peptides of any protein.\n*)\n\n// Code block 15\n\nlet showLabelEfficiencyChartsSimple =\n    labelEfficiency\n    |\u003E Array.groupBy (fun ((prot,(peptideSequence,charge)),experimentalDist,(le,ratio,dist)) -\u003E prot,peptideSequence,charge)\n    |\u003E Array.map (\n        fun ((prot,peptideSequence,charge),arr) -\u003E\n            prot,\n            peptideSequence,\n            arr\n            |\u003E Array.sortByDescending (fun ((prot,(peptideSequence,charge)),experimentalDist,(le,ratio,dist)) -\u003E experimentalDist.Dilution)\n            |\u003E Array.map (fun ((prot,(peptideSequence,charge)),experimentalDist,(le,ratio,dist)) -\u003E\n                let normExperimental =\n                    experimentalDist\n                    |\u003E fun x -\u003E\n                        List.zip\n                            [x.N15Minus1MOverZ;x.N15MOverZ]\n                            (\n                                [x.N15Minus1Quant; x.N15Quant]\n                                |\u003E fun vals -\u003E \n                                    let max = List.max vals\n                                    vals\n                                    |\u003E List.map (fun v -\u003E v / max)\n                            )\n                [\n                    dist\n                    |\u003E List.map (fun (x,y) -\u003E [(x,0.);(x,y);(x,0.)])\n                    |\u003E List.concat\n                    |\u003E Chart.Line\n                    |\u003E Chart.withTraceName (sprintf \u0022[%s] %s : PID @ %.3f \u0022 prot peptideSequence le)\n                    Chart.Point(normExperimental,Name= sprintf \u0022[%s] %s : Experimental Masses 1 to %s\u0022  prot peptideSequence (string experimentalDist.Dilution))\n                ]\n                |\u003E Chart.Combine\n                |\u003E Chart.withTitle (sprintf \u0022[%s] : %s @ \u002B %i\u0022 prot peptideSequence charge )\n                |\u003E Chart.withX_Axis (xAxis false \u0022\u0022 20 16)\n                |\u003E Chart.withY_Axis (yAxis false \u0022\u0022 20 16)\n                |\u003E Chart.withConfig config \n            )\n        )\n        |\u003E Array.map ( fun (prot,pepSeq,charts) -\u003E\n            charts\n            |\u003E Chart.Stack charts.Length\n            |\u003E Chart.withSize (1500.,600.)\n        )\n        \nshowLabelEfficiencyChartsSimple\n|\u003E Array.head \n\n(***hide***)\nshowLabelEfficiencyChartsSimple |\u003E Array.head |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n### Midas Results Var 2\nThe following code is used to generate in depth charts with most information about the midas calculation.\nIf [variant 1](#Midas-Results-Var-1) does not contain enough information, this variant can be used instead.\n*)\n\n// Code block 16\n\ntype LabelEfficiencyPredictor =\n    {\n        Protein: string\n        PeptideSequence: string\n        Charge: int\n        PredictedDistribution: (float*float) list\n        PredictedLabelEfficiency: float\n        ExperimentalDistribution: (float*float) list\n        EFCollector: LabelEffCollector\n    }\n\nlet createLabelEfficiencyPredictor p ps c pred eff exp efCollector=\n    {\n        Protein                     = p\n        PeptideSequence             = ps\n        Charge                      = c\n        PredictedDistribution       = pred\n        PredictedLabelEfficiency    = eff\n        ExperimentalDistribution    = exp\n        EFCollector                 = efCollector\n    }\n\n\ntype LabelEfficiencyResult =\n    {\n        Protein                 : string\n        PeptideSequence         : string\n        Charge                  : int\n        PredictedLabelEfficiency: float\n        PredictedPattern        : (float*float) list\n        ActualPattern           : (float*float) list\n        MedianLabelEfficiency   : float\n        MedianPattern           : (float*float) list\n        FullLabeledPattern      : (float*float) list\n        CorrectionFactor        : float\n        EFCollector             : LabelEffCollector\n    }\n\nlet createLabelEfficiencyResult p ps c predLE predP aP mLE mP flP cf efCollector=\n    {\n        Protein                     = p\n        PeptideSequence             = ps\n        Charge                      = c\n        PredictedLabelEfficiency    = predLE\n        PredictedPattern            = predP\n        ActualPattern               = aP\n        MedianLabelEfficiency       = mLE\n        MedianPattern               = mP\n        FullLabeledPattern          = flP\n        CorrectionFactor            = cf\n        EFCollector                 = efCollector\n    }\n\n// Code block 17\n\nlet labelEfficiencyResultsFinalPre =\n    labelEfficiency\n    |\u003E Array.map \n        (fun ((prot,(peptideSequence,charge)),experimentalDist,(le,ratio,dist)) -\u003E\n            let prepExperimentalDist =\n                [\n                    experimentalDist.N15Minus1MOverZ, experimentalDist.N15Minus1Quant;\n                    experimentalDist.N15MOverZ, experimentalDist.N15Quant\n                ]\n            createLabelEfficiencyPredictor prot peptideSequence charge dist le prepExperimentalDist experimentalDist\n        )\nlabelEfficiencyResultsFinalPre\n|\u003E Array.head\n\n(***include-it***)\n\n// Code block 18\n\nlet getCorrectionFactors (medianPredictedLabelEfficiency:float) (predictors: LabelEfficiencyPredictor []) =\n    predictors\n    |\u003E Array.map \n       (fun lePredictor -\u003E\n\n           let n15Minus1Mz, n15Minus1Quant =\n               lePredictor.ExperimentalDistribution.[0]\n\n           let n15Mz, n15Quant =\n               lePredictor.ExperimentalDistribution.[1]\n\n           let formulaWithH2O =\n               lePredictor.PeptideSequence\n               |\u003E BioArray.ofAminoAcidString\n               |\u003E BioSeq.toFormula\n               |\u003E Formula.add Formula.Table.H2O\n\n           let predictedWithMedianLE =\n               formulaWithH2O\n               |\u003E initlabelN15Partial medianPredictedLabelEfficiency\n               |\u003E generateIsotopicDistributionOfFormulaBySum lePredictor.Charge\n\n           let predictedWithMedianLENorm = \n               formulaWithH2O\n               |\u003E initlabelN15Partial medianPredictedLabelEfficiency\n               |\u003E generateIsotopicDistributionOfFormulaByMax lePredictor.Charge\n\n           let predictedWithFullLE = \n               formulaWithH2O\n               |\u003E initlabelN15Partial 0.99999\n               |\u003E generateIsotopicDistributionOfFormulaBySum lePredictor.Charge\n\n           let predictedWithFullLENorm =\n               formulaWithH2O\n               |\u003E initlabelN15Partial 0.99999\n               |\u003E generateIsotopicDistributionOfFormulaByMax lePredictor.Charge\n\n           let n15ProbWithMedianLE =\n               predictedWithMedianLE\n               |\u003E List.minBy   \n                   (fun (mz,prob) -\u003E abs (mz - n15Mz))\n\n           let n15ProbWithFullLE =\n               predictedWithFullLE\n               |\u003E List.minBy   \n                   (fun (mz,prob) -\u003E abs (mz - n15Mz))\n\n           let correctionFactor = \n               snd n15ProbWithFullLE / snd n15ProbWithMedianLE\n\n           createLabelEfficiencyResult\n               lePredictor.Protein\n               lePredictor.PeptideSequence\n               lePredictor.Charge\n               lePredictor.PredictedLabelEfficiency\n               lePredictor.PredictedDistribution\n               (\n                   lePredictor.ExperimentalDistribution\n                   |\u003E List.unzip\n                   |\u003E fun (x,y) -\u003E\n                       List.zip\n                           x\n                           (\n                               y\n                               |\u003E fun vals -\u003E \n                                   let max = List.max vals\n                                   vals\n                                   |\u003E List.map (fun v -\u003E v / max)\n                           )\n               )\n               medianPredictedLabelEfficiency\n               predictedWithMedianLENorm\n               predictedWithFullLENorm\n               correctionFactor\n               lePredictor.EFCollector\n       )\n       \nlet labelEfficiencyResultsFinal =\n    labelEfficiencyResultsFinalPre\n    |\u003E getCorrectionFactors filteredOverallPredictedLabelEfficiency\n    \nlabelEfficiencyResultsFinal\n|\u003E Array.head\n\n(***include-it***)\n\n// Code block 19\n\nlet plotLabelEfficiencyResult (leRes: LabelEfficiencyResult) =\n    [\n        leRes.FullLabeledPattern\n        |\u003E List.map (fun (x,y) -\u003E [(x,0.);(x,y);(x,0.)])\n        |\u003E List.concat\n        |\u003E Chart.Line\n        |\u003E Chart.withTraceName (sprintf \u0022Dil=%s; Fully Labeled Pattern\u0022 (string leRes.EFCollector.Dilution))\n        |\u003E Chart.withLineStyle(Color=\u0022lightgray\u0022,Width = 20)\n\n        leRes.MedianPattern\n        |\u003E List.map (fun (x,y) -\u003E [(x,0.);(x,y);(x,0.)])\n        |\u003E List.concat\n        |\u003E Chart.Line\n        |\u003E Chart.withTraceName (sprintf \u0022Dil=%s; CorrectedPattern @ Median LE of %.3f\u0022 (string leRes.EFCollector.Dilution) leRes.MedianLabelEfficiency)\n        |\u003E Chart.withLineStyle(Width = 10,Color=\u0022lightgreen\u0022)\n\n        leRes.PredictedPattern\n        |\u003E List.map (fun (x,y) -\u003E [(x,0.);(x,y);(x,0.)])\n        |\u003E List.concat\n        |\u003E Chart.Line\n        |\u003E Chart.withTraceName (sprintf \u0022Dil=%s; PredictedPattern @ %.3f LE\u0022 (string leRes.EFCollector.Dilution) leRes.PredictedLabelEfficiency)\n        |\u003E Chart.withLineStyle(Color=\u0022orange\u0022,Width = 5)\n\n        Chart.Point(leRes.ActualPattern,Name=sprintf \u0022Dil=%s; Experimental Values\u0022 (string leRes.EFCollector.Dilution))\n        |\u003E Chart.withMarkerStyle(Size = 15,Symbol = StyleParam.Symbol.X, Color = \u0022lightred\u0022)\n\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_Axis \n        (xAxis false (sprintf \u0022m/z for Dilution = %s\u0022 (string leRes.EFCollector.Dilution)) 20 16 )\n    |\u003E Chart.withY_Axis (yAxis false \u0022normalized probability\u0022 20 16)\n    |\u003E Chart.withConfig config\n\nlet showLabelEfficiencyResults =\n    labelEfficiencyResultsFinal\n    |\u003E Array.groupBy (fun x -\u003E x.Protein, x.PeptideSequence, x.Charge)\n    |\u003E Array.map (fun (header,pepSortedVals) -\u003E\n        let header = Array.head pepSortedVals\n        pepSortedVals\n        |\u003E Array.sortByDescending (fun x -\u003E x.EFCollector.Dilution)\n        |\u003E Array.map plotLabelEfficiencyResult\n        |\u003E Chart.Stack ((pepSortedVals.Length/2),Space=0.1)\n        |\u003E Chart.withTitle (sprintf \u0022[%s] : %s @ z = %i\u0022 header.Protein header.PeptideSequence header.Charge)\n        |\u003E Chart.withSize (1400.,1000.)\n    )\n    \nshowLabelEfficiencyResults\n|\u003E Array.head\n\n(***hide***)\nshowLabelEfficiencyResults |\u003E Array.head |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n// Code block 20\n\nlet labelEfficiencyFrame =\n    labelEfficiencyResultsFinal\n    |\u003E Array.map \n        (fun leRes -\u003E\n            (leRes.Protein,(leRes.PeptideSequence, leRes.Charge, leRes.EFCollector.Dilution)) =\u003E \n                series \n                    [\n                        \u0022PredictedLabelEfficiency\u0022      =\u003E leRes.PredictedLabelEfficiency\n                        \u0022MedianLabelEfficiency\u0022         =\u003E leRes.MedianLabelEfficiency\n                    ]\n        )\n    |\u003E frame\n    |\u003E Frame.transpose\n    \nlabelEfficiencyFrame\n\n(***include-it***)"},{"uri":"/BIO-BTE-06-L-7/JP00_Systems_Biology_FSharp_Introduction.html","title":"JP00 Systems Biology\n","content":"(**\n# JP00 Systems Biology\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP00_Systems_Biology_FSharp_Introduction.ipynb)\n\n\nThis notebook introduces the field of Systems Biology and explains why programming is a necessary skill to it. You will get a short introduction to the programming language F# and some links to resource for further studies.\n\n1. Systems Biology: A brief introduction\n2. Starting with FSharp\n    1. Functions\n    2. Binding function values and simple values\n        1. Side note: Lambda expressions\n    3. Simple values\n    4. Lists \u0026 Arrays\n    5. Higher-order functions\n        1. Side Note: Pipe-forward operator |\u003E\n    6. Control flow expressions\n        1. if-then-else\n        2. Pattern Matching\n    7. Complex Data Types\n        1. Tuples\n        2. Record Types\n    8. Code organization\n        1. Namespaces and modules\n        2. Comments\n3. References\n\n## Systems Biology: A brief introduction\n\n\nThe term \u201Csystems theory\u201D was introduced by the biologist L. von Bertalanffy. He defined a system as a set of related components that work together in a particular environment to perform whatever \nfunctions are required to achieve the system\u0027s objective (Bertalanffy 1945). The hierarchical organization orchestrating the interaction of thousands of molecules with individual \nproperties allows complex biological functions. Biological processes like cell division, biomass production, or a systemic response to perturbations are molecular physiological functions \nwhich result from a complex dynamic interplay between genes, proteins and metabolites (Figure 1). To gain a holistic understanding of a biological system, all parts of the \nsystem need to be studied simultaneously by quantitative measures (Sauer et al. 2007). The focus on a system-wide perspective lies on the quantitative understanding of the \norganizational structure, functional state, robustness and dynamics of a biological system and led to the coining of the term \u201CSystems Biology\u201D(Kitano 2002a).\n\nThe current challenges of Systems Biology approaches are mainly along four lines (Sauer et al. 2007, Joyce and Palsson 2006): \n\n - (**i**) - system-wide quantification of transcriptome, proteome (including protein modifications) and metabolome\n \n - (**ii**) - identification of physical interactions between these components\n \n - (**iii**) - inference of structure, type and quantity of found interactions\n \n - (**iv**) - analysis and integration of the resulting large amounts of heterogeneous data. It becomes obvious that an interdisciplinary effort is needed to resolve these challenges in Systems Biology (Aderem 2006). Here Biology dictates which analytical, experimental and computational methods are required.\n\nModern analytical methods to measure the identity and quantity of biomolecules system-wide, summarized under the term \u201Cquantitative omics\u201D-technologies, address the first two \nmentioned challenges of Systems Biology. Among these \u201Comics\u201D-technologies are transcriptomics based on microarrays/next generation sequencing and proteomics/metabolomics based on mass-spectrometry.\n\nTying in with the area of genome sequencing, the focus is set on the accurate profiling of gene/protein expression and metabolite concentrations, as well as on the determination of biological \nprotein modifications and of physical interactions between proteins.\n\nAddressing the abovementioned challenges three and four of Systems Biology, the development of numerous computational approaches reaches out to unravel the \nintrinsic complexity of biological systems (Kahlem and Birney 2006). These computational approaches focus on knowledge discovery and on in silico \nsimulation or modeling (Kitano 2002b). In the latter approach knowledge on a biological process is converted into a mathematical model. \nIn silico simulations based on such a model can provide predictions that may subsequently be tested experimentally. Computation-based knowledge discovery \n(also known as data mining) aims to extract hidden patterns from complex and high-dimensional data to generate hypotheses. Therefore, the first step is to describe \ninformation on a biological system such that it is sustainably stored in a format rendering it readable and manipulable for machines and humans. The second step is \nto integrate the huge amount of differently structured data, often referred to as the \u201Cbig data\u201D challenge. In a last step, statistical or machine learning methods \nare applied to extract the information or underlying principles hidden in the data.\n\nThe most flexible way of working with huge amounts of data is using a lightweight programming language with a succinct syntax. Therefore, it becomes necessary that biologist become familiar with a suitable programming language to solve real world problems in (Systems) Biology.\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/OmicSpace.png)\n***Figure 1: A conceptual view of the omic space.***\n\nThe omics space comprises of genomic, transcriptomic, proteomic, metabolomic and phenomic systems level represented as a plane. Complex biological function is the result of the interplay between molecules of one and/or different systems level.\n\n## Starting with FSharp\n\n\nF# (pronounced \u201CF Sharp\u201D) is a simple and expressive programming language. It can be described as statically typed impure functional language that supports functional, \nimperative and object-oriented paradigm and also several other programming styles including data-driven, event-driven and parallel programming. \nThis makes it an excellent tool for introducing programming as well as programming paradigms.\n\nF# is supported by the [F# Software Foundation](http://fsharp.org) and a worldwide community of contributors. Microsoft and other companies \ndevelop professional tooling for F#. The [F# Language Reference](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/) is a reference for \nthe F# language, and the [F# Guide](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/) covers general topics. There are lots of excellent \n[F# learning resources](http://fsharp.org/learn.html) available online.\n   \nTo learn more about how to use Jupyter notebooks, see the [Jupyter documentation](http://jupyter-notebook.readthedocs.io/) and the [Jupyter keyboard shortcuts](https://www.cheatography.com/weidadeyue/cheat-sheets/jupyter-notebook/). You can find more information baoutthe F# and Jupyter tooling locally using [IfSharp](https://github.com/fsprojects/IfSharp).\n  \nWith the help of the following FSharp coding information/examples, you will be able to solve all exercises in *JP01_FSharpExcercises.ipynb*!\n   \nLet\u0027s start with our basic introduction:\n\n## Functions\n\nThe impetus behind functional programming comes from mathematics. Mathematical functions have a number of very nice features that functional languages try to emulate in the real world.\nSo first, let\u2019s start with a mathematical function that adds 1 to a number.\n\n\u0060\u0060\u0060\nAdd1(x) = x\u002B1\n\u0060\u0060\u0060\n\nWhat does this really mean? Well it seems pretty straightforward. It means that there is an operation that starts with a number, and adds one to it.\n   \n**Let\u2019s introduce some terminology:**\n\n - The set of values that can be used as input to the function is called the domain. In this case, it could be the set of real numbers, but to make life simpler for now, let\u2019s restrict it to integers only.\n\n - The set of possible output values from the function is called the range (technically, the image on the codomain). In this case, it is also the set of integers.\n\n - The function is said to map the domain to the range.\n\nA diagram of a general function would be:\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/function.png)\n***Figure 2: diagram of a general function***\n\n\n## Binding function values and simple values\n\nThe process of using a name to represent a function or a value is called \u201Cbinding\u201C. A binding is done by using the \u0060let\u0060 keyword in F#. Let\u2019s look at the simple function we used previously:\n\n*)\n\nlet add1 x = x \u002B 1\n// evaluate\nadd1\n\n(**\n\u0060\u0060\u0060\nval add1: \n   x: int \n   -\u003E int\n\u0060\u0060\u0060\n\nWhat does the \u201Cx\u201D mean here? It means:\n\n - Accept some value from the input domain.\n\n - Use the name \u201Dx\u201D to represent that value so that we can refer to it later. The name \u201Cx\u201D is \u0022bound\u0022 to the input value. So if we evaluate the function with the input 5 say, what is happening is that everywhere we see \u201Cx\u201D in the original definition, we replace it with \u201C5\u201D, sort of like search and replace in a word processor\n\n*)\n\nadd1 5\n// replace \u0022x\u0022 with \u00225\u0022\n// add1 5 = 5 \u002B 1 = 6\n// result is 6\n\n(***include-it***)\n\n(**\nIf you think about this a bit more, you will see that the name \u0060add1\u0060 itself is just a binding to _the function that adds one to its input_. \nThe function itself is independent of the name it is bound to. When you type let \u0060add1\u0060 x = x \u002B 1 you are telling the F# compiler \u201Cevery time you see the name add1, \nreplace it with _the function that adds one to its input_\u201D. \u0060add1\u0060 is called a function value. To see that the function is independent of its name, try:\n*)\n\nlet plus1 = add1\nadd1 5 = plus1 5\n\n(***include-it***)\n\n(**\nYou can see that \u0060add1\u0060 and \u0060plus1\u0060 are two names that refer (\u0022bound to\u0022) to the same function. You can always identify a function value because its signature has the standard form domain \u2192 range. \nHere is a generic function value signature:\n\n\u0060\u0060\u0060\nval functionName : domain -\u003E range\n\u0060\u0060\u0060\n\nSide note: Lambda expressions\n\nIn F# it is possible to use function without giving them a name and use the keyword \u0060fun\u0060 instead and the \u0060=\u0060 becomes \u0060-\u003E\u0060. \nThis is called anonymous function, or - referring to lambda calculus - **lambda expression**. This kind of functions are often used for convenience. To write \u0060add1\u0060 as lambda expression:\n*)\n\nfun x -\u003E x \u002B 1\n\n(**\n## Simple values\n\n![](img/valueBinding.png)\n      \nImagine an operation that always returned the integer 5 and didn\u2019t have any input.\n   \nThis would be a \u201Cconstant\u201D operation.\nHow would we write this in F#? We want to tell the F# compiler \u201Cevery time you see the name c, replace it with 5\u201D. Here\u2019s how:\n*)\n\nlet c = 5\n// evaluate\nc\n\n(***include-it***)\n\n(**\nThere is no mapping arrow this time, just a single int. What\u2019s new is an equals sign with the actual value printed after it. The F# compiler knows that this binding has a known value which it will always return, namely the value 5.\nIn other words, we\u2019ve just defined a constant, or in F# terms, a simple value.\n\n## Lists \u0026 Arrays\n\nSquare brackets \u0060[]\u0060 create a list with semicolon \u0060;\u0060 delimiters.\n*)\n\nlet twoToFive = [2; 3; 4; 5]\ntwoToFive\n\n(***include-it***)\n\n(**\n\u0060::\u0060 creates a list with a new element appended to the front of the list.\n*)\n\nlet oneToFive = 1::twoToFive\noneToFive\n\n(***include-it***)\n\n(**\nSquare brackets with dashes \u0060[||]\u0060 create an array with semicolon \u0060;\u0060 delimiters.\n*)\n\nlet oneToFour = [|1; 2; 3; 4|]\n\n(**\nElements can be accessed using dot \u0060.[i]\u0060, where i is the (zero-based) index of the desired element\n*)\n\noneToFour.[0]\n\n(***include-it***)\n\n(**\n_Note_: commas are **never** used as delimiters in collection types, only semicolons!\n\n## Higher-order functions\n\nA higher-order function is a function that takes another function as a parameter. \nThis is simple, but leads to one of the most important concepts of functional programming: The conceptual operation: ***map***\n\nThe higher-order and polytypic function \u0060map\u0060 applies a function working on the normal space to an elevated space.\nThis concept is so important that all collection types (lists, arrays, ...) have a build in \u0060map\u0060 function. \nLet\u0027s look at an example of what that means. Therefore, we first define a function working on the normal space:\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/map.png)\n***Figure 3: A conceptual view of the \u0060map\u0060 concept.***\n*)\n\nlet square x = x * x\n// evaluate\nsquare 3\n\n(***include-it***)\n\n(**\nNow, let\u0027s apply this function to every number in a list.\n*)\n\nList.map square [3;2;6;7]\n\n(***include-it***)\n\n(**\nBe aware, that this concept of mapping is restricted to the actual function called \u0060map\u0060. A \u0060filter\u0060 function, for example, is also the same kind of operation.\n*)\n\nlet evens list =\n   let isEven x = x%2 = 0\n   List.filter isEven list \n   \n//isEven 5      // the value or constructor isEven is not defined. .. this is because it is only defined inside \n                // of the functional scope of \u0060evens\u0060.\n\n(**\nAdditionaly, you can see in this example how to define a multiline function. Just use indents! No \u0060;\u0060 needed.\nDefine \u0060isEven\u0060 as an inner (\u0022nested\u0022) function. In this case the function \u0060isEven\u0060 is defined in the scope of the function \u0060evens\u0060. It cannot be accessed outside of this scope.\n\u0060List.filter\u0060 is a library function with two parameters: a \u0060predicate\u0060 function, returning \u0060true\u0060 or \u0060false\u0060 depending on the input - and a \u0060list\u0060 to work on.\n*)\n\nevens [1..5]\n\n(***include-it***)\n\n(**\nYou can use \u0060()\u0060 to clarify precedence (think brackets in math). In this example, do \u0060List.map\u0060 first, with two parameters. Then do \u0060List.sum\u0060 on the result. \u0060List.map\u0060 \napplies a function to all elements in the list.\n*)\n\nlet sumOfSquaresTo100 =\n   List.sum (List.map square [1..100])\n\nsumOfSquaresTo100\n\n(***include-it***)\n\n(**\nWithout the \u0060()\u0060, \u0060List.map\u0060 would be passed as an parameter to \u0060List.sum\u0060.\n\n## Side Note: Pipe-forward operator \u0060|\u003E\u0060\n\nThe Pipe-forward operator lets you pass an intermediate result (value) onto the next function, it\u2019s defined as: \n\n*)\n\nlet (|\u003E) x f = f x \n\n(**\n\nNow, you can pipe the output of one operation to the next using \u0060|\u003E\u0060.\nHere is the same \u0060sumOfSquares\u0060 function written using pipes.\n\n*)\n\nlet sumOfSquaresTo100piped =\n   [1..100] \n   |\u003E List.map square \n   |\u003E List.sum\n\nsumOfSquaresTo100piped\n\n(***include-it***)\n\n(**\nIn this case one often uses anonymous functions using the \u0060fun\u0060 keyword. This saves time to think about a name and the function can be writen inline.\n*)\n\nlet sumOfSquaresTo100withFun =\n   [1..100] \n   |\u003E List.map (fun x -\u003E x * x) \n   |\u003E List.sum\n   \nsumOfSquaresTo100withFun\n\n(***include-it***)\n\n(**\nYou already used the \u0060List.sum\u0060 function. It is important to notice that this function doesn\u2019t follow the \u0060map\u0060 concept. There is a second related concept called \u0060fold\u0060. \nThe higher-order and polytypic function \u0060fold\u0060 applies a function working on the normal space to an elevated space and reduces the elevated space into the normal space. \nThis results in an aggregation. A simple but concreate example would be to sum a list of numeric values.\n\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/fold.png)\n***Figure 4: A conceptual view of the \u0060fold\u0060 concept.***\n\n## Control flow expressions\n\nControl flow expressions are used to determine the program pathing under multiple possible conditions. These different paths must always lead to the same \u0060Type\u0060 (e.g. \u0060string\u0060).\n\n### if-then-else\n\n\u0060if-then-else\u0060 is an expression and must return a value of a particular type.\nIt evaluates to a different value depending on the \u0060boolean\u0060 expression given.\n\nBoth branches must return the same type!\n\n*)\n\nlet v = if true then \u0022a\u0022 else \u0022b\u0022\nv\n\n(***include-it***)\n\n(**\n\n### Pattern Matching\n\nPattern matchings are one method to apply these control flow expressions. These function similiar to the *if then else* expression, but much more powerful.\n\n*)\n\nlet simplePatternMatch x =\n   match x with\n    | \u0022a\u0022 -\u003E printfn \u0022input is a\u0022\n    | \u0022b\u0022 -\u003E printfn \u0022input is b\u0022\n    | _   -\u003E printfn \u0022input is something else\u0022\n\n(**\nUnderscore \u0060_\u0060 matches anything\n*)\n\nsimplePatternMatch \u0022a\u0022 \n\n(***include-output***)\n\nsimplePatternMatch \u0022I will not match\u0022\n\n(***include-output***)\n\n(**\nIn the following we will use a \u0060printfn\u0060 function. Normally in FSharp only the last output is returned, but side effects, can always be returned. As a rule of thumb: All Unit outputs are side effects. \nIn this case, this means, we will print the result and still can keep working with the output.\nAlso you will notice, that the last output is only \u0060f (1=3)\u0060 \u2192 \u0060\u0022b\u0022\u0060, but we still will get all other results, as we print them below.\n*)\n\nlet f x = \n    if x then \n        printfn \u0022a\u0022;\n        \u0022a\u0022 \n    else\n        printfn \u0022b\u0022\n        \u0022b\u0022\n\nf false\n\n(***include-it***)\n\nf true\n\n(***include-it***)\n\nf (1=1)\n\n(***include-it***)\n\nf (1=3)\n\n(***include-it***)\n\n(**\n\n## Complex Data Types\n\n\n### Tuples\n\nTuple types are pairs, triples, and so on of values.\n\nTuples use commas \u0060,\u0060 as delimiter.\n\n*)\n\nlet twoTuple = 1,2\ntwoTuple\n\n(***include-it***)\n\nlet threeTuple = \u0022a\u0022,2,true\nthreeTuple\n\n(***include-it***)\n\n(**\n### Record Types\n\nRecord types have named fields. They use Semicolons \u0060;\u0060 as separators.\n\n*)\n\ntype Person = {FirstName:string; LastName:string}\n\nlet person1 = {FirstName = \u0022John\u0022; LastName = \u0022Doe\u0022}\nperson1\n\n(***include-it***)\n\n(**\nField of a record type can be acessed individually with a dot \u0060.Name\u0060\n*)\n\nperson1.FirstName\n\n(***include-it***)\n\n(**\n## Code organization\n\nSometimes it can be necessary to organize code for example to ship a library to other users. Namespaces und Modules are top-level and low-level constructs to organize code. \n\n### Namespaces and modules\n\nYou can think of namespaces and modules as containers and sub containers, respectively, in which you can put function and type definitions. \nThe hierarchy is defined that you can have multiple modules in one namespace, also nested modules in a module, but no namespace in another \nnamespace. You can acces namespaces and modules with the \u0060.\u0060 operator.\n\n*)\n\n//Module \u201Ccontainer\u201D \nmodule WidgetsModule =\n    let widgetName = \u0022FSharp\u0022\n    let widgetFunction x y =\n        sprintf \u0022%s %s\u0022 x y\n        // printfn \u0022%s %s\u0022 x y\n\n// Calls the function from the module\nWidgetsModule.widgetFunction \u0022Hello\u0022 WidgetsModule.widgetName\n\n(***include-it***)\n\n(**\n### Comments\n\nComments also help to write organized code.\n\n**Comments are text written in code area (often marked green) which will be ignored by the compiler and not be executed.**\n\n\u0060//\u0060 single line comments use a double slash\n\n(* multi-line or in-line comments use \u0060(* . . . *)\u0060 pair -end of multi line comment- *)\n\n*)\n\ntype PersonalInformation =\n    {\n        //First name of a person\n        FirstName  :string\n        //Last name of a person\n        LastName   :string\n        (*Address and\n        phone number of a person*)\n        Address    : (*int*) string\n        PhoneNumber: int\n    }\n\n\n(**\n\n## References\n\n1. Bertalanffy, L. von. Zu einer allgemeinen Systemlehre. Bl\u00E4tter f\u00FCr deutsche Philosophie 18 (1945).\n2. Sauer, U., Heinemann, M. \u0026 Zamboni, N. Genetics. Getting closer to the whole picture. Science 316, 550\u2013551; 10.1126/science.1142502 (2007).\n3. Kitano, H. Systems biology. a brief overview. Science 295, 1662\u20131664; 10.1126/science.1069492 (2002).\n4. Joyce, A. R. \u0026 Palsson, B. O. The model organism as a system. integrating \u0027omics\u0027 data sets. Nat Rev Mol Cell Bio 7, 198\u2013210; 10.1038/Nrm1857 (2006).\n5. Aderem, A. Systems biology. Its practice and challenges. Cell 121, 511\u2013513; 10.1016/j.cell.2005.04.020 (2005).\n6. Kahlem, P. \u0026 Birney, E. Dry work in a wet world. computation in systems biology. Mol Syst Biol 2 (2006).\n7. Kitano, H. Computational systems biology. Nature 420, 206\u2013210; 10.1038/nature01254 (2002).\n*)"},{"uri":"/BIO-BTE-06-L-7/index.html","title":"The fslab documentation template\n","content":"(**\n# The fslab documentation template\n\nThis template scaffolds the necessary folder structure for FSharp.Formatting \nand adds custom styles in the **fslab** theme. \n\nThe provided stylesheet was compiled from sass (before uploading the nuget package) and\nuses the [Bulma](https://bulma.io/) CSS framework instead of bootstrap which is used by FSharp.Formatting per default.\n\n#### Table of contents \n\n- [Installation](#Installation)\n- [Usage](#Usage)\n- [Quick content rundown](#Quick-content-rundown)\n- [Creating new content](#Creating-new-content)\n- [Customization options](#Customization-options)\n    - [Style sheet options](#Style-sheet-options)\n    - [Inclusion of sample content](#Inclusion-of-sample-content)\n    - [Create notebooks](#Create-notebooks)\n\n\n## Installation\n\nThis template is available as a _dotnet new_ template (from [nuget](https://www.nuget.org/packages/FsLab.DocumentationTemplate/)):\n\n\u0060\u0060\u0060no-highlight\ndotnet new -i FsLab.DocumentationTemplate\n\u0060\u0060\u0060\n\n## Usage\n\nIf not already present, create a _local tool manifest_ in the root of your project that you want to write documentation for:\n\n\u0060\u0060\u0060no-highlight\ndotnet new tool-manifest\n\u0060\u0060\u0060\n\nThen, still in the root of your project, run:\n\n\u0060\u0060\u0060no-highlight\ndotnet new fslab-docs\n\u0060\u0060\u0060\n\n## Quick content rundown:\n\nThe default template initializes the following folder structure when you initialize it in the root of your project.\n\nSee [further below](#Customization-options) for command line customization options of the template.\n\n\u003Cpre\u003E\ndocs\n\u2502   index.fsx\n\u2502   _template.html\n|   _template.ipynb\n|   \n\u2502   0_Markdown-Cheatsheet.md\n\u2502   1_fsharp-code-example.fsx\n\u2502   2_inline-references.fsx\n\u2502   3_notebooks.fsx\n|\n\u251C\u2500\u2500\u2500content\n\u2502   fsdocs-custom.css\n\u2502\n\u251C\u2500\u2500\u2500img\n\u2502       favicon.ico\n\u2502       logo.png\n\u2502\n\u2514\u2500\u2500\u2500reference\n        _template.html\n\u003C/pre\u003E\n\n- \u0060index.fsx\u0060 is the file you are reading just now. It contains the very content you are reading at the moment \nin a markdown block indicated by \u0060(** *)\u0060 guards. It will be rendered as the root \u0060index.html\u0060 file of your documentation.\n\n- \u0060_template.html\u0060 is the root html scaffold (sidebar to the left, script and style loading) where all of the individual docs will be injected into\n\n- \u00600_Markdown-Cheatsheet.md\u0060 is a adaption of [this markdown cheat sheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) that shows how to write markdown and showcases the rendered equivalents. It can also be viewed in all its glory [here](https://fslab.org/docs-template/0_Markdown-Cheatsheet.html).\n\n- \u00601_fsharp-code-example.fsx\u0060 is a script file that showcases the syntax highlighting style for F# snippets. It can also be viewed in all its glory [here](https://fslab.org/docs-template/1_fsharp-code-example.html).\n\n- \u00602_inline-references.fsx\u0060 is a script file that explains how to use inline references and use Plotly.NET for charting. It can also be viewed in all its glory [here](https://fslab.org/docs-template/2_inline-references.html).\n\n- \u00603_notebooks.fsx\u0060 is a script file that showcases conditional content in documentation and how to use that to create dotnet interactive notebooks besides your html documentation. It can also be viewed in all its glory [here](https://fslab.org/docs-template/3_notebooks.html).\n\n- \u0060fsdocs-custom.css\u0060 contains the custom styling that applies the fslab styles.\n\n - the \u0060img\u0060 folder contains the fslab logo and favicon. replace these files (with the same names) to youse sours\n\n - \u0060reference/_template.html\u0060 is a slightly adapted version of the template above for the API documentation\n\n## Creating new content\n\n- run \u0060dotnet fsdocs watch --eval\u0060 to spawn a watcher and dev server that hosts your docs on http://localhost:8901/ (You currently will still have to refresh the page when you make changes to files)\n\n- add a new .md or .fsx file to the \u0060content\u0060 directory (or into a new subdirectory there)\n\n- the sidebar title for the document will be either the file name or, if existent, the first level 1 header in the file\n\n- when writing a .fsx file, code will automatically become syntax-highlighted code snippets. \n\n- use \u0060(** \u003Cmarkdown here\u003E *)\u0060 to guard markdown sections in .fsx files\n\n- use \u0060(*** include-value:\u003Cval name\u003E ***)\u0060 to include the value of a binding\n\n- use \u0060(*** include-it ***)\u0060 to include the evaluation of the previous snippet block \n\nFor more info please refer to the [FSharp.Formatting documentation](http://fsprojects.github.io/FSharp.Formatting/).\n\n\n## Customization options\n\n### Style sheet options\n\n\u0060\u0060\u0060no-highlight\n-s|--styles             Set the type of style content the template will initialize. For the sass file to work, you will have to download bulma\n\n        all             - sass file, compiled csss, and minified css\n\n        sass            - only include the sass file\n\n        minified        - only include the minified css file\n\n        css             - only include the compiled css file\n\n        Default:        css\n\u0060\u0060\u0060\n\n### Inclusion of sample content\n\n\u0060\u0060\u0060no-highlight\n-is|--include-samples   wether to include sample files in the generated content\n\n        bool            - Optional\n\n        Default:        true\n\u0060\u0060\u0060\n\n### Create notebooks\n\n\u0060\u0060\u0060no-highlight\n-in|--include-notebooks  wether to include the notebook template file\n        \n        bool            - Optional\n\n        Default:        true\n\u0060\u0060\u0060\n\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP11_Quantification.html","title":"JP11 Quantification\n","content":"(**\n# JP11 Quantification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP11_Quantification.ipynb)\n\n1. [Quantification Theory](#Quantification-Theory)\u003Cbr\u003E\n    1. [Targeted quantification](#Targeted-quantification)\n    2. [(i) Targeted acquisition at peptide](#(i)-Targeted-acquisition-at-peptide)\n    3. [(ii) Targeted data analysis at peptide ion level](#(ii)-Targeted-data-analysis-at-peptide-ion-level)\n2. [References](#References)\n*)\n\n(**\n## Quantification Theory\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTo estimate the amount of individual proteins in complex mixtures, all peptide signals corresponding to a common protein serve as a \nproxy for their abundance. Peptide information needs to be obtained from multidimensional signal data detected by the mass spectrometer. \nAll signals generated from one peptide ion species, often referred to as peptide feature, need to be grouped to form a three-dimensional peak \nalong the m/z, ion intensity, and retention time dimension. This process is generally defined as peak detection or feature detection. \nPeak detection algorithms are a set of rules defining how neighboring signal points are joined. Whether noise filtering is done before or after \npeak detection strongly depends on the peak detection algorithm. Traditional approaches mainly focused on signal amplitude neglecting \ncharacteristic peak shapes as a common feature of chromatographic or spectroscopic peaks. These algorithms are prone to miss detection of low \nintensity peaks with a signal strength close to the noise level. To overcome these issues, techniques like smoothing, shape-matching and curve \nfitting are often implemented and applied. At the time, the most promising approach to do shape-matching and noise reduction in one step uses the \ncontinuous wavelet transformation (CWT).\n\nIn general, a CWT based approach describes a family of time-frequency-transformations often used in data compression and feature detection. \nThe term is coined by the use of a wavelet, as a basis function which is \u201Ccompared\u201D to the signal. The point of highest correlation between the \nbasis function and the signal reflects the location of the peak present. Due to the fact that MS derived peaks often follow the shape of a \ngaussian distribution, the \u003Ci\u003EMexican Hat\u003C/i\u003E wavelet as the negative normalized second derivative of the Gaussian distribution is perfectly \nsuited to find the peptide feature.\n\n\u003Cdiv Id=\u0022figure5\u0022 Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 70% ; padding: 15px\u0022\u003E\n    \u003Cimg src=\u0022img/Wavelets.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\n        \u003Cb\u003EFigure 5: Schematic representation of the \u2018Haar\u2019-wavelet (blue) and the \u2018Mexican Hat\u2019- wavelet (green). \u003C/b\u003EThe \u2018Haar\u2019-wavelet is \n        named after its discoverer Alfred Haar and represents the first wavelet ever to be described. The \u2018Mexican Hat\u2019- or \u2018Ricker\u2019-wavelet is \n        frequently used in the fields of signal detection and compression.\n    \u003C/div\u003E\n\u003C/div\u003E    \n\nDepending on the quantification approach, the peptide features used for protein quantification might differ. In case of isotopic labeling, \nquantification means pairing features with the proper mass shift according to the utilized label. It is essential to account for the frequency \nof label incorporation when calculating the mass shift for the utilized label. Taking the ICAT method as an example, by which a heavy/light \ndifference of 9 Dalton per cysteine is incorporated, the total mass shift is 9 Dalton times the number of cysteine within the sequence. \nConsequently, pairing peptide features for \u003Csup\u003E15\u003C/sup\u003EN labeling is even more challenging, as the mass shift is less discrete. Using stable \nisotope labeling, different peptide feature pairs belonging to the same protein can be treated as technical replicates and averaged to gain \nprotein quantification. In contrast, the sum of all extracted peptide signals results in a label-free protein quanti\uFB01cation. Spectral counting \ncomputes abundance values from the number of times a peptide was successfully identi\uFB01ed by tandem mass spectrometry (MS/MS) and combines all \nthese events per protein. The spectral counting values can be normalized by the number of peptides theoretically expected from the particular \nprotein. \n\n\u003Cdiv Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 100% ; padding: 15px; max-width: 800px\u0022\u003E\n    \u003Cimg src=\u0022img/ComputationalProteinQuantification.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\n        \u003Cb\u003EFigure 6: Computational strategy of peptide and protein quanti\uFB01cation on based on stable isotope labeling or by label-free \n        quanti\uFB01cation.\u003C/b\u003E (A) Label-free methods compare corresponding peptide abundances over different MS runs. The abundance is either \n        estimated by the elution pro\uFB01le les of the pep de ions or (B) in case of spectral counting, by the number of times a peptide was \n        successfully identi\uFB01ed (MS2). In contrast, methods based on differential stable isotope labeling analyze peptides pairs detected by \n        their characteristic mass di\uFB00erence \u0394m/z. The abundance is estimated by the ratio of their corresponding elution pro\uFB01les (C). Isobaric \n        tagging methods (D) compare the reporter ion abundances in the fragmentation spectrum.\n    \u003C/div\u003E\n\u003C/div\u003E\n\n\u003C/div\u003E\n*)\n\n(**\n### Targeted quantification\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nTargeted proteomics has gained significant popularity in mass spectrometry\u2010based protein quantification as a method to detect proteins of \ninterest with high sensitivity, quantitative accuracy and reproducibility. The two major strategies of (i) targeted acquisition at peptide, \nand (ii) targeted data analysis at peptide ion level need to be distinguished.\n\u003C/div\u003E\n*)\n\n(**\n###(i) Targeted acquisition at peptide\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nIn multiple reaction monitoring (MRM or SRM for single/selected reaction monitoring) simply predefined transitions are recorded. \nKnowledge about the targeted transitions from precursor to their corresponding fragment ions are needed and predefined in the mass \nspectrometer. MRM can be performed rapidly and is highly specific even for low abundant peptide ions in complex mixtures, but with the \ndrawback of a necessary bias in the sense that only predefined peptides are measured.\n\u003C/div\u003E\n*)\n\n(**\n### (ii) Targeted data analysis at peptide ion level\n\u003Ca href=\u0022#Quantification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nData\u2010independent acquisition at the peptide level makes it possible to acquire peptide data for virtually all peptide ions present in a sample. \nIn this strategy, a high\u2010resolution mass analyzer\u2014such as an orbitrap or a time\u2010of\u2010flight\u2014is used to constantly sample the full mass range \nat the peptide level during the entire chromatographic gradient. In a subsequent step, precursor ion chromatograms can be extracted by targeted \ndata analysis. Those extracted-ion chromatogram (XIC) can be obtained to calculate the area under the curve and used for peptide quantification.\n\nLet\u2019s start and extract a XIC\u2026\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: System.Data.SQLite, 1.0.113.7\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: MzIO, 0.1.0-beta\u0022\n#r \u0022nuget: MzIO.SQL, 0.1.0-beta\u0022\n#r \u0022nuget: MzIO.Processing, 0.1.0-beta\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.1\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen FSharp.Stats\nopen BioFSharp\nopen System.IO\nopen System.Data.SQLite\nopen BIO_BTE_06_L_7_Aux.FS3_Aux\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\nWe now want to extract the XIC for the peptide where we previously calculated the matching score.\n\nSince we need several mass spectrometry scans to quantify over the retention time, we connect to our database \nand index the entries according to their retention time.\n\u003C/div\u003E\n*)\n\n// Code-Block 1\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/sample.mzlite\u0022|]\ndownloadFile path \u0022sample.mzlite\u0022 \u0022bio-bte-06-l-7\u0022\nlet runID = \u0022sample=0\u0022\n\nlet mzReader = new MzIO.MzSQL.MzSQL(path)\nlet cn = mzReader.Open()\nlet transaction = mzReader.BeginTransaction()\n\n// Indexes all spectra of the related sample run\nlet idx = MzIO.Processing.Query.getMS1RTIdx mzReader runID\nidx\n\n(***include-it***)\n\n(**\n\u003Cdiv class=\u0022container\u0022\u003E\n\u003Cb\u003EWe know from the MS\u003Csup\u003E2\u003C/sup\u003E measurement, that our peptide had its match at a retention of around 51.95 min\u003C/b\u003E. We create a query \nto the database to extract the intensities of all peaks that are \u002B/-5 min of our retention time and within 0.04 m/z of our peptide of interest. \nAfter we are done, we close the connection to the database.\n\u003C/div\u003E\n*)\n\n// Code-Block 2\n\nlet retentionTime = 51.95\nlet mzAtCharge2   = 511.2691141\n\nlet rtQuery = MzIO.Processing.Query.createRangeQuery retentionTime 5.\n\nlet mzQuery = MzIO.Processing.Query.createRangeQuery mzAtCharge2 0.04\n\nlet xic = \n    MzIO.Processing.Query.getXIC mzReader idx rtQuery mzQuery  \n    |\u003E Array.map (fun p -\u003E p.Rt , p.Intensity)\n    \ntransaction.Dispose()\n\nlet xicChart =\n    xic\n    |\u003E Chart.Point\n    |\u003E Chart.withX_AxisStyle \u0022Retention Time\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Intensity/Score\u0022\n    |\u003E Chart.withSize (900.,900.)\nxicChart\n(***hide***)\nxicChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nWe have now the XIC in our hands and can use the second derivative to identify peaks with our trace.\n*)\n\n// Code-Block 3\n\n// get all peaks\nlet peaks = \n    xic\n    |\u003E Array.unzip\n    |\u003E (fun (ret, intensity) -\u003E\n        FSharp.Stats.Signal.PeakDetection.SecondDerivative.getPeaks 0.1 2 13 ret intensity\n        )\n\npeaks |\u003E Array.head\n\n(***include-it***)\n\n(**\nThe peak model includes numerus information. Therefore we can mark the apices of the peaks we identified.\n*)\n\n// Code-Block 4\n\nlet apices =\n    peaks\n    |\u003E Array.map (fun peak -\u003E peak.Apex.XVal,peak.Apex.YVal)\n\nlet apicesChart=\n    [    \n        Chart.Point(apices, Name=\u0022apices\u0022)\n        |\u003E Chart.withMarkerStyle(Size=15)\n        Chart.Point(xic, Name = \u0022XIC\u0022)\n\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_AxisStyle \u0022Retention Time\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Intensity\u0022\n    |\u003E Chart.withSize (900.,900.)\napicesChart\n(***hide***)\napicesChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nWe can then go ahead and characterize our peak and quantify the area under the fitted curve.\n*)\n\n// Code-Block 5\n\n// get peak at \u0022ret=51.95\u0022 from all peaks \u0022peaks\u0022\nlet quantifiedXIC = \n    BioFSharp.Mz.Quantification.HULQ.getPeakBy peaks retentionTime\n    // quantify peak of interest\n    |\u003E BioFSharp.Mz.Quantification.HULQ.quantifyPeak \n    \nquantifiedXIC.Area\n\n(***include-it***)\n\n(**\nThe peak model gives us all the information we need for our peptide of interest. If we want to see what we quantified, we can take an \nexponential modified gaussian function using the parameters given by the peak model and plot it together with the previously extracted XIC.\n*)\n\n// Code-Block 6\n\nlet eval x = \n    Fitting.NonLinearRegression.Table.emgModel.GetFunctionValue (vector quantifiedXIC.EstimatedParams) x\n\neval\n\n(**\n*)\n\n// Code-Block 7\n\nlet quantifiedArea =\n    xic \n    |\u003E Array.map (fun (rt,i) -\u003E rt, eval rt)\n\nlet quantifiedAreaChart =\n    [\n        Chart.Point(xic,Name=\u0022XIC\u0022)\n        Chart.SplineArea(quantifiedArea,Name=\u0022quantified XIC\u0022)\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_AxisStyle (title = \u0022Retention Time\u0022, MinMax = (51.,55.))\n    |\u003E Chart.withY_AxisStyle \u0022Intensity\u0022\n    |\u003E Chart.withSize (900.,900.)\nquantifiedAreaChart\n(***hide***)\nquantifiedAreaChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP10_Peptide_Identification.html\u0027;\u0022\u003E\u0026#171; JP10\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP10_Peptide_Identification.html","title":"JP10 Peptide Identification\n","content":"(**\n# JP10 Peptide Identification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP10_Peptide_Identification.ipynb)\n\n\n1. [Understanding peptide identification from MS\u003Csup\u003E2\u003C/sup\u003E spectra](#Understanding-peptide-identification-from-MS2-spectra)\n2. [Matching and scoring of Tandem MS peptide identification](#Matching-and-scoring-of-Tandem-MS-peptide-identification)\n    3. [Step 1: Data acquisition and preprocessing](#Step-1:-Data-acquisition-and-preprocessing)\n    4. [Step 2: Preselecting the peptides of interest](#Step-2:-Preselecting-the-peptides-of-interest)\n    5. [Step 3\u002B4: Matching and Scoring](#Step-3\u002B4:-Matching-and-Scoring)\n*)\n\n(**\n## Understanding peptide identification from MS\u003Csup\u003E2\u003C/sup\u003E spectra\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nUnder low-energy fragmentation conditions, peptide fragment patterns are reproducible and, in general, predictable, which allows for an \namino acid sequence identification according to a fragmentation expectation. Algorithms for peptide identification perform in principle \nthree basic tasks:\n\n\u003Cb\u003E(i)\u003C/b\u003E a raw data preprocessing step is applied to the MS/MS spectra to obtain clean peak information. The same signal filtering \nand background subtraction methods are used as discussed in the section of low-level processing. Peak detection, however, may be performed \ndifferently. Preprocessing of MS/MS spectra focuses on the extraction of the precise m/z of the peak rather than the accurate peak areas. \nThe conversion of a peak profile into the corresponding m/z and intensity values reduces the complexity, its representation is termed centroiding. \nTo extract the masses for identification in a simple and fast way, peak fitting approaches are used. These approaches take either the most intense \npoint of the peak profile, fit a Lorentzian distribution to the profile, or use a quadratic fit\u003Csup\u003E\u003Ca href=\u0022#37\u0022\u003E37\u003C/a\u003E\u003C/sup\u003E. \n\n\u003Cb\u003E(ii)\u003C/b\u003E Spectrum information and possible amino acid sequences assignments are evaluated. \n\n\u003Cb\u003E(iii)\u003C/b\u003E The quality of the match between spectrum and possible sequences is scored.\n\nEven though the three steps roughly describe the basic principle of algorithms used for peptide sequence identification, most implementations \nshow differences in individual steps which can lead to major changes in the outcome. Therefore, it has been proven useful to utilize more than \none algorithm for a robust and thorough identification. Due to their major difference in identification strategies and prerequisites, \nidentification algorithms are normally classified into three categories: (i) \u003Ci\u003Ede novo\u003C/i\u003E peptide sequencing, (ii) peptide sequence-tag (PST) \nsearching, and (iii) uninterpreted sequence searching. However, in this notebook we focus on the explanation of (iii) uninterpreted sequence \nsearching, the most frequently used methods.\n\u003C/div\u003E\n*)\n\n(**\n## Matching and scoring of Tandem MS peptide identification\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\n\u003Cdiv class=\u0022container\u0022\u003E\n\n\u003Cdiv Id=\u0022figure4\u0022 Style=\u0022float: right ; display: inline-block ; color: #44546a ; width: 60% ; padding: 15px\u0022\u003E\n    \u003Cimg src=\u0022img/ComputationalProteinIdentification.png\u0022 Style=\u0022width: 100%\u0022\u003E\n    \u003Cdiv Style=\u0022padding-left: 1rem ; padding-right: 1rem ; text-align: justify ; font-size: 0.8rem\u0022\u003E\u003Cb\u003E\n        Figure 4: Process of computational identification of peptides from their fragment spectra\u003C/b\u003E\n    \u003C/div\u003E\n\u003C/div\u003E    \n\nPreviously we learned, that peptides fragment to create patterns characteristic of a specific amino acid sequence. These patterns are reproducible and, in general, predictable taking the applied fragmentation method into account. This can be used for computational identification of peptides from their fragment spectra. This process can be subdivided into 5 main steps: spectrum preprocessing, selection of possible sequences, generating theoretical spectra, matching and scoring (\u003Ca href=\u0022#figure5\u0022 \u003EFigure 4\u003C/a\u003E). The first step is a preprocessing of the experimental spectra and is done to reduce noise. Secondly, all possible amino acid sequences are selected which match the particular precursor peptide mass. The possible peptides can but do not need to be restricted to a particular organism. A theoretical spectrum is predicted for each of these amino acid sequences. Matching and scoring is performed by comparing experimental spectra to their predicted corresponding theoretical spectra. The score function measures the closeness of fit between the experimental acquired and theoretical spectrum. There are many different score functions, which can be considered as the main reason of different identifications considering different identification algorithm. The most natural score function is the cross correlation score (xcorr) used by the commercially available search tool SEQUEST. One of the reasons the xcorr is so sensitive is because it involves a correction factor that assesses the background correlation for each acquired spectrum and the theoretically predicted spectrum from sequences within a database. To compute this correction factor, a measure of similarity is calculated at different offsets between a preprocessed mass spectrum and a theoretical spectrum. The final xcorr is then the correlation at zero offset minus the mean correlation from all the individual offsets.\n\nThus, the correlation function measures the coherence of two signals by, in effect, translating one signal across the other. This can be mathematically achieved using the formula for cross-correlation in the form for discrete input signals:\n\n\u003Ci\u003E\u003Cb\u003EEquation 5\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?\\large\u0026space;R_{\\tau}\u0026space;=\u0026space;\\sum_{i=0}^{n-1}x_{i}\\cdot y_{i\u0026plus;\\tau}\u0022 title=\u0022\\large R_{\uD835\uDF0F} = \\sum_{i=0}^{n-1}x_{i}\\cdot y_{i\u002B\uD835\uDF0F}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nwhere x\u003Csub\u003Ei\u003C/sub\u003E is a peak of the reconstructed spectrum at position i and y\u003Csub\u003Ei\u003C/sub\u003E is a peak of the experimental spectrum. The displacement value \uD835\uDF0F is the amount by which the signal is offset during the translation and is varied over a range of values. If two signals are the same, the correlation function should have its maxima at \uD835\uDF0F=0, where there is no offset. The average of the offset-correlation is seen as the average background correlation and needs to be subtracted from the correlation at \uD835\uDF0F=0. It follows: \n\n\u003Ci\u003E\u003Cb\u003EEquation 6\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?xcorr\u0026space;=\u0026space;R_{0}\u0026space;-\u0026space;\\frac{(\\sum\u0026space;\\begin{matrix}\u0026space;\\tau=\u0026plus;offeset\\\\\u0026space;\\tau=-offeset\\end{matrix}R_{\\tau})}{2*offset\u0026plus;1}\u0022 title=\u0022xcorr = R_{0} - \\frac{(\\sum \\begin{matrix} \\tau=\u002Boffeset\\\\ \\tau=-offeset\\end{matrix}R_{\\tau})}{2*offset\u002B1}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nIn practice many theoretical spectra have to be matched again a single experimental spectrum. Therefore, the calculation can be speed up by reformulating Equation 5 and Equation 6 and introduce a preprocessing step, which is independent of the predicted spectra.\n\n\u003Ci\u003E\u003Cb\u003EEquation 7\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?xcorr\u0026space;=\u0026space;x_{0}\\cdot\u0026space;y_{0}\u0026space;-\u0026space;\\frac{(\\sum\u0026space;\\begin{matrix}\u0026space;\\tau=\u0026plus;offeset\\\\\u0026space;\\tau=-offeset\\end{matrix}x_{0}\\cdot\u0026space;y_{\\tau})}{2*offset\u0026plus;1}\u0022 title=\u0022xcorr = x_{0}\\cdot y_{0} - \\frac{(\\sum \\begin{matrix} \\tau=\u002Boffeset\\\\ \\tau=-offeset\\end{matrix}x_{0}\\cdot y_{\\tau})}{2*offset\u002B1}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nFor the preprocessed experimental spectrum y\u0027 it follows:\n\n\u003Ci\u003E\u003Cb\u003EEquation 8\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?xcorr\u0026space;=\u0026space;x_{0}\\cdot\u0026space;y\u0027\u0022 title=\u0022xcorr = x_{0}\\cdot y\u0027\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\nwhere:\n\n\u003Ci\u003E\u003Cb\u003EEquation 9\u003C/b\u003E\u003C/i\u003E\n\n\u003Cimg src=\u0022https://latex.codecogs.com/gif.latex?y\u0027\u0026space;=\u0026space;y_{0}\u0026space;-\u0026space;\\frac{(\\sum\u0026space;\\begin{matrix}\u0026space;\\tau=\u0026plus;offeset\\\\\u0026space;\\tau=-offeset\\end{matrix}x_{0}\\cdot\u0026space;y_{\\tau})}{2*offset\u0026plus;1}\u0022 title=\u0022y\u0027 = y_{0} - \\frac{(\\sum \\begin{matrix} \\tau=\u002Boffeset\\\\ \\tau=-offeset\\end{matrix}x_{0}\\cdot y_{\\tau})}{2*offset\u002B1}\u0022 style=\u0022margin: 1rem auto 1rem; display: block\u0022 /\u003E\n\n\u003Cdiv Style=\u0022text-align: justify ; margin-top: 2rem ; margin-bottom: 2rem ; line-height: 1.3 ; width: 85% ; margin-left: auto ; margin-right: auto ; padding: 10px ; border: 2px dotted #708090 ; color: #708090\u0022\u003E\nMatching a measured spectrum against chlamy database\n\u003C/div\u003E\n\u003C/div\u003E\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta4\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta4\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.1\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\nopen BIO_BTE_06_L_7_Aux.FS3_Aux\nopen System.IO\n\n(**\n### Step 1: Data acquisition and preprocessing\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\nWe load a single MS\u003Csup\u003E2\u003C/sup\u003E spectrum that is saved in a mgf file.\n*)\n\n// Code-Block 1\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/ms2sample.mgf\u0022|]\ndownloadFile path \u0022ms2sample.mgf\u0022 \u0022bio-bte-06-l-7\u0022\n\nlet ms2 = \n    BioFSharp.IO.Mgf.readMgf path\n    |\u003E List.head\n    \nms2\n\n(***include-it***)\n\n(**\nHere, the spectrum is already centroidized as shown in \u003Ca href=\u0022JP08_Centroidisation.ipynb\u0022\u003EJP08_Centroidisation\u003C/a\u003E using the function \n\u003Ccode\u003EmsPeakPicking\u003C/code\u003E. So we just visualize mass and intensity:\n*)\n\n// Code-Block 2\n\nlet ms2Chart = Chart.Column(ms2.Mass, ms2.Intensity)\nms2Chart\n(***hide***)\nms2Chart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nNow, we will preprocess the experimental spectrum from our example. This is on the one hand to reduce noise, but also to make \nthe measured spectrum more like the once we are able to simulate. \n*)\n\n// Code-Block 3\n\nlet lowerScanLimit = 150.\nlet upperScanLimit = 1000.\n\nlet preprocessedIntesities =\n    Mz.PeakArray.zip ms2.Mass ms2.Intensity\n    |\u003E (fun pa -\u003E Mz.PeakArray.peaksToNearestUnitDaltonBinVector pa lowerScanLimit upperScanLimit)\n    |\u003E (fun pa -\u003E Mz.SequestLike.windowNormalizeIntensities pa 10)\n    \nlet intensityChart = Chart.Column([lowerScanLimit .. upperScanLimit], preprocessedIntesities)\nintensityChart\n(***hide***)\nintensityChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n### Step 2: Preselecting the peptides of interest\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\u0022container\u0022\u003E\nEvery MS\u003Csup\u003E2\u003C/sup\u003E spectrum is accompanied by a m/z ratio reported by the instrument. Additionally, we can estimate the charge looking \nat the isotopic cluster. We take the peptide \u0022DTDILAAFR\u0022 from our previous notebook again. Our example has a measured m/z = 511.2691141 and \na charge of z=2.\n\u003C/div\u003E\n*)\n\nlet peptideMass = \n    Mass.ofMZ 511.2691141 2.\n\npeptideMass\n\n(***include-it***)\n\n(**\nFrom our previos notebook \u003Ca href=\u0022JP04_Digestion_and_mass_calculation.ipynb\u0022\u003EJP04 Digestion and mass calculation\u003C/a\u003E, we know how to \ncalculate all peptide masses that we can expect to be present in \u003Ci\u003EChlamydomonas reinhardtii\u003C/i\u003E.\n*)\n\n// Code-Block 4\nlet path2 = Path.Combine[|directory;\u0022downloads/Chlamy_JGI5_5(Cp_Mp).fasta\u0022|]\ndownloadFile path2 \u0022Chlamy_JGI5_5(Cp_Mp).fasta\u0022 \u0022bio-bte-06-l-7\u0022\n\nlet peptideAndMasses = \n    path2\n    |\u003E IO.FastA.fromFile BioArray.ofAminoAcidString\n    |\u003E Seq.toArray\n    |\u003E Array.mapi (fun i fastAItem -\u003E\n        Digestion.BioArray.digest Digestion.Table.Trypsin i fastAItem.Sequence\n        |\u003E Digestion.BioArray.concernMissCleavages 0 0\n        )\n    |\u003E Array.concat\n    |\u003E Array.map (fun peptide -\u003E\n        // calculate mass for each peptide\n        peptide.PepSequence, BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n        )\n\npeptideAndMasses |\u003E Array.head\n\n(***include-it***)\n\n(**\nHowever, we are only interest in possible amino acid sequences, that match the particular precursor peptide mass of our example spectrum \nwith 1020.523675 Da. Additionaly, we should also consider a small measurement error.\n*)\n\n// Code-Block 5\n\npeptideAndMasses\n|\u003E Array.filter (fun (sequence,mass) -\u003E mass \u003E 1020.52  \u0026\u0026 mass \u003C 1020.53)\n\n(***include-it***)\n\n(**\nIn the previous notebook \u003Ca href=\u0022JP09_Fragmentation_for_peptide_identification.ipynb\u0022\u003EFragmentation for peptide identification\u003C/a\u003E, \nwe used functions that generate the theoretical series of b- and y-ions from the given peptide. Combined with the function \n\u003Ccode\u003EMz.SequestLike.predictOf\u003C/code\u003E that generates theoretical spectra that fit the Sequest scoring algorithm.\n*)\n\n// Code-Block 6\n\nlet predictFromSequence peptide =\n    [\n        peptide\n        |\u003E Mz.Fragmentation.Series. yOfBioList BioItem.initMonoisoMassWithMemP\n        peptide\n        |\u003E Mz.Fragmentation.Series.bOfBioList BioItem.initMonoisoMassWithMemP\n    ]\n    |\u003E List.concat\n    |\u003E Mz.SequestLike.predictOf (lowerScanLimit,upperScanLimit) 2.\n\npredictFromSequence\n\n(**\n### Step 3\u002B4: Matching and Scoring\n\u003Ca href=\u0022#Peptide-Identification\u0022 style=\u0022display: inline-block\u0022\u003E\u003Csup\u003E\u0026#8593;back\u003C/sup\u003E\u003C/a\u003E\u003Cbr\u003E\n\nIn the matching step, we compare theoretical spectra of peptides within our precursor peptide mass range with our measured spectra. \nWe get a score which tells us how well the theoretical spectrum fits the given experimental spectrum.\n*)\n\n// Code-Block 7\n\npeptideAndMasses\n|\u003E Array.filter (fun (sequence,mass) -\u003E\n    mass \u003E 1020.52  \u0026\u0026 mass \u003C 1020.53\n)\n|\u003E Array.map (fun (sequence,mass)    -\u003E\n    sequence,predictFromSequence sequence\n)\n|\u003E Array.map (fun (sequence,theoSpectrum) -\u003E \n    sequence,Mz.SequestLike.scoreSingle theoSpectrum preprocessedIntesities\n)\n|\u003E Array.sortByDescending (fun (sequence,score) -\u003E score)\n\n(***include-it***)\n\n(**\nFinaly, we pick the sequence with the best score and are done for now. Notice however, that in a real world we would need to \nrelate our score to the complete data set to get an idea of the overall quality and which numerical value we could trust. \n*)\n\n(**\n\u003Chr\u003E\n\u003Cnav class=\u0022level is-mobile\u0022\u003E\n    \u003Cdiv class=\u0022level-left\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP09_Fragmentation_for_peptide_identification.html\u0027;\u0022\u003E\u0026#171; JP09\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n    \u003Cdiv class=\u0022level-right\u0022\u003E\n        \u003Cdiv class=\u0022level-item\u0022\u003E\n            \u003Cbutton class=\u0022button is-primary is-outlined\u0022 onclick=\u0022location.href=\u0027/JP11_Quantification.html\u0027;\u0022\u003EJP11 \u0026#187;\u003C/button\u003E\n        \u003C/div\u003E\n    \u003C/div\u003E\n\u003C/nav\u003E\n*)"},{"uri":"/BIO-BTE-06-L-7/JP04_Digestion_and_mass_calculation.html","title":"JP04 Digestion and mass calculation\n","content":"(** \n# JP04 Digestion and mass calculation\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP04_Digestion_and_mass_calculation.ipynb)\n\n1. Digestion and mass calculation\n    2. Accessing the protein sequences of *Chlamydomonas reinhardtii*\n    3. Amino acid distribution for *C. reinhardtii*\n4. Calculating the molecular weight for peptides\n    5. *In silico* digestion of FASTA proteins with trypsin\n    6. Calculating peptide masses\n    7. Calculating peptide masses for charge 2\n6. References\n\n*)\n\n(** \n## Digestion and mass calculation\n\nThe most widely applied method for protein digestion involves the use of enzymes. Many proteases are available for this purpose, \neach having their own characteristics in terms of specificity, efficiency and optimum digestion conditions. Trypsin is most widely \napplied in bottom-up proteomics and and has a very high degree of specificity, cleaving the peptide bonds C-terminal to the basic residues \nLys and Arg, except when followed by Pro (Burkhart et al. 2012). In general, Lys and Arg are relatively abundant amino acids and are \nusually well distributed throughout a protein (Switzar et al. 2013). This leads to tryptic peptides with an average length of \u223C14 amino \nacids that carry at least two positive charges, which is ideally suited for CID-MS analysis (Burkhart et al. 2012).\n\nUsing *in silico* analysis, we want to confirm that the general properties of trypsin digestion also apply for the \nproteome of *Chlamydomonas reinhardtii* . First, we load the proteome of *Chlamydomonas* in standard fastA format. \nAmino acid composition of the proteome is simply counting each amino acid occurrence and can be visualized by a histogram:\n*)\n\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.1\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen BioFSharp\nopen BIO_BTE_06_L_7_Aux.FS3_Aux\nopen System.IO\n\n(**\n## Accessing the protein sequences of *Chlamydomonas reinhardtii*\n\nFASTA is a standardized text format, containing gene or protein sequence information. Such FASTAs can be donwloaded \nfrom [UniProt](https://www.uniprot.org/proteomes/UP000006906) for example.\n\nTo gain informations about the amino acid composition of *C. reinhardtii*, we need information about the proteome \nof *Chlamydomonas*, which is saved in the .fasta file we are accessing below.\n*)\n\n// __SOURCE_DIRECTORY__ returns the directory in which the current notebook is located\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/Chlamy_JGI5_5(Cp_Mp).fasta\u0022|]\ndownloadFile path \u0022Chlamy_JGI5_5(Cp_Mp).fasta\u0022 \u0022bio-bte-06-l-7\u0022\n// with /../ we navigate a directory \npath\n\n(*** include-it ***)\n\n(**\nFunctions to read information from FASTA files exist in the [BioFSharp](https://csbiology.github.io/BioFSharp/) library.\n*)\n\nlet sequences = \n    path\n    |\u003E IO.FastA.fromFile BioArray.ofAminoAcidString\n    |\u003E Seq.toArray\n    \n// Display the first element in the array collection\nsequences |\u003E Array.head\n\n(*** include-it ***)\n\n(**\n\n## Amino acid distribution for *C. reinhardtii*\n\nTo count the amino acid composition, we take the sequence of every protein and count the occurences of each amino acid\n*)\n\nlet aminoAcidDistribution =\n    sequences\n    // only access Sequence from each array element.\n    |\u003E Array.collect (fun fastAItem -\u003E fastAItem.Sequence)\n    // count each occurence of all amino acids. \n    |\u003E Array.countBy id\n    \naminoAcidDistribution\n\nlet aaDistributionHis =\n    aminoAcidDistribution\n    |\u003E Array.map (fun (name,count) -\u003E string name, count)\n    // sort by number of occurences\n    |\u003E Array.sortBy fst\n    // create chart\n    |\u003E Chart.Column\n    // style chart\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\n    |\u003E Chart.withTitle \u0022Amino Acid composition of the *Chlamydomonas reinhardtii* proteome\u0022\naaDistributionHis\n(***hide***)\naaDistributionHis |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n    \n\n(**\n\n## Calculating the molecular weight for peptides\n\nThe molecular weight M of a peptide may be estimated by calculating the equation for the molecular weight of a peptide: \n\n![](https://latex.codecogs.com/gif.latex?M\u0026space;=\u0026space;M_{N}\u0026plus;M_{C}\\sum_{i=0}^{n}N_{i}M_{i})\n\nwhere N(i) are the number, and M(i) the average residue molecular weights, of the amino acids. M(N) \u002B M(C) \nare added to the total in order to account for the termini: H at the N-terminus and OH at the C-terminus. (Remark: if the termini are modified, \nthese additions are replaced by those of the modifiers.)\n\nThe distribution of all molecular weights for the peptides resulting from the previous proteome digest can be calculated and visualized using a histogram chart:\n*)\n\n(**\n## *In silico* digestion of FASTA proteins with trypsin\n\nTo gain information about the peptide sequences of each protein, we have to compute the digested sequence, A digest function with \nvariable protease exists in BioFSharp.\n*)\n\nlet digestedProteins =\n    // sequences is the fasta data\n    sequences\n    |\u003E Array.mapi (fun i fastAItem -\u003E\n        // in silico digestion\n        Digestion.BioArray.digest Digestion.Table.Trypsin i fastAItem.Sequence\n        |\u003E Digestion.BioArray.concernMissCleavages 0 1\n    )\n    |\u003E Array.concat\n    \ndigestedProteins |\u003E Array.head\n\n(*** include-it ***)\n\n(**\n## Calculating peptide masses\n\nWe calculate the mass of each peptide by calculating the monoisotopic mass of each amino acid and adding the weight \nof an H(2)O to each peptide weight.\n*)\n\nlet chartDigestedProteins =\n    digestedProteins\n    |\u003E Array.map (fun peptide -\u003E\n        // calculate mass for each peptide\n        BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n        )\n    |\u003E Array.filter (fun x -\u003E x\u003C3000.)\n    // visualize distribution of all peptide masses \u003C 5000 Da\n    |\u003E fun masses -\u003E Chart.Histogram(data=masses,nBinsx=100)\n    |\u003E Chart.withX_AxisStyle (title = \u0022Mass [Da]\u0022,MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\nchartDigestedProteins\n(***hide***)\nchartDigestedProteins |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n    \n(**\n## Calculating peptide masses for charge 2\n\nHowever, in mass spectrometry we are only able to detect ions. Therefore, the measurements report the mass-to-charge ratio. \nThe abbreviation m/z (m = mass; z = charge) is used to denote the dimensionless quantity formed by dividing the molecular weight \nof an ion (M\u002BnH(\u002B)) by its charge number (n).\n\n![](https://latex.codecogs.com/gif.latex?M_{z}=\\frac{(M\u0026plus;nH^{\u0026plus;})}{n})\n\nIn the following, we will convert the uncharged peptide masses to the m/z ratio with charge two by applaying the Mass.toMZ \nfunction from the BioFSharp library and displax its distribution again. Note that m/z ratio with a charge of two represents \nthe predominant charge species.\n*)\n\nlet digestedPeptideMasses =\n    digestedProteins\n    |\u003E Array.map (fun peptide -\u003E\n        BioSeq.toMonoisotopicMassWith (BioItem.monoisoMass ModificationInfo.Table.H2O) peptide.PepSequence\n    )\n\nlet chartDigestedPeptideMasses =\n    digestedPeptideMasses\n    |\u003E Array.map (fun ucMass -\u003E Mass.toMZ ucMass 2.)\n    |\u003E Array.filter (fun x -\u003E x\u003C3000.)\n    |\u003E fun masses -\u003E Chart.Histogram(data=masses,nBinsx=100)\n    |\u003E Chart.withX_AxisStyle (title = \u0022m/z\u0022,MinMax=(0.,3000.))\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\nchartDigestedPeptideMasses\n(***hide***)\nchartDigestedPeptideMasses |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## References\n\n23. Burkhart, J. M., Schumbrutzki, C., Wortelkamp, S., Sickmann, A. \u0026 Zahedi, R. P. Systematic and quantitative comparison of digest efficiency and specificity reveals the impact of trypsin quality on MS-based proteomics. Journal of proteomics 75, 1454\u20131462; 10.1016/j.jprot.2011.11.016 (2012).\n24. Switzar, L., Giera, M. \u0026 Niessen, W. M. A. Protein digestion: an overview of the available techniques and recent developments. J. Proteome Res. 12, 1067\u20131077; 10.1021/pr301201x (2013).\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP01_FSharpExcercises.html","title":"JP01 FSharp Introduction Excercises\n","content":"(** \nThis notebook contains introductional excercises for the FSharp programming language and also some small code examples for correct formatting.\nIf you have questions at any point please ask us. We will discuss the first batch (task 1-6) before you can start the rest.\n\n# JP01 FSharp Introduction Excercises\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP01_FSharpExcercises.ipynb)\n\n\n1. Code Examples\n2. Excercises\n    * Task 1\n    * Task 2\n    * Task 3\n    * Task 4\n    * Task 5\n    * Task 6\n    * Task 7\n    * Task 8\n    * Task 9\n    * Task 10\n    * Task 11\n\n## Code Examples\n\nWe will beginn with some minor code examples to show you correct formatting. You can even use these examples to help you understand minor programming logics for your excercises below.\n\n*)\n\n// Define a function \u0027mulitplyBy2\u0027, which should double any input Float.\n\nlet mulitplyBy2 x = x * 2.\n\nmulitplyBy2 3.\n\n(*** include-it ***)\n\n(**\nIf a excercise asks you to bind something to a specific name, keep that name! It might be used later on!\nAlso remember to use camel case for names. This works by having a regular first letter and then have a capital letter at the start of each new word.\n\nexmp: \u0060thisIsACamelCaseExample\u0060\n\n*)\n\n// Create a function \u0027calculateCylinderVolume\u0027, which should, with a given radius and lenght, \n// calculate and return the volume of a cylinder AND print \u0022The volume of the cylinder is: XX.\u0022 into the console. \u0027XX\u0027 is,\n// of course, the correct volume for the cylinder. (The output of a printfn function is Unit.)\n\nlet calculateCylinderVolume radius length : float =\n   // function body\n   let pi = 3.14159 //or System.Math.PI\n   let volume = length * pi * radius * radius\n   printfn \u0022Das Volumen des Zylinders ist: %f\u0022 volume\n   volume\n\ncalculateCylinderVolume 2. 10.\n   \n(*** include-it ***)\n(*** include-output ***)\n\n(**\n\n\n* Try to follow the excercise as close as possible, to not overlook something like \u0022.. calculate (..) the volume of a cylinder AND print ..\u0022 as these small differences migth be a valuable part of the excercise.\n* Lines of code do not have any cost, don\u0027t be to stingy about them, e.g. have an extra line with a binding of \u0060let pi = 3.14159\u0060, so you can just use \u0022pi\u0022 instead of the number.\n* This improves readability and keeps the function modular.\n* By defining pi inside of the scope of \u0060calculateCylinderVolume\u0060 it cannot be accessed from outside, keeping your overall code nice and clean.\n\n\n*)\n\n// A chessboard is a 8x8 field. The rows and columns have the indices 0 - 7.\n// Create a function, which should return true if two queens can hit each other or false if they can\u0027t.\n// The functions parameters should be two Tuples (int*int).\n\nlet canHit (queen1 : int*int) (queen2 : int*int) =\n    let (posX1, posY1),(posX2, posY2)= (queen1,queen2)\n    if \n        // check if both queens are on the same x-axis\n        (posX1 = posX2) \n        // check if both queens are on the same y-axis\n        || (posY1 = posY2) \n        // check if both queens are on the same diagonal\n        || (abs (posX1 - posX2) = abs (posY1 - posY2))\n    then\n        printfn \u0022Both queens can hit each other\u0022\n        true\n    else \n        printfn \u0022Both queen cannot hit each other\u0022\n        false\n        \ncanHit (3,5) (5,7)\n\n(*** include-it ***)\n(*** include-output ***)\n\n(**\n\n## Excercises \n\n### Task 1\n\n*)\n\n// Bind a String of your name (\u0022Name\u0022) to the name \u0027myFirstName\u0027.\n\n// Solution\n\nlet myFirstName = \u0022Kevin\u0022\n\nmyFirstName\n\n(*** include-it ***)\n\n(**\n### Task 2\n*)\n\n// Define a variable \u0027myName\u0027, by adding \u0027myFirstName\u0027 to the rest of your name.\n\n// Solution\n\nlet myName = myFirstName \u002B \u0022 Frey\u0022\n\nmyName\n\n(*** include-it ***)\n\n(** \n### Task 3\n*)\n\n// Define a variable \u0027summeXY\u0027 as the sum of any two Integer numbers. Do this, by defining x and y as separate \n// let - bindings inside the functional scope of the \u0027summeXY\u0027 function. \n// (The function MUST contain three let - bindings)\n\n// Solution\n\nlet summeXY =\n    let x = 2\n    let y = 34\n    x \u002B y\n\n\n(*** include-value:summeXY ***)\n\n(** \n### Task 4\n*)\n\n// Declare a Tuple, consisting of 2 and \u0022February\u0022 and bind the Tuple to the name \u0027tuple1\u0027\n\n// Solution \n\nlet tuple1 = (2,\u0022February\u0022)\n\n(*** include-value:tuple1 ***)\n\n(**\n### Task 5\n*)\n\n// Declare a Tuple, consisting of 2, \u0022February\u0022 and \u0022spring\u0022 and bind the Tuple to the name \u0027tuple2\u0027\n\n// Solution \n\nlet tuple2 = (2,\u0022February\u0022,\u0022spring\u0022)\n\n(*** include-value:tuple2 ***)\n\n(**\n### Task 6 \n*)\n\n// Access the second variable of the Tuple \u0027tuple1\u0027.\n// Access the second variable of the Tuple \u0027tuple2\u0027.\n\n// Solution \n\nlet solution1 = snd tuple1\n\nlet solution2 = (fun (x,y,z) -\u003E y) tuple2 // or: let (x,y,z) = tuple2\n\n(*** include-value:solution1 ***)\n(*** include-value:solution2 ***)\n\n(** \n### Task 7\n*)\n\n// Create a Record Type with the name \u0027Month\u0027. \u0027Month\u0027 should contain the fields \u0027Number\u0027 (int),\n// \u0027Name\u0027 (string) and \u0027Season\u0027 (string).\n\n// Solution\n\ntype Month =\n    {\n        Number: int\n        Name:   string\n        Season: string\n    }\n    \n(** \n### Task 8\n*)\n\n// Declare a function \u0027createMonth\u0027 with three input parameters and which should return a \u0027Month\u0027 - Record Type.\n// Use the values from \u0027tuple2\u0027 and create a month with these as input.  \n\n// Solution\n\nlet createMonth number name season =\n    {\n        Number = number\n        Name   = name\n        Season = season\n    }\n    \nlet feb = createMonth 2 \u0022February\u0022 \u0022spring\u0022\nfeb\n\n(*** include-value:feb ***)\n\n(** \n### Task 9\n*)\n\n// Create a function called \u0027myMonthsPrinter\u0027 which should take a \u0027Month\u0027 as input and return a unit output \n// (printfn - command) in the form of \u0022My favorite month is [Month Name]. It is the [Number of Month] month\n// in the year and i especially like this time because it is part of [Season].\u0022\n\n// Solution\n\nlet myMonthsPrinter (month:Month) =\n    printfn \u0022\n        My favorite month is %s. It is the %i month in the year \n        and i especially like this time because it is part of %s.\u0022\n        month.Name\n        month.Number\n        month.Season\n        \nmyMonthsPrinter feb\n\n(*** include-output ***)\n\n(** \n### Task 10\n*)\n\n// We want to put additional emphasis on readability of code ...\n\n// Oh no, the following function is not readable. Write the function new and use pipe operators!\n\nlet unreadableFunc x = (string ((x - 7) * 2) \u002B \u0022Generic\u0022).ToUpper().ToCharArray()\n\n// Solution\n\nlet readableFunc (x:int) = \n    x\n    |\u003E fun x -\u003E x - 7\n    |\u003E fun x -\u003E x * 2\n    |\u003E string\n    |\u003E fun x -\u003E x \u002B \u0022Generic\u0022\n    |\u003E fun x -\u003E x.ToUpper().ToCharArray()\n    \nreadableFunc 4 = unreadableFunc 4\n\n(*** include-it ***)\n\n(** \n### Task 11\n*)\n\n// Create a function \u0027replaceSmallNumbers\u0027, which should replace all \n// integers in a list with a 0 if the integer is smaller than 5.\n\nlet numList = [0 .. 20]\n\n// Solution\n\nlet replaceSmallNumbers (numList:int list) =\n    numList\n    |\u003E List.map (\n        fun x -\u003E\n            if x \u003C 5 then\n                0\n            else x\n        )\n    \nreplaceSmallNumbers numList\n\n(*** include-it ***)"},{"uri":"/BIO-BTE-06-L-7/JP07_Signal_detection_and_quantification.html","title":"JP07 Signal detection and quantification\n","content":"(**\n# JP07 Signal detection and quantification\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP07_Signal_detection_and_quantification.ipynb)\n\n1. Signal detection and quantification\n\n*)\n\n(**\n## Signal detection and quantification\n\nSignals detected during a LC-MS measurement are pairs of m/z value and ion intensity in time. All signals recorded at a particular retention \ntime in a given mass range compose a spectrum. Thus, in its most raw form, a generic spectrum contains the following information: (i) scan \n(spectra) number; (ii) retention time; (iii) vector of m/z values; (iv) vector of ion intensities; (v) scan mode. The scan number is a simple \nenumeration over the measurements. The retention time is the time when the measured peptides were eluting from the column. The m/z values \nrepresent the mass over charge values of the ions and ion intensity values are the corresponding ion abundances. The scan mode denotes the \noperational mode used to record the spectrum. It is either a full scan or the number of the fragmentation scan.\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/MSDerivedDataSpaces.PNG)\n\n**Figure 3: A conceptual view of different spaces of MS derived data sets.**\n(i) The metadata-space serves as a descriptive layer to order, assign and integrate spectra information. (ii) \nThe MS1-space and the (iii) MS2-space represent two independent entities that differ in signal shape, resolution and their \ninformation content (\u2018features\u2019).\n*)"},{"uri":"/BIO-BTE-06-L-7/JP02_Plant_Systems_Biology.html","title":"JP02 Plant Systems Biology\n","content":"(** \n# JP02 Plant Systems Biology\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP02_Plant_Systems_Biology.ipynb)\n\n\n1. Plant Systems Biology\n2. Modeling growth for a defined cell number\n1. Insert Growth Data and Display as Chart\n2. Calculation of growth rate and doubling time for cell cultures\n3. Fitting biological growth curves\n    1. Theory\n    2. Model selection\n    3. Exponential Fit\n4. Calculate Doubling Time\n5. References\n\n*)\n\n(** \n## Plant Systems Biology\n\nThe general paradigm of Systems Biology clearly applies to plants, as they represent complex biological systems. \nThe functioning of a plant as a biological system is the result of a combination of multiple intertwined and dynamic interactions between its components. \nIn addition, most plants are sessile systems that have to face fluctuating environmental conditions, including biotic and abiotic stresses (Ruffel et al. 2010).\nThe process of a biological system responding to changes in environmental conditions is termed acclimation. These molecular physiological responses represent a complex \ndynamic adjustment of the interplay between genes, proteins and metabolites that allows the organism to acclimate to the changing environment. \nThe ability to acclimate ensures the survival of all living organisms and is therefore fundamental for the understanding of biological systems. \nDetailed knowledge about how plants acclimate to a changing environment is crucial especially in times of global climate changes, \nas plants are of great importance for our quality of life as a key source of food, shelter, fiber, medicine, and fuel (Minorsky 2003).\n\nThe prominent model plant *Arabidopsis thaliana* is well suited for plant Systems Biology studies because sophisticated experimental tools and extensive data \ncollections are readily available (Van Norman et al. 2009). However, the importance of a model organism is not only coined by the availability of molecular \ntools to manipulate the organism, but also by its agricultural and economic impact like in the cases of tobacco, rice, maize or \nbarley (P\u00E3curar 2009). Also microalgae are of special economic interest due to their potential as biofuel producers (Cagnon et al. 2013). \nAdditionally, the use of organisms with lower biological complexity facilitates the feasibility of System Biology studies and is an important factor to consider \nfor the choice of a suitable model organism in Systems Biology.\n\nThe eukaryotic green alga *Chlamydomonas reinhardtii* is particularly well suited for plant Systems Biology approaches. \nThis unicellular freshwater and soil-dwelling alga has a single, cup-shaped chloroplast with a photosynthetic apparatus that is similar to \nthat of higher plants (Eberhard et al. 2008, Merchant et al. 2007). Hence, results gained on photosynthesis processes in *Chlamydomonas* \nare likely to be transferable to higher plants. The nuclear, mitochondrial, and chloroplast genomes have been sequenced and tools for manipulating them \nare available (Merchant et al. 2007). *Chlamydomonas* cells have a size of ~10 \u00B5m and grow under photo-, mixo-, and heterotrophic conditions \nwith a generation time of ~5-8 h (Harris, 2008). *Chlamydomonas* can be maintained under controlled conditions and environmental \nchanges can be applied homogeneously and rapidly to all cells in a liquid culture. In contrast to multicellular organisms there are no influences by \ntissue heterogeneity. Even the influence of different cell cycle stages may be ruled out by performing experiments with asynchronous cell cultures \n(Bruggeman and Westerhoff 2007, Harris 2001). Finally, gene families in *Chlamydomonas* have fewer members than those in higher plants thus facilitating the \ninterpretation of results involving many genes/proteins (Merchant et al. 2007).\n*)\n\n(** \n## Modeling growth for a defined cell number\n\nIn order to solves real world task more convenient, F# provides a huge collection of additional programming libraries. \nAnything that extends beyond the basics must be written by a user. If the chunk of code is useful to multiple different users, \nit\u0027s often put into a library to make it easily reusable. A library is a collection of related pieces of code that have been compiled \nand stored together in a single file and can than be used an included. The most important libraries in F# for bioinformatics are:\n\n\n* [BioFSharp](https://csbiology.github.io/BioFSharp/): Open source bioinformatics and computational biology toolbox written in F#\n* [FSharp.Stats](https://github.com/fslaborg/FSharp.Stats): F# project for statistical computing\n* [Plotly.NET](https://github.com/plotly/Plotly.NET): .NET interface for plotly.js written in F# \uD83D\uDCC8\n\n\nThe first real world use case of F# in Systems Biology is to model growth for a defined cell number to see possible overexpression effects. \nBiologists often utilize growth experiments to analyze basic properties of a given organism or cellular model. For a solid comparison of data \nobtain from different experiment and to investigate the speci\uFB01c e\uFB00ect of a given experimental set up, modeling the growth is needed after recording the data. \n\nThis notebook introduces two basic ways to model growth of *Chlamydomonas reinhardtii* using F#.\n\nNow, let\u0027s get started by loading our libraries first.\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Plotly.NET\nopen FSharp.Stats\nopen FSharp.Stats.Fitting.NonLinearRegression\n\n(** \n## Insert Growth Data and Display as Chart\n\nA normal cell culture experiment with measurements for the growth curve will return data like the following.\nMultiple cell counts (\u0060y_Count\u0060) each related to a specific timepoint (\u0060x_Hours\u0060).\n*)\n// Code-Block 1\n\nlet exmp_x_Hours = [|0.; 19.5; 25.5; 43.; 48.5; 51.25; 67.75|]\nlet exmp_y_Count = [|1659000.; 4169000.; 6585400.; 16608400.; 17257800.; nan; 18041000.|]\n\n/// filter out any nans. These could be introduced through missing measurements.\nlet exmp_x_Hours_Filtered,exmp_y_Count_Filtered =\n    Array.zip exmp_x_Hours exmp_y_Count\n    |\u003E Array.filter (fun (x,y) -\u003E isNan y = false \u0026\u0026 isNan x = false )\n    |\u003E Array.unzip\n\n// Such data can easily be display with the following code block.\n// Chart.Point takes a sequence of x-axis-points and a series of y-axis-points as input\nlet example_Chart_1 = \n    Chart.Point(exmp_x_Hours_Filtered,exmp_y_Count_Filtered)\n    // some minor styling with title and axis-titles.\n    |\u003E Chart.withTitle \u0022Growth curve of *Clamydomonas reinhardtii* cell cultures\u0022\n    |\u003E Chart.withX_AxisStyle (\u0022Number of cells\u0022)\n    |\u003E Chart.withY_AxisStyle (\u0022Time [hours]\u0022)\n\n(***hide***)\nexample_Chart_1 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Calculation of growth rate and doubling time for cell cultures\n\nThe normal growth of an in vitro cell culture is defined through three phases. The lag phase in which the cells still acclimate to the growth conditions, the exponential growth, \nalso called log phase, during which cell growth is exponential due to the proliferation of cells into two daughter cells, and the stationary phase in which the growth rate and the \ndeath rate are equal. The stationary phase is typically initiated due to limitations in growth conditions, e.g. depletion of essential nutrients or accumulation of toxic/inhibitory \nexcretions/products. The doubling time defines a time interval in which the quantity of cells doubles and is calculated as seen in Equation 1.\n\n*Equation 1: Calculation of the doubling time. Growth rate is calculates as shown in Equation 2.*\n\n![](https://latex.codecogs.com/gif.latex?doubling\u0026space;Time\u0026space;=\u0026space;\\frac{ln(2)}{growthRate})\n\nGrowth rate can then be calculated as shown in Equation 2.\n\n*Equation 2: Calculation of the growth rate. With N(t) = the number of cells at time t, N(0) = number of cells at time 0, gr = growth rate, and t = time.*\n\n![](https://latex.codecogs.com/gif.latex?gr=\\frac{ln(\\frac{N(t)}{N(0)})}{t})\n*)\n\n(** \n## Fitting biological growth curves\n\n\n### Theory\n\nTo derive parameters required for e.g. the doubling time calculation, the measured growth data points have to be modelled. \nIn order to obtain a continuous function with known coefficients, a suitable model function is fitted onto the existing data. \nMany models exist, each one of them optimized for a specific task (Kaplan et al. 2018).\n\nLinear model function example: ![](https://latex.codecogs.com/gif.latex?f(x)\u0026space;=\u0026space;mx\u0026space;\u0026plus;\u0026space;b)\n \nWhen a model is fitted onto the data, there are endless possibilities to choose coefficients of the model function. \nIn the case above there are two coefficients to be identified: The slope m and the y-intercept b. But how can the best fitting coefficients be determined?\n\nTherefore a quality measure called ***Residual Sum of Squares (RSS)*** is used. It describes the discrepancy of the measured points \nand the corresponding estimation model. If the discrepancy is small, the RSS is small too.\n\nIn regression analysis the optimal set of coefficients (m and b) that [minimizes the RSS is searched](https://mathworld.wolfram.com/LeastSquaresFitting.html).\n\nIf there is no straightforward way to identify the RSS-minimizing coefficient set, then the problem is part of nonlinear regression. \nHere, initial coefficients are guessed and the RSS is calculated. Thereafter, the coefficients are modified in tiny steps. \nIf the RSS decreases, the direction of the coefficient change seems to be correct. \nBy [iteratively changing coefficients](https://books.google.de/books?id=rs51DwAAQBAJ\u0026pg=PA422\u0026lpg=PA422\u0026dq=rss\u002Bminimizing\u002Bsolver\u0026source=bl\u0026ots=qZ0Y4cYtM-\u0026sig=ACfU3U0rHGWCmTo_kv5wqYMmSo8ZKyj5Pg\u0026hl=de\u0026sa=X\u0026ved=2ahUKEwjKtdf-oaHoAhUUwsQBHX07DTwQ6AEwBHoECAkQAQ#v=onepage\u0026q=rss%20minimizing%20solver\u0026f=false)\n, the optimal coefficient set is determined when no further change leads to an decrease in RSS. \nAlgorithms, that perform such a \u0027gradient descent\u0027 methods to solve nonlinear regression tasks are called ***solver*** \n(e.g. Gauss-Newton algorithm or Levenberg\u2013Marquardt algorithm). [Introduction to RSS and optimization problems.](https://www.youtube.com/watch?v=sDv4f4s2SB8)\n\n### Model selection\n\nUnder certain circumstances, more than one solution may arise out of a optimization process. \nIf the solutions are based on the same data and the same fitting model, the function minimizing the RSS can be selected as best estimator. \n\n### Exponential Fit\n\nSince cellular growth behaves in an exponential manner, it seems to make sense to use an exponential fitting function. \n\n![](https://latex.codecogs.com/gif.latex?f(x)\u0026space;=\u0026space;ae^{bx}\u0022 title=\u0022f(x) = ae^{bx})\n\nAs seen below, the resulting [exponential fit](https://da.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth) does not represent the data \nsufficiently, even though it is the best fit, that a exponential model can provide. This is caused by the lag- and stationary phase, both not following an exponential increase. \nIn order to use an exponential function as model, it would be necessary to discard data points from lag- and stationary phases and model the remaining data points. \n\n \nThere are two main problems regarding this workflow: \n\n1. The assignment of points to lag-, log-, and stationary phases is a nontrivial task.\n2. The exponential phase only lasts a short period of time and therefore the number of points that can be assigned to the log phase is (very) low.\n\nConsequential the fitted function is not robust against variance introduced during cell count measurements.\n\n\n*)\n\n// Code-Block 2\n\n// An template exponential function has the form f(x) = a * exp(b * x) with the two unknowns a and b. \n\n// The model we need already exists in FSharp.Stats and can be taken from the \u0022Table\u0022 module.\nlet expModel = Table.expModel\n\n// the solver needs additional information like the initial coefficient guesses or the coefficient accuracy\n// FSharp.Stats assists by estimating the required parameters based on the original input data\nlet solverOptions = Table.expSolverOptions exmp_x_Hours_Filtered exmp_y_Count_Filtered\n\n// The Gauss-Newton solver is used to find the optimal coefficients for an exponential function (expModel)\n// The result is a vector, containing parameter a and b as floats.\nlet coefficientsExp = GaussNewton.estimatedParams expModel solverOptions exmp_x_Hours_Filtered exmp_y_Count_Filtered\n\n// The determined coefficients can be inserted into the exponential template function\nlet fittingExpFunction x = coefficientsExp.[0] * System.Math.Exp(coefficientsExp.[1] * x)\n\n// create a chart with \nlet exp_Chart_1 = \n    [|0. .. (Array.last exmp_x_Hours_Filtered)|]\n    |\u003E Array.map (fun xValue -\u003E xValue,fittingExpFunction xValue) // gives tuples of (xValue,yValue)\n    |\u003E Chart.Line\n    |\u003E Chart.withTraceName \u0022exponential fit\u0022\n\n// styling of the chart axis\nlet templateAxis title = Axis.LinearAxis.init(Title=title,Showgrid=false,Showline=true,Mirror=StyleParam.Mirror.All)       \n\nlet exponentialFitChart =\n    [\n        example_Chart_1\n        |\u003E Chart.withTraceName \u0022data points\u0022\n        exp_Chart_1\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_Axis (templateAxis \u0022time [hours]\u0022)\n    |\u003E Chart.withY_Axis (templateAxis \u0022number of cells\u0022)\n    |\u003E Chart.withSize (900.,600.)\n\n(***hide***)\nexponentialFitChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n    \n(**\n## Logistic regression fit\n\nAs seen above, the model selection is a crucial step for obtaining reasonable functions and to derive function properties with \nwhich further studies are examined. The selected model should match the theoretical (time) course of the studied signal, but under \nconsideration of Occams razor principle. It states, that a approriate model with a low number of coefficients should be preferred over a \nmodel with many coefficients, since the excessive use of coefficients leads to overfitting.\n\nA better model that can be used in growth curve fitting, is a [logistic function](https://en.wikipedia.org/wiki/Logistic_function). \nIt is defined by a minimum, a maximum, and a sigmoidal transition between those two. Thereby, the lag, log, and stationary phase are covered.\n\nThe function has the form: \u0022[](https://latex.codecogs.com/gif.latex?f(x)=\\frac{L}{1\u0026plus;e^{-k(x-x_{0})}}\u0026plus;N\u0022 title=\u0022f(x)=\\frac{L}{1\u002Be^{-k(x-x_{0})}}\u002BN)\n\nwhere:\n\n***L*** = curve maximum\n\n***k*** = steepness\n\n***x0*** = xValue of sigmoid\u0027s midpoint\n\n***N*** = curve minimum\n\nIn the following, we will go through the necessary steps to calculate the doubling time with the help of a logistic fit. \nThis is more complex than the exponential fit, but the given problem requires a more sophisticated method.\n*)\n\n// Code-Block 3\n\n// The model we need already exists in FSharp.Stats and can be taken from the \u0022Table\u0022 module.\nlet modelLogistic = Table.LogisticFunctionVarYAscending\n\n// To fit the logistic function, the solver requires more parameters. Some of them are stored in the solverOption type\nlet lineSolverOptions initialParamGuess = {\n    // defines the stepwidth of the x_value change\n    MinimumDeltaValue       = 0.00001\n    // defines the stepwidth of the parameter change\n    MinimumDeltaParameters  = 0.00001\n    // defines the number of iterations until the solver converges to a solution\n    MaximumIterations       = 10000\n    // initial parameters to start the solving algorithms\n    // vector containing all coefficients of the function: vector [L;k;x0;N]\n    InitialParamGuess       = initialParamGuess\n    }\n\n// Generation of solverOptions with varying steepnesses\nlet initialGuess = \n    // maximum measured intensity/cell count\n    let l  = exmp_y_Count_Filtered |\u003E Array.max\n    // estimate of the xValue of sigmoid\u0027s midpoint\n    let x0 = (exmp_x_Hours_Filtered |\u003E Array.max) / 2.\n    // minimum measured intensity/cell count.\n    let n  = exmp_y_Count_Filtered |\u003E Array.min \n    \n    //since steepness in unknown, a variety of steepnesses is provided \n    let steepnessRange = [|0.01 .. 0.01 .. 1.|]\n    \n    steepnessRange\n    |\u003E Array.map (fun steepness -\u003E lineSolverOptions [|l; steepness; x0; n|])\n\n// Estimate coefficients for a possible solution based on residual sum \n// of squares. Besides the solverOptions, an upper and lower bound for \n// the parameters are required. It is recommended to define them depending \n// on the initial param guess.\n// It reports coefficients tupled with a corresponding RSS value.\nlet estimateCoefficientsRSS =\n    initialGuess\n    |\u003E Array.map (fun solvOpt -\u003E\n        let lowerBound =\n            solvOpt.InitialParamGuess\n            |\u003E Array.map (fun param -\u003E param - (abs param) * 0.2)\n            |\u003E vector\n        let upperBound =\n            solvOpt.InitialParamGuess\n            |\u003E Array.map (fun param -\u003E param \u002B (abs param) * 0.2)\n            |\u003E vector\n        // all parameters are given to the solver and the set of coefficients that minimize the RSS are reported\n        LevenbergMarquardtConstrained.estimatedParamsWithRSS \n            modelLogistic         // logistic function model\n            solvOpt               // solver options with optimization parameters and initial guess\n            0.001                 //\n            10.                   //\n            lowerBound            // lower bound of coefficient space\n            upperBound            // upper bound of coefficient space\n            exmp_x_Hours_Filtered // x data\n            exmp_y_Count_Filtered // y data\n    )\n    |\u003E Array.filter (fun (coeffs,rss) -\u003E not(coeffs |\u003E Vector.exists System.Double.IsNaN)) // discard solutions with nan as coefficients\n    |\u003E Array.minBy snd // minimize all possible solutions based on RSS quality measure\n    |\u003E fun (solCoeffs,rss) -\u003E\n        printfn \u0022Chosen Estimate: %A\u0022 solCoeffs\n        printfn \u0022Equation: (%.1f / (1. \u002B exp(-%.3f * (x - %.3f)))) \u002B %.1f\u0022 solCoeffs.[0] solCoeffs.[1] solCoeffs.[2] solCoeffs.[3]\n        solCoeffs\n        \n// Create fitting function from optimal coefficients\nlet fittingLogisticFunction = modelLogistic.GetFunctionValue estimateCoefficientsRSS\n\n// Code-Block 4\n\n// fit of the optimized logistic function over all x Values\nlet fittedY = \n     [|0. .. exmp_x_Hours |\u003E Array.max|]\n     |\u003E Array.map (fun x -\u003E x, fittingLogisticFunction x) //tupled (xValue,yValue)\n\nlet fittedLogisticFunc =\n    [\n        // raw chart\n        Chart.Point (exmp_x_Hours, exmp_y_Count) |\u003E Chart.withTraceName\u0022data points\u0022\n        // logistic fit\n        Chart.Line fittedY                       |\u003E Chart.withTraceName \u0022logistic fit\u0022\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withY_Axis (templateAxis \u0022cell count\u0022)\n    |\u003E Chart.withX_Axis (templateAxis \u0022time [Hours]\u0022)\nfittedLogisticFunc\n(***hide***)\nfittedLogisticFunc |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n    \n## Calculate Doubling Time\n\nTo calculate the doubling time it is necessary to determine the growth rate (gr) for *equation 1*.\nTo get gr we make use of the first and second derivative of the logistic function. They can be calculated by hand or with help \nof [derivative calculator](https://www.ableitungsrechner.net/).\n\nThe first derivative of the logistic function is: \n\n![](https://latex.codecogs.com/gif.latex?\\dfrac{kl\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u0026plus;1\\right)^2}\u0022 title=\u0022\\dfrac{kl\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u002B1\\right)^2})\n\nThe second derivative of the logistic function is: \n\n![](https://latex.codecogs.com/gif.latex?-\\dfrac{k^2l\\left(\\mathrm{e}^{k\\left(x-m\\right)}-1\\right)\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u0026plus;1\\right)^3}\u0022 title=\u0022-\\dfrac{k^2l\\left(\\mathrm{e}^{k\\left(x-m\\right)}-1\\right)\\mathrm{e}^{k\\left(x-m\\right)}}{\\left(\\mathrm{e}^{k\\left(x-m\\right)}\u002B1\\right)^3})\n*)\n\n// Code-Block 5\n\n// calculate fst derivative of logistic function\nlet fstDerivative x = \n    let l  = estimateCoefficientsRSS.[0]\n    let k  = estimateCoefficientsRSS.[1]\n    let x0 = estimateCoefficientsRSS.[2]\n    let n  = estimateCoefficientsRSS.[3]\n    let exp = System.Math.Exp(k*(x-x0))\n    - (k**2.*l*(exp - 1.)* exp ) / (exp \u002B 1.)**3.\n\n// calculate snd derivative of logistic function \nlet sndDerivative x = \n    let l  = estimateCoefficientsRSS.[0]\n    let k  = estimateCoefficientsRSS.[1]\n    let x0 = estimateCoefficientsRSS.[2]\n    let n  = estimateCoefficientsRSS.[3]\n    let exp = System.Math.Exp(k*(x-x0))\n    (k*l*exp) / (exp \u002B 1.)**2.\n\n// calculate derivatives to corresponding x values\nlet yValuesOfDerivative fkt = \n    [|0. .. 0.5 .. exmp_x_Hours |\u003E Array.max|]\n    |\u003E Array.map (fun x -\u003E x,fkt x)\n    \nlet fitAllLogisticFunc =\n    [\n        Chart.Line (yValuesOfDerivative fstDerivative)|\u003E Chart.withTraceName \u0022fst derivative\u0022\n        Chart.Line (yValuesOfDerivative sndDerivative)|\u003E Chart.withTraceName \u0022snd derivative\u0022\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withY_Axis (templateAxis \u0022slope or curvature\u0022)\n    |\u003E Chart.withX_Axis (templateAxis \u0022time [hours]\u0022)\nfitAllLogisticFunc\n(***hide***)\nfitAllLogisticFunc |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nWe define the region between the maximal and minimal curvature (second derivative) as the time period to derive the growth rate from. \nAn alternative is to just use the slope at the midpoint because this is the point of maximal slope (minimal generation time), but since \nthis calculation would be only dependent from this particular point we go for the more conservative approach.\n    \nWhen the xValues of the maximal curvatures are identified (either by calculus or by plotting the derivatives) the generation time calculation\n is straight forward ([Wikipedia - Doubling time](https://en.wikipedia.org/wiki/Doubling_time)).\n*)\n\n// Code-Block 6\n\n// The exponential phase is considered to be between the maximal positive curvature\n// and the minimal negative curvature of the fitting functions (other interpretations possible).\nlet xValuesOfMaximalCurvature = [| 23.5 ; 44.0 |]\n\nlet calculateDoublingTimeLogistic fittingFunction =\n\n    //https://en.wikipedia.org/wiki/Doubling_time\n    // -\u003E Cell culture doubling time\n    let growthRate nCells0 nCellsT t =\n        log(nCellsT/nCells0)\n        |\u003E fun x -\u003E x/t\n\n    let doublingTime growthRate =\n        (log(2.))/growthRate\n\n    /// get the corresponding cell counts around the midpoint of the logistic function\n    let rootsYY = xValuesOfMaximalCurvature |\u003E Array.map fittingFunction\n    \n    /// calculate the time difference between both roots\n    let diff = xValuesOfMaximalCurvature.[1] - xValuesOfMaximalCurvature.[0]\n    \n    /// get the minimum measured cell count and the maximum measured cell count\n    let min,max = rootsYY.[0], rootsYY.[1]\n\n    let doublingTime =\n        growthRate min max diff\n        |\u003E doublingTime\n\n    doublingTime\n    \nlet doublingTime = \n    calculateDoublingTimeLogistic fittingLogisticFunction\n    \nsprintf \u0022The doubling time is %.2f hours.\u0022 doublingTime\n\n(*** include-it ***)\n\n\n(**\n## References\n\n8. Ruffel, S., Krouk, G. \u0026 Coruzzi, G. M. A systems view of responses to nutritional cues in Arabidopsis: toward a paradigm shift for predictive network modeling. Plant physiology 152, 445\u2013452; 10.1104/pp.109.148502 (2010).\n9. Minorsky, P. V. Achieving the in Silico Plant. Systems Biology and the Future of Plant Biological Research. Plant physiology 132, 404\u2013409; 10.1104/pp.900076 (2003).\n10. Van Norman, Jaimie M \u0026 Benfey, P. N. Arabidopsis thaliana as a model organism in systems biology. Wiley interdisciplinary reviews. Systems biology and medicine 1, 372\u2013379; 10.1002/wsbm.25 (2009).\n11. P\u00E3curar, D. I. Model organisms - a journey from the dawn of biological research to the post-genomic era. Romanian Society of Biological Sciences, 4087\u20134094 (2009).\n12. Cagnon, C. et al. Development of a forward genetic screen to isolate oil mutants in the green microalga Chlamydomonas reinhardtii. Biotechnology for biofuels 6, 178; 10.1186/1754-6834-6-178 (2013).\n13. Eberhard, S., Finazzi, G. \u0026 Wollman, F.-A. The dynamics of photosynthesis. Annual review of genetics 42, 463\u2013515; 10.1146/annurev.genet.42.110807.091452 (2008).\n14. Merchant, S. S. et al. The Chlamydomonas genome reveals the evolution of key animal and plant functions. Science (New York, N.Y.) 318, 245\u2013250; 10.1126/science.1143609 (2007).\n15. Harris, E. H. The chlamydomonas sourcebook. 2nd ed. (Academic, London, 2008).\n16. Bruggeman, F. J. \u0026 Westerhoff, H. V. The nature of systems biology. Trends in microbiology 15, 45\u201350; 10.1016/j.tim.2006.11.003 (2007).\n17. Harris, E. H. CHLAMYDOMONAS AS A MODEL ORGANISM. Annual review of plant physiology and plant molecular biology 52, 363\u2013406; 10.1146/annurev.arplant.52.1.363 (2001).\n18. Kaplan, S. et al. Comparison of growth curves using non-linear regression function in Japanese squail. Journal of Applied Animal Research 46, 112-117; 10.1080/09712119.2016.1268965 (2018).\n*)"},{"uri":"/BIO-BTE-06-L-7/JP12_Targeted_quantification_of_photosynthetic_proteins_WC.html","title":"JP12 Targeted quantification of photosynthetic proteins (Whole Cell)\n","content":"(**\n# JP12 Targeted quantification of photosynthetic proteins (Whole Cell)\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP12_Targeted_quantification_of_photosynthetic_proteins_WC.ipynb)\n\n1. [General steps for targeted quantification](#General-steps-for-targeted-quantification)\n2. [Peptide Ratio Visualization](#Peptide-Ratio-Visualization)\n3. [Sample stability](#Sample-stability)\n*)\n\n(**\n## General steps for targeted quantification\n\n\n1. Read the output file of the QconQuantifier containing the raw peptide ion quantification.\n2. Performing a first data cleaning step\n3. Calculating the 14N/15N ratio per peptide ion per sample\n4. Aggregating the peptide ions to their corresponding peptide\n5. Calculating the average of the peptide quantification value for protein quantification\n6. Visually inspect the peptide/protein quantification\n\nFor the explorative data analysis, we are using \n[Deedle](http://bluemountaincapital.github.io/Deedle/tutorial.html).\nDeedle is an easy to use library for data and time series manipulation and for scientific programming. \nIt supports working with structured data frames, ordered and unordered data, as well as time series. Deedle is designed to work well for exploratory programming using F#.\n*)\n\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.2\u0022\n#r \u0022nuget: Deedle, 2.3.0\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Deedle\nopen BioFSharp\nopen FSharpAux\nopen FSharp.Stats\nopen Plotly.NET\nopen FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear\nopen System.IO\nopen BIO_BTE_06_L_7_Aux.FS3_Aux\n\n(**\nAt the start we have the output file of the QconQuantifier. We want to read the file, bind it to \n\u0060qConcatRawData\u0060 and group the rows by peptide sequence, modifcation (14N or 15N) and the charge state of the ion.\n*)\n\n// Code block 1\n\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/Group1/G1_1690WC1zu1_QuantifiedPeptides.txt\u0022|]\ndownloadFile path \u0022G1_1690WC1zu1_QuantifiedPeptides.txt\u0022 \u0022bio-bte-06-l-7/Group1\u0022\n\nlet qConcatRawData =\n    Frame.ReadCsv(path,separators=\u0022\\t\u0022)\n    // StringSequence is the peptide sequence\n    |\u003E Frame.indexRowsUsing (fun os -\u003E \n            os.GetAs\u003Cstring\u003E(\u0022StringSequence\u0022),\n            os.GetAs\u003Cbool\u003E(\u0022GlobalMod\u0022), \n            os.GetAs\u003Cint\u003E(\u0022Charge\u0022)\n        )\n        \nqConcatRawData\n|\u003E BIO_BTE_06_L_7_Aux.Deedle_Aux.formatAsTable\n|\u003E Chart.Show\n\n(***include-fsi-merged-output***)\n\n(**\nFrom literature we know that there are peptides with a very bad flyability \n(Hammel et al.). Additionally, there are extreme values only due to technical artifacts. Both should be avoided in further analysis:\n*)\n\n// Code block 2\n\nlet qConcatData =\n    qConcatRawData\n    |\u003E Frame.filterRows ( fun (sequence, gmod, charge) _ -\u003E \n        sequence \u003C\u003E \u0022EVTLGFVDLMR\u0022 \u0026\u0026 sequence \u003C\u003E \u0022AFPDAYVR\u0022 \n        )\n    |\u003E Frame.mapValues (fun x -\u003E  if x \u003C 2000000. \u0026\u0026 x \u003E 1. then x else nan)\n\n(**\nReading the sample description file provides us with a list of all measured files and additional information about the experiment (mixing ratio, strain, etc.) \n*)\n\n// Code block 3\n\n//FileName Experiment Content ProteinAmount[ug] Replicate\n\nlet path2 = Path.Combine[|directory;\u0022downloads/Group1/WC_SampleDesc.txt\u0022|]\ndownloadFile path2 \u0022WC_SampleDesc.txt\u0022 \u0022bio-bte-06-l-7/Group1\u0022\n\nlet sampleDesc = \n    Frame.ReadCsv(path2 ,separators=\u0022\\t\u0022,schema=\u0022Strain=string\u0022)\n    |\u003E Frame.indexRowsString \u0022RawFileName\u0022\n    \nsampleDesc.Print()\n\n(***include-fsi-merged-output***)\n\n(**\nWe map the list of filenames and get the corresponding 14N and 15N column series. \nThis allows us to calculate the 14N/15N ratio per peptide ion per sample.\n*)\n\n// Code block 4\n\nlet ionRatios = \n    sampleDesc\n    |\u003E Frame.mapRows (fun rawFileName _ -\u003E \n        let n14 = qConcatData.GetColumn\u003Cfloat\u003E(\u0022N14Quant_\u0022 \u002B rawFileName) \n        let n15 = qConcatData.GetColumn\u003Cfloat\u003E(\u0022N15Quant_\u0022 \u002B rawFileName)\n        n14 / n15 \n        )\n    |\u003E Frame.ofColumns\n    \nionRatios.Print()\n\n(***include-fsi-merged-output***)\n\n(**\nFrom our in silico protein digest during the design of the qConCat protein, \nwe know the peptide(s) \u0026rarr; protein relationship. We read this information from the \u0022PeptideProtMap.txt\u0022 file.\n*)\n\n// Code block 5\n\nlet path3 = Path.Combine[|directory;\u0022downloads/PeptideProtMap.txt\u0022|]\ndownloadFile path3 \u0022PeptideProtMap.txt\u0022 \u0022bio-bte-06-l-7\u0022\n\nlet peptideProtMapping =\n    Frame.ReadCsv(path3,hasHeaders=true,separators=\u0022\\t\u0022)\n    |\u003E Frame.indexRowsString \u0022Peptide\u0022\n    \npeptideProtMapping.Print()\n\n(***include-fsi-merged-output***)\n\n(**\nNext, we will aggregate the peptide ion ratios to obtain one ratio per peptide sequence despite the ion charge. For convenience, we join the protein names.\n*)\n\n// Code block 6\n\nlet peptideRatios = \n    ionRatios\n    |\u003E Frame.applyLevel (fun (sequence,globalMod,charge) -\u003E sequence) Stats.mean\n    |\u003E Frame.join JoinKind.Inner peptideProtMapping \n    |\u003E Frame.groupRowsByString \u0022Protein\u0022\n    |\u003E Frame.getNumericCols\n    |\u003E Frame.ofColumns\n    \npeptideRatios.Print()\n\n(***include-fsi-merged-output***)\n\n(**\nNow, we join the sample description with the data.\n*)\n\n// Code block 7\n\nlet peptideRatiosWithDesc = \n    peptideRatios\n    |\u003E Frame.nest\n    |\u003E Series.map (fun k v -\u003E \n        v\n        |\u003E Frame.transpose\n        |\u003E Frame.join JoinKind.Right sampleDesc\n        |\u003E Frame.indexRowsUsing (fun os -\u003E \n                os.GetAs\u003Cstring\u003E(\u0022Strain\u0022),\n                os.GetAs\u003Cfloat\u003E(\u0022Dilution\u0022)\n            )\n        |\u003E Frame.filterCols (fun ck cs -\u003E v.RowKeys |\u003E Seq.contains ck)\n        |\u003E Frame.transpose\n        )\n    |\u003E Frame.unnest\n    \npeptideRatiosWithDesc.Print()\n\n(***include-fsi-merged-output***)\n\n(**\nBy calculating the mean value per protein, we have two final tables with peptide and protein ratios:\n*)\n\n// Code block 8\n\nlet proteinRatiosWithDesc =\n    //peptideRatiosWithDesc\n    peptideRatiosWithDesc\n    |\u003E Frame.applyLevel fst Stats.mean\n    \nproteinRatiosWithDesc.Print()\n\n(***include-fsi-merged-output***)\n\n(**\nHere are functions and parameters which are used for the styling of the graphs.\n*)\n\n// Code block 9\n\nlet xAxis showGrid title titleSize tickSize = Axis.LinearAxis.init(Title=title,Showgrid=showGrid,Showline=true,Mirror=StyleParam.Mirror.All,Zeroline=false,Tickmode=StyleParam.TickMode.Auto,Ticks= StyleParam.TickOptions.Inside, Tickfont=Font.init(StyleParam.FontFamily.Arial,Size=tickSize),Titlefont=Font.init(StyleParam.FontFamily.Arial,Size=titleSize))\nlet yAxis showGrid title titleSize tickSize = Axis.LinearAxis.init(Title=title,Showgrid=showGrid,Showline=true,Mirror=StyleParam.Mirror.All,Tickmode=StyleParam.TickMode.Auto,Ticks= StyleParam.TickOptions.Inside,Tickfont=Font.init(StyleParam.FontFamily.Arial,Size=tickSize),Titlefont=Font.init(StyleParam.FontFamily.Arial,Size=titleSize))\n\nlet config = Config.init(ToImageButtonOptions = ToImageButtonOptions.init(Format = StyleParam.ImageFormat.SVG, Filename = \u0022praktikumsplot.svg\u0022), EditableAnnotations = [AnnotationEditOptions.LegendPosition])\n\n(**\n## Peptide Ratio Visualization\n\n\u0060createChartForPeptideComparison\u0060 creates a chart for the given protein comparing the ratios for each given strain. \nIt generates a chart for each strain showing the individual peptide ratios and their mean (protein ratio). It also compares the protein ratios for each strain.\n*)\n\n// Code block 10\n\n// create charts to compare rel quant per dilution in strains\nlet createChartForPeptideComparison (protString:string) (strainStrings:string []) =\n    \n    let protFrame =\n        peptideRatiosWithDesc.Nest()\n        |\u003E fun x -\u003E x.Get(protString)\n\n    let peptideStrings =\n        protFrame.RowKeys\n        |\u003E Array.ofSeq\n\n    let peptideRows : Series\u003Cstring,Series\u003C(string * float),float\u003E\u003E =\n        protFrame\n        |\u003E Frame.getRows\n\n    let protMeanFrame : Series\u003C(string * float),float\u003E =\n        proteinRatiosWithDesc.GetRow protString\n\n    let xyMean =\n        strainStrings\n        |\u003E Array.map (fun strain -\u003E\n            strain,\n            protMeanFrame\n            |\u003E Series.filter (fun k t -\u003E fst k = strain)\n            |\u003E fun x -\u003E x.Observations\n            |\u003E Seq.map (fun x -\u003E 1./snd x.Key, x.Value)\n            |\u003E Array.ofSeq\n        )\n\n    let xyMeanChart =\n        xyMean\n        |\u003E Array.map (fun (strain,xyMean) -\u003E\n            Chart.Scatter(xyMean,mode=StyleParam.Mode.Lines_Markers, MarkerSymbol = StyleParam.Symbol.Circle, Opacity=0.8)\n            |\u003E Chart.withTraceName (sprintf \u0022%s - %s\u0022 protString strain )\n        )\n        |\u003E Chart.Combine\n        |\u003E Chart.withX_Axis (xAxis false \u0022Means: \u003Csup\u003E14\u003C/sup\u003EN Sample/\u003Csup\u003E15\u003C/sup\u003EN QProtein ratio\u0022 20 16)\n        |\u003E Chart.withY_Axis (yAxis false \u0022\u003Csup\u003E14\u003C/sup\u003EN/\u003Csup\u003E15\u003C/sup\u003EN Quantification ratio\u0022 20 16)\n\n    strainStrings\n    |\u003E Array.map (fun strain -\u003E\n        let peptideCharts =\n            peptideStrings\n            |\u003E Array.map (fun peptide -\u003E\n                let strainValueSeries = \n                    peptideRows.[peptide] \n                    |\u003E Series.filter (fun k t -\u003E fst k = strain)\n                let xy =\n                    strainValueSeries.Observations\n                    |\u003E Seq.map (fun x -\u003E 1./snd x.Key, x.Value)\n                    |\u003E Array.ofSeq\n                Chart.Scatter(xy,mode=StyleParam.Mode.Markers, MarkerSymbol = StyleParam.Symbol.Cross)\n                |\u003E Chart.withTraceName (sprintf \u0022%s -  %s - %s\u0022 strain protString peptide)\n            )\n        let relMeanChart = \n            let xyMeanVals = Array.find (fun (x,y) -\u003E x = strain) xyMean |\u003E snd\n            Chart.Scatter(xyMeanVals,mode=StyleParam.Mode.Lines_Markers, MarkerSymbol = StyleParam.Symbol.Circle, Color=\u0022#366F8E\u0022, Opacity=0.8)\n            |\u003E Chart.withTraceName (sprintf \u0022Mean %s - %s\u0022 protString strain)\n        Array.append peptideCharts [|relMeanChart|]\n        |\u003E Chart.Combine\n        |\u003E Chart.withX_Axis (xAxis false (strain \u002B \u0022: \u003Csup\u003E14\u003C/sup\u003EN Sample/\u003Csup\u003E15\u003C/sup\u003EN QProtein ratio\u0022) 20 16)\n        |\u003E Chart.withY_Axis (yAxis false \u0022\u003Csup\u003E14\u003C/sup\u003EN/\u003Csup\u003E15\u003C/sup\u003EN Quantification ratio\u0022 20 16)\n    )\n    |\u003E Array.append [|xyMeanChart|]\n    |\u003E Chart.Stack(2,Space=0.2)\n    |\u003E Chart.withSize (1200.,900.)\n    |\u003E Chart.withTitle (sprintf \u0022Relative Quantification of %s\u0022 protString)\n    |\u003E Chart.withConfig config\n\n(**\n\u0060rbclChart\u0060 executes \u0060createChartForPeptideComparison\u0060 for rbcL and the strains 4A, 1690 and 1883. \nWith \u0060allCharts\u0060 you can generate charts for all proteins and strains (***Warning! This displays a lot of charts***).\n*)\n\n// Code block 11\n\nlet rbclChart = createChartForPeptideComparison \u0022rbcL\u0022 [|\u00224A\u0022;\u00221690\u0022;\u00221883\u0022|]\n\nrbclChart\n\n(***hide***)\nrbclChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n\n//let allCharts =\n//    let strains = \n//        peptideRatiosWithDesc.ColumnKeys\n//        |\u003E Seq.map fst\n//        |\u003E Seq.distinct\n//        |\u003E Array.ofSeq\n//        \n//    peptideRatiosWithDesc.RowKeys\n//    |\u003E Seq.map (fun (prot,pep) -\u003E\n//        createChartForPeptideComparison prot strains\n//    )\n//allCharts\n\n(**\n## Sample stability\n\nNext, we do a quality assessment for the whole-cell sample preparation. \nFor that we will do a linear regression of the RuBisCO subunits relative quantification (14N/15N) protein ratio in whole-cell samples.\n\nNext we need two peptides (in this case rbcl and rbcs) for the assessment. You can exchange them for other proteins if you want to.\n*)\n\n(**\nHere, we fit a linear function to our mean peptide ratios and dilution series for the first protein. The  x-values are our different dilutions and the y-values our ratios. We calculate the [goodness\n of the fit](https://en.wikipedia.org/wiki/Goodness_of_fit) (discrepancy between predicted and observed values) for each fit and and also the [pearson correlation coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient) (measure of the linear correlation between our ratios and dilution) for our values.\n*)\n\n// Code block 12\n\nlet calculateFit protName strainName (meanValueArray:(float*float) [])  =\n    let dilutionsSorted,strainVals =\n        meanValueArray\n        |\u003E Array.unzip\n    // RBCL Regression of relative quantification values\n    let RBCLcoeff = Univariable.coefficient (vector dilutionsSorted) (vector strainVals)\n    let RBCLfitFunc = Univariable.fit RBCLcoeff\n    let RBCLfitVals = dilutionsSorted |\u003E Array.map RBCLfitFunc\n    let RBCLdetermination = FSharp.Stats.Fitting.GoodnessOfFit.calculateDeterminationFromValue strainVals RBCLfitVals\n    let RBCLpearson = FSharp.Stats.Correlation.Seq.pearson strainVals dilutionsSorted\n    printfn \u0022%s - Pearson WholeCell %s: %f\u0022 strainName protName RBCLpearson\n    RBCLcoeff, RBCLfitVals, RBCLdetermination\n\nlet meanValuesFor protName strainName=\n    let meanSeries : Series\u003C(string * float),float\u003E = proteinRatiosWithDesc.GetRow protName\n    meanSeries\n    |\u003E Series.filter (fun k t -\u003E fst k = strainName)\n    |\u003E fun x -\u003E x.Observations\n    |\u003E Seq.map (fun x -\u003E 1./snd x.Key, x.Value)\n    |\u003E Array.ofSeq\n\nmeanValuesFor \u0022rbcL\u0022 \u00224A\u0022\n//|\u003E calculateFit \u0022rbcL\u0022 \u00224A\u0022\n\n(**\n\u0060chartRatios\u0060 generates charts for each given strain and our chosen proteins. \nEach chart contains a comparison of the two proteins, showing their mean data points, the linear fit and the goodness of the fit.\n*)\n\n// Code block 13\n\nlet chartRatios prot1 prot2 strain =\n    let prot1Vals = meanValuesFor prot1 strain\n    let prot2Vals = meanValuesFor prot2 strain\n\n    let (prot1Coeff:Vector\u003Cfloat\u003E),prot1FitVals,prot1Determination =\n        calculateFit prot1 strain prot1Vals\n\n    let (prot2Coeff:Vector\u003Cfloat\u003E),prot2FitVals,prot2Determination =\n        calculateFit prot2 strain prot2Vals\n\n    let dilutionsSorted,_ =\n        prot1Vals // or prot2Vals, does not matter, as we only want x-axis\n        |\u003E Array.unzip\n    [\n        Chart.Point (prot1Vals,Name = sprintf \u0022%s Quantified Ratios\u0022 prot1)\n        |\u003E Chart.withMarkerStyle(Size=10,Symbol = StyleParam.Symbol.Cross)\n        Chart.Line(Array.zip dilutionsSorted prot1FitVals,Name = (sprintf \u0022%s linear regression: %.2f x \u002B (%2f) ; R = %.4f\u0022 prot1 prot1Coeff.[1] prot1Coeff.[0] prot1Determination))\n        |\u003E Chart.withLineStyle(Color=\u0022lightblue\u0022,Dash=StyleParam.DrawingStyle.DashDot)\n\n        Chart.Point (prot2Vals,Name = sprintf \u0022%s Quantified Ratios\u0022 prot2,MarkerSymbol = StyleParam.Symbol.Cross)\n        |\u003E Chart.withMarkerStyle(Size=10,Symbol = StyleParam.Symbol.Cross)\n        Chart.Line(Array.zip dilutionsSorted prot2FitVals,Name = (sprintf \u0022%s linear regression: %.2f x \u002B (%2f) ; R = %.4f\u0022 prot2 prot2Coeff.[1] prot2Coeff.[0] prot2Determination))\n        |\u003E Chart.withLineStyle(Color=\u0022LightGreen\u0022,Dash=StyleParam.DrawingStyle.DashDot)\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withTitle (sprintf \u0022%s - Whole cell extracts: Stability of %s/%s ratios between samples\u0022 strain prot1 prot2)\n    |\u003E Chart.withX_Axis (yAxis false \u0022\u003Csup\u003E14\u003C/sup\u003EN Sample/\u003Csup\u003E15\u003C/sup\u003EN QProtein ratio\u0022 20 16)\n    |\u003E Chart.withY_Axis (xAxis false \u0022relative quantification\u0022 20 16 )\n    |\u003E Chart.withConfig config\n    |\u003E Chart.withSize (1200.,500.)\n\n(**\nHere we display the chart of rbcl and rbcs for the strain 4A.\n*)\n\n// Code block 14\n\nchartRatios \u0022rbcL\u0022 \u0022RBCS2\u0022 \u00224A\u0022\n\n(***hide***)\nrbclChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n"},{"uri":"/BIO-BTE-06-L-7/JP03_Mass_spectrometry_based_proteomics.html","title":"JP03 Mass Spectrometry Based Proteomics\n","content":"(** \n\n# JP03 Mass Spectrometry Based Proteomics\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP03_Mass_spectrometry_based_proteomics.ipynb)\n\n1. Mass spectrometry (MS)-based proteomic\n6. References\n\n*)\n(**\n## Mass spectrometry (MS)-based proteomic\n\n![](https://raw.githubusercontent.com/CSBiology/BIO-BTE-06-L-7/main/docs/img/OmicsWorkflow.png)\n**Figure 2. Summary of a typical proteomics workflow following the bottom-up principle.**\n\nDuring sample preparation proteins are extracted from the samples and digested into peptides using proteases typically trypsin. An optional fractionation or enrichment may be applied at either the protein or peptide level to enhance the scope of identification. Peptides are separated by high-performance liquid chromatography (HPLC) and afterward transferred into the \nvacuum of the mass spectrometer mostly using electrospray ionization (ESI). Cycles of full MS including all peptide at a time followed by MS/MS of selected peptides are measured. \nThe consecutive measured MS and MS/MS spectra are then used to computationally identify and quantify the peptide sequence and infer the protein.\n\nThe proteome is understood as an entire complement of proteins in one cell, tissue or a whole organism. \nProteomics as a scientific field deals with the qualitative and quantitative analysis of protein expression patterns. \nThus, proteomics relies primarily on the ability to unambiguously identify proteins, followed by accurate quantification. \nMass spectrometry-based proteomics refers to the large-scale analysis of\nproteins using mass spectrometry, an analytical method to determine the mass of molecules. In the case of proteomics, the target \nmolecules are whole proteins or peptides.\n\nThe typical proteomics workflow is as follows (Figure 2): first, proteins are isolated from \ncells or tissues by lysis followed by biochemical fractionation or affinity selection. MS on whole proteins (top-down proteomics) \nis less sensitive and more difficult to handle when compared to MS on peptides (bottom-up proteomics), as the mass of the intact protein by \nitself is insufficient for protein identification (Breuker et al. 2008, Reid and McLuckey 2002). Therefore, the bottom-up approach is \nstandardly used, which comprises the enzymatic degradation of proteins to peptides using an endopeptidase (trypsin in most cases)\n (Olsen et al. 2004). Trypsin is advantageous as it generates peptides with C-terminally protonated amino acids to foster\n the detectability of a full ion ladder (series) in a subsequent, optional fragmentation step for sequencing. The peptides are separated by one\n or more steps of liquid chromatography (LC) and afterwards transferred into the vacuum of the mass spectrometer, where a mass spectrum\n of the peptides eluting at this time from the LC is taken (MSU\u002B00B9 spectrum or \u2018normal mass spectrum\u2019). A prioritized list of these peptides\n for fragmentation is either automatically generated or provided by the operator. These peptide ions are then fragmented by energetic collision with\n an inert gas and recorded as tandem MS spectra (MS/MS or MSU\u002B00B2 spectra). The consecutive MS and MS/MS\n spectra are then used to computationally identify the peptide\u2019s sequence and quantify its abundance (Walther and Mann 2010, Aebersold and Mann 2003).\n\n*)\n\n(** \n## References\n\n18. Breuker, K., Jin, M., Han, X., Jiang, H. \u0026 McLafferty, F. W. Top-down identification and characterization of biomolecules by mass spectrometry. Journal of the American Society for Mass Spectrometry 19, 1045\u20131053; 10.1016/j.jasms.2008.05.013 (2008).\n19. Reid, G. E. \u0026 McLuckey, S. A. \u0027Top down\u0027 protein characterization via tandem mass spectrometry. Journal of mass spectrometry : JMS 37, 663\u2013675; 10.1002/jms.346 (2002).\n20. Olsen, J. V., Ong, S.-E. \u0026 Mann, M. Trypsin cleaves exclusively C-terminal to arginine and lysine residues. Molecular \u0026 cellular proteomics : MCP 3, 608\u2013614; 10.1074/mcp.T400003-MCP200 (2004).\n21. Walther, T. C. \u0026 Mann, M. Mass spectrometry-based proteomics in cell biology. J. Cell Biol. 190, 491\u2013500; 10.1083/jcb.201004052 (2010).\n22. Aebersold, R. \u0026 Mann, M. Mass spectrometry-based proteomics. Nature 422, 198\u2013207; 10.1038/Nature01511 (2003).\n*)\n"},{"uri":"/BIO-BTE-06-L-7/JP12_Targeted_quantification_of_photosynthetic_proteins_SDS_IGD.html","title":"JP12 Targeted quantification of photosynthetic proteins (SDS in gel digest)\n","content":"(**\n# JP12 Targeted quantification of photosynthetic proteins (SDS in gel digest)\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/CSBiology/BIO-BTE-06-L-7/gh-pages?filepath=JP12_Targeted_quantification_of_photosynthetic_proteins_SDS_IGD.ipynb)\n\n1. [Relative Quantification between rbcL and rbcS](#Relative-Quantification-between-rbcL-and-rbcS)\u003Cbr\u003E\n2. [Compare 14N/15N for rbcL and rbcS](#Compare-14N/15N-for-rbcL-and-rbcS)\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: BioFSharp, 2.0.0-beta5\u0022\n#r \u0022nuget: BioFSharp.IO, 2.0.0-beta5\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: BIO-BTE-06-L-7_Aux, 0.0.1\u0022\n#r \u0022nuget: Deedle, 2.3.0\u0022\n\n#if IPYNB\n#r \u0022nuget: Plotly.NET, 2.0.0-beta6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-beta6\u0022\n#endif // IPYNB\n\nopen Deedle\nopen BioFSharp\nopen FSharpAux\nopen FSharp.Stats\nopen Plotly.NET\nopen FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear\nopen System.IO\nopen BIO_BTE_06_L_7_Aux.FS3_Aux\n\n(**\nAt start we have the output file of the QconQuantifier. We want to read the file, bind it to \u0060qConcatRawData\u0060 \nand group the rows by peptide sequence, modifcation (14N or 15N) and the charge state of the ion.\n*)\n\n// Code block 1\n\nlet directory = __SOURCE_DIRECTORY__\nlet path = Path.Combine[|directory;\u0022downloads/Group2/G2_L_4A_20myg_QuantifiedPeptides.txt\u0022|]\ndownloadFile path \u0022G2_L_4A_20myg_QuantifiedPeptides.txt\u0022 \u0022bio-bte-06-l-7/Group2\u0022\n\nlet qConcatRawData =\n    Frame.ReadCsv(path = path,separators=\u0022\\t\u0022)\n    // StringSequence is the peptide sequence\n    |\u003E Frame.indexRowsUsing (fun os -\u003E \n            os.GetAs\u003Cstring\u003E(\u0022StringSequence\u0022),\n            os.GetAs\u003Cbool\u003E(\u0022GlobalMod\u0022), \n            os.GetAs\u003Cint\u003E(\u0022Charge\u0022)\n        )\n        \nqConcatRawData\n\n(***include-it***)\n\n(**\nFrom literature we know that there are peptides with a very bad flyability (Hammel et al.). Additionally, \nthere are extreme values only due to technical artifacts. Both should be avoided in further analysis:\n*)\n\n// Code block 2\n\nlet qConcatData =\n    qConcatRawData\n    |\u003E Frame.filterRows ( fun (sequence, gmod, charge) _ -\u003E \n        sequence \u003C\u003E \u0022EVTLGFVDLMR\u0022 \u0026\u0026 sequence \u003C\u003E \u0022AFPDAYVR\u0022 \n        )\n    |\u003E Frame.mapValues (fun x -\u003E  if x \u003C 2000000. \u0026\u0026 x \u003E 1. then x else nan)\n    \nqConcatData\n\n(***include-it***)\n\n(**\nReading the sample description file provides us with a list of all measured files and additional information about \nthe experiment (mixing ratio, strain, etc.). Here you need to write ***YOUR*** filenames into the .txt file!\n*)\n\n// Code block 3\n\nlet path2 = Path.Combine[|directory;\u0022downloads/Group2/IGD_SampleDesc.txt\u0022|]\ndownloadFile path2 \u0022IGD_SampleDesc.txt\u0022 \u0022bio-bte-06-l-7/Group2\u0022\n\n//FileName CutOutBand Dilution Strain\nlet sampleDesc :Frame\u003Cstring,string\u003E= \n    Frame.ReadCsv(path = path2,separators=\u0022\\t\u0022,schema=\u0022Strain=string\u0022)\n    |\u003E Frame.indexRows \u0022RawFileName\u0022\n    \nsampleDesc\n\n(***include-it***)\n\n(**\nWe map the list of filenames and get the corresponding 14N and 15N column series. \nThis allows us to calculate the 14N/15N ratio per peptide ion per sample.\n*)\n\n// Code block 4\n\nlet ionRatios = \n    sampleDesc\n    |\u003E Frame.mapRows (fun rawFileName _ -\u003E \n        let n14 = \n            qConcatData.GetColumn\u003Cfloat\u003E(\u0022N14Quant_\u0022 \u002B rawFileName) \n            |\u003E Series.filterValues (fun x -\u003E  x \u003C 2000000. \u0026\u0026 x \u003E 1. )\n        let n15 = \n            qConcatData.GetColumn\u003Cfloat\u003E(\u0022N15Quant_\u0022 \u002B rawFileName) \n            |\u003E Series.filterValues (fun x -\u003E  x \u003C 2000000. \u0026\u0026 x \u003E 1. )\n        n14 / n15 \n        )\n    |\u003E Frame.ofColumns\n\nionRatios\n\n(***include-it***)\n\n(**\nFrom our in silico protein digest during the design of the qConCat protein, we know the peptide(s) \u0026rarr; \nprotein relationship. We read this information from the \u0022PeptideProtMap.txt\u0022 file.\n*)\n\n// Code block 5\n\nlet path3 = Path.Combine[|directory;\u0022downloads/PeptideProtMap.txt\u0022|]\ndownloadFile path3 \u0022PeptideProtMap.txt\u0022 \u0022bio-bte-06-l-7\u0022\n\nlet peptideProtMapping =\n    Frame.ReadCsv(path3,hasHeaders=true,separators=\u0022\\t\u0022)\n    |\u003E Frame.indexRowsString \u0022Peptide\u0022\n    \npeptideProtMapping\n\n(***include-it***)\n\n(**\nNext, we will aggregate the peptide ion ratios to obtain one ratio per peptide sequence despite the ion charge. For convenience, we join the protein names.\n*)\n\n// Code block 6\n\nlet peptideRatios = \n    ionRatios\n    |\u003E Frame.applyLevel (fun (sequence,globalMod,charge) -\u003E sequence) Stats.mean\n    |\u003E Frame.join JoinKind.Inner peptideProtMapping \n    |\u003E Frame.groupRowsByString \u0022Protein\u0022\n    |\u003E Frame.getNumericCols\n    |\u003E Frame.ofColumns\n    \npeptideRatios\n\n(***include-it***)\n\n(**\nNow, we join the sample description with the data. \n*)\n\n// Code block 7\n\nlet peptideRatiosWithDesc : Frame\u003C(string * string),(string * (string * float))\u003E=\n    peptideRatios\n    |\u003E Frame.mapColKeys (fun rk -\u003E\n        sampleDesc.GetColumn(\u0022CutOutBand\u0022).[rk],\n        (sampleDesc.GetColumn(\u0022Strain\u0022).[rk],\n         sampleDesc.GetColumn(\u0022Dilution\u0022).[rk])\n    )\n    \npeptideRatiosWithDesc\n\n(***include-it***)\n\n(**\n\nBy calculating the mean value per protein, we have two final tables with peptide and protein ratios:\n*)\n\n// Code block 8\n\nlet proteinRatiosWithDesc =\n    //peptideRatiosWithDesc\n    peptideRatiosWithDesc\n    |\u003E Frame.applyLevel fst Stats.mean\n    \nproteinRatiosWithDesc\n\n(**\n\nNext we want to compare the quantities between the cut-out band for rbcL and the cut-out band for rbcS. \nTherefore we divide the rbcL quantities from the rbcL cut-out by the rbcS quantities from the rbcS cut.out.\n*)\n\n// Code block 9\n\nlet calcultateRelativeQuantForCutOutsProteins (prot1) (prot2) frame =\n    let nestedFrame: Series\u003Cstring,Frame\u003C\u0027a,string\u003E\u003E =\n        frame\n        |\u003E Frame.transpose\n        |\u003E Frame.nest\n    nestedFrame.[\u0022RBCL\u0022] \n    |\u003E Frame.filterCols (fun ck cs -\u003E ck = prot1)\n    |\u003E Frame.mapCols (fun ck _ -\u003E\n        let rbclSeries =\n            nestedFrame.[\u0022RBCL\u0022].GetColumn\u003Cfloat\u003Eprot1\n        let rbcsSeries =\n            nestedFrame.[\u0022RBCS\u0022].GetColumn\u003Cfloat\u003Eprot2\n        rbclSeries / rbcsSeries\n    )\n    |\u003E Frame.mapColKeys (fun ck -\u003E prot1 \u002B \u0022/\u0022 \u002B prot2)\n    |\u003E Frame.transpose\n\nlet proteinRatiosWithDescCutOuts prot1 prot2=\n    proteinRatiosWithDesc\n    |\u003E calcultateRelativeQuantForCutOutsProteins prot1 prot2\n    \nlet rbclRBCS2 = proteinRatiosWithDescCutOuts \u0022rbcL\u0022 \u0022RBCS2\u0022\n\nrbclRBCS2\n|\u003E Frame.transpose\n\n(***include-it***)\n\n(**\nHere are functions and parameters which are used for the styling of the graphs.\n*)\n\n// Code block 10\n\nlet xAxis showGrid title titleSize tickSize = Axis.LinearAxis.init(Title=title,Showgrid=showGrid,Showline=true,Mirror=StyleParam.Mirror.All,Zeroline=false,Tickmode=StyleParam.TickMode.Auto,Ticks= StyleParam.TickOptions.Inside, Tickfont=Font.init(StyleParam.FontFamily.Arial,Size=tickSize),Titlefont=Font.init(StyleParam.FontFamily.Arial,Size=titleSize))\nlet yAxis showGrid title titleSize tickSize = Axis.LinearAxis.init(Title=title,Showgrid=showGrid,Showline=true,Mirror=StyleParam.Mirror.All,Tickmode=StyleParam.TickMode.Auto,Ticks= StyleParam.TickOptions.Inside,Tickfont=Font.init(StyleParam.FontFamily.Arial,Size=tickSize),Titlefont=Font.init(StyleParam.FontFamily.Arial,Size=titleSize))\n\nlet config = Config.init(ToImageButtonOptions = ToImageButtonOptions.init(Format = StyleParam.ImageFormat.SVG, Filename = \u0022praktikumsplot.svg\u0022), EditableAnnotations = [AnnotationEditOptions.LegendPosition])\n\n(**\n## Relative Quantification between rbcL and rbcS\nAt first we calculated the 14N/15N relative quantities for rbcL and rbcS. Then, as we normalized against the same \nQProtein we can now calculate the relation of subunits from rbcL and rbcS, both from their respective cut-out band.\n\nFirst we will access the data for rbcL and rbcS for a given strain from our Deedle frame.\n*)\n\n// Code block 11\n\n/////////////////////////////////// Chart Step 1 //////////////////////////////////////////\n\nopen FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear\n\n// access the data for rbcL and rbcS for a given strain\nlet meanValuesFor prot1Name prot2Name strainName=\n    let meanSeries : Series\u003C(string * float),float\u003E = rbclRBCS2.GetRow (prot1Name\u002B\u0022/\u0022\u002Bprot2Name)\n    meanSeries\n    |\u003E Series.filter (fun k t -\u003E fst k = strainName)\n    |\u003E fun x -\u003E x.Observations\n    |\u003E Seq.map (fun x -\u003E snd x.Key, x.Value)\n    |\u003E Array.ofSeq\n    \nlet testMeanValues =\n    meanValuesFor \u0022rbcL\u0022 \u0022RBCS2\u0022 \u00224A\u0022\n    \ntestMeanValues\n\n(***include-it***)\n\n(**\nIn addition we will display the pearson coefficient for all different given dilutions.\n*)\n\n// Code block 12\n\n//let prot1Coeff,prot1FitVals,prot1Determination =\nlet calculatePearson prot1Name prot2Name strainName (meanValueArray:(float*float) [])  =\n    let dilutionsSorted,strainVals =\n        meanValueArray\n        |\u003E Array.unzip\n    // RBCL Regression of relative quantification values\n    let RBCLcoeff = Univariable.coefficient (vector dilutionsSorted) (vector strainVals)\n    let RBCLfitFunc = Univariable.fit RBCLcoeff\n    let RBCLfitVals = dilutionsSorted |\u003E Array.map RBCLfitFunc\n    let RBCLdetermination = FSharp.Stats.Fitting.GoodnessOfFit.calculateDeterminationFromValue strainVals RBCLfitVals\n    let RBCLpearson = FSharp.Stats.Correlation.Seq.pearson strainVals dilutionsSorted\n    printfn \u0022%s - Pearson WholeCell %s: %f\u0022 strainName (prot1Name\u002B\u0022/\u0022\u002Bprot2Name) RBCLpearson\n    RBCLcoeff, RBCLfitVals, RBCLdetermination\n    \ntestMeanValues\n|\u003E calculatePearson \u0022rbcL\u0022 \u0022RBCS2\u0022 \u00224A\u0022\n\n(***include-it***)\n\n// Code block 13\n\nlet chartRatios prot1 prot2 strain =\n    let prot1Vals = meanValuesFor prot1 prot2 strain\n\n    let (prot1Coeff:Vector\u003Cfloat\u003E),prot1FitVals,prot1Determination =\n        calculatePearson prot1 prot2 strain prot1Vals\n\n    let dilutionsSorted,_ =\n        prot1Vals\n        |\u003E Array.unzip\n\n    [\n        Chart.Point (prot1Vals,Name = sprintf \u0022%s Quantified Ratios\u0022 (prot1\u002B\u0022/\u0022\u002Bprot2))\n        |\u003E Chart.withMarkerStyle(Size=10,Symbol = StyleParam.Symbol.Cross)\n        Chart.Line(Array.zip dilutionsSorted prot1FitVals,Name = (sprintf \u0022%s linear regression: %.2f x \u002B (%2f) ; R = %.4f\u0022 (prot1\u002B\u0022/\u0022\u002Bprot2) prot1Coeff.[1] prot1Coeff.[0] prot1Determination))\n        |\u003E Chart.withLineStyle(Color=\u0022lightblue\u0022,Dash=StyleParam.DrawingStyle.DashDot)\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withTitle (sprintf \u0022%s - In-Gel-Digest: Stability of %s/%s ratios between samples\u0022 strain prot1 prot2)\n    |\u003E Chart.withX_Axis (xAxis false (sprintf \u0022Cut Out 1 - %s / Cut Out 2 - %s\u0022 prot1 prot2) 20 16)\n    |\u003E Chart.withY_Axis (xAxis false \u0022relative quantification\u0022 20 16 )\n    |\u003E Chart.withConfig config\n    |\u003E Chart.withSize (1000.,400.)\n\nchartRatios \u0022rbcL\u0022 \u0022RBCS2\u0022 \u00221690\u0022\n\n(***hide***)\nchartRatios \u0022rbcL\u0022 \u0022RBCS2\u0022 \u00221690\u0022 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Compare 14N/15N for rbcL and rbcS\nTo calculate absolute quantities we need to know the relation of 14N protein to the 15N QProtein. \nWe will show these relation with the following charts.\nWe add a linear fit to the charts to allow for more precise evaluation of sample linearity.\n*)\n\n// Code block 14\n\n/////////////////////////////////// Chart Step 2 //////////////////////////////////////////\n\nlet calculateLinearFit ((amount,quant): float[]*float[]) =\n    // Calculation of the coefficients for a linear fit.\n    let coeffs =\n        Univariable.coefficient (vector amount) (vector quant)\n    // Calculation of the linear fit with the coefficients.\n    let linearFitFunc =\n        Univariable.fit coeffs\n    // Here, we apply the fitting function to our x-values (amount of loaded protein) \n    // to get the corresponding fitted values.\n    let linearFitVals =\n        amount\n        |\u003E Array.map linearFitFunc\n    // Calculation of the goodness of the fit by comparing our calculated \n    // Protein1/Protein2 ratios to the values of the fit.\n    let determination =\n        FSharp.Stats.Fitting.GoodnessOfFit.calculateDeterminationFromValue quant linearFitVals\n    {|Coefficients = coeffs; LinearFitValues = linearFitVals; Determination = determination; LoadedProtein = amount|}\n\n(***include-it***)\n\n// Code block 15\n\nlet createChartForRbcsRbclComparison prot1 prot2 strain =\n\n    let nestedFrame =\n        proteinRatiosWithDesc\n        |\u003E Frame.filterRows (fun rk rs -\u003E rk = prot1 || rk = prot2)\n        |\u003E Frame.transpose\n        |\u003E Frame.nest     \n\n    let getProtValuesFromSeries series =\n        series\n        |\u003E Series.filter (fun k t -\u003E fst k = strain)\n        |\u003E fun x -\u003E x.Observations \n        |\u003E Array.ofSeq\n        |\u003E Array.map (fun x -\u003E snd x.Key, x.Value)\n\n    let rbcLRBCLValues =\n        nestedFrame.[\u0022RBCL\u0022].GetColumn\u003Cfloat\u003Eprot1\n        |\u003E getProtValuesFromSeries\n\n    let rbcs2RBCSValues =\n        nestedFrame.[\u0022RBCS\u0022].GetColumn\u003Cfloat\u003Eprot2\n        |\u003E getProtValuesFromSeries\n\n    let rbclFit =\n        calculateLinearFit (Array.unzip rbcLRBCLValues)\n\n    let rbcsFit =\n        calculateLinearFit (Array.unzip rbcs2RBCSValues)\n\n    let fitChart =\n        [\n            Chart.Line(Array.zip rbclFit.LoadedProtein rbclFit.LinearFitValues)\n            |\u003E Chart.withTraceName (sprintf \u0022linear regression: %.2f x \u002B (%2f) ; R\u00B2 = %.4f for strain %s and %s\u0022\n                rbclFit.Coefficients.[1] rbclFit.Coefficients.[0] rbclFit.Determination strain prot1)\n            |\u003E Chart.withLineStyle(Color=\u0022#D3D3D3\u0022,Dash=StyleParam.DrawingStyle.DashDot)\n            Chart.Line(Array.zip rbcsFit.LoadedProtein rbcsFit.LinearFitValues)\n            |\u003E Chart.withTraceName (sprintf \u0022linear regression: %.2f x \u002B (%2f) ; R\u00B2 = %.4f for strain %s and %s\u0022\n                rbcsFit.Coefficients.[1] rbcsFit.Coefficients.[0] rbcsFit.Determination strain prot2)\n            |\u003E Chart.withLineStyle(Color=\u0022#D3D3D3\u0022,Dash=StyleParam.DrawingStyle.DashDot)\n        ]\n        |\u003E Chart.Combine\n\n    let dataChart =\n        [\n            Chart.Scatter(rbcLRBCLValues,mode=StyleParam.Mode.Lines_Markers, MarkerSymbol = StyleParam.Symbol.Circle, Opacity=0.8)\n            |\u003E Chart.withTraceName (sprintf \u0022Mean %s - %s\u0022 prot1 strain)\n            Chart.Scatter(rbcs2RBCSValues,mode=StyleParam.Mode.Lines_Markers, MarkerSymbol = StyleParam.Symbol.Circle, Opacity=0.8)\n            |\u003E Chart.withTraceName (sprintf \u0022Mean %s - %s\u0022 prot2 strain)\n        ]\n        |\u003E Chart.Combine\n        |\u003E Chart.withX_Axis (xAxis false \u0022Loaded protein [\u00B5g]\u0022 20 16)\n        |\u003E Chart.withY_Axis (xAxis false \u0022\u003Csup\u003E14\u003C/sup\u003EN/\u003Csup\u003E15\u003C/sup\u003EN Quantification ratio\u0022 20 16)\n\n    [fitChart;dataChart]\n    |\u003E Chart.Combine\n    |\u003E Chart.withTitle (sprintf \u0022%s/%s relative protein quantification\u0022 prot1 prot2)\n    |\u003E Chart.withSize (1200.,400.)\n\nlet prot1 = \u0022rbcL\u0022\nlet prot2 = \u0022RBCS2\u0022\n\n[|\u00224A\u0022; \u00221883\u0022;\u00221690\u0022|]\n|\u003E Array.map (createChartForRbcsRbclComparison prot1 prot2)\n\n(***hide***)\n[|\u00224A\u0022; \u00221883\u0022;\u00221690\u0022|]\n|\u003E Array.map (createChartForRbcsRbclComparison prot1 prot2 \u003E\u003E GenericChart.toChartHTML)\n(***include-it-raw***)"}]