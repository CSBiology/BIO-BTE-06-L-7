<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Stats</name></assembly>
<members>
<member name="T:FSharp.Stats.complex">
<summary>
Complex number            
</summary>
</member>
<member name="T:FSharp.Stats.Complex">
<summary>
Complex number in cartesian form
</summary>
</member>
<member name="P:FSharp.Stats.Vector`1.Length">
<summary>
Length of vector
</summary>
</member>
<member name="P:FSharp.Stats.Matrix`1.Dimensions">
<summary>
 RowCount * ColumnCount
</summary>
</member>
<member name="T:FSharp.Stats.OpsData`1">
<summary>
 The value stored for the dictionary of numeric operations. If none is present then this indicates
 no operations are known for this type.
</summary>
</member>
<member name="M:FSharp.Stats.LinearAlgebraLAPACK.FSharp-Stats-Algebra-ILinearAlgebra-dsyevd_(FSharp.Stats.Matrix{System.Double})">
<summary>
Eigen Value Decomposition of Symmetric Matrix
</summary>
</member>
<member name="T:FSharp.Stats.LinearAlgebraLAPACK">
<summary>
 Internal provider of Lapack functionality, not for direct user usage.
</summary>
</member>
<member name="M:FSharp.Stats.LinearAlgebraMKL.FSharp-Stats-Algebra-ILinearAlgebra-dgesdd_(FSharp.Stats.Matrix{System.Double})">
<summary>
Singular Value Decomposition Divide- Conquer
</summary>
</member>
<member name="M:FSharp.Stats.LinearAlgebraMKL.FSharp-Stats-Algebra-ILinearAlgebra-dgemm_(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
Matrix-Matrix Multiplication
</summary>
</member>
<member name="T:FSharp.Stats.LinearAlgebraMKL">
<summary>
 Internal provider of MKL functionality, not for direct user usage.
</summary>
</member>
<member name="M:FSharp.Stats.Ops.signum(System.Double,System.Double)">
<summary>
 Signum function, assigns a positive sign to a with respect to the signing of b. 
</summary>
</member>
<member name="M:FSharp.Stats.Ops.round(System.Int32,System.Double)">
<summary>
 Rounds a double-precision floating-point value to a specified number of fractional digits.  
</summary>
</member>
<member name="M:FSharp.Stats.Ops.arsinh(System.Double)">

</member>
<member name="M:FSharp.Stats.Ops.square``2(``0)">
<summary>
 Returns x squared (x^2)
</summary>
</member>
<member name="M:FSharp.Stats.Ops.revLog2(System.Double)">
<summary>
 Returns the reverted log2 (2^x)
</summary>
</member>
<member name="M:FSharp.Stats.Ops.isNan``1(``0)">
<summary>
 Returs true if x is nan (generics) equality
</summary>
</member>
<member name="M:FSharp.Stats.Ops.log10(System.Double)">
<summary>
 Returns the logarithm for x in base 10.
</summary>
</member>
<member name="M:FSharp.Stats.Ops.log2(System.Double)">
<summary>
 Returns the logarithm for x in base 2.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.infNeg">
<summary>
 Float negative infinity.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.inf">
<summary>
 Float positive infinity.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.pi">
<summary>
 The constant pi = 3.141596...
</summary>
</member>
<member name="T:FSharp.Stats.Ops">
<summary>
 Operations module (automatically opened)
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandBasic.FSharp-Stats-Random-IRandom-NextInt">
<summary>
maxValue is not part of the possible sampling range (minVal &lt;= x &lt; maxVal)
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandBasic.#ctor(System.Int32)">
<summary>
 If n is negative, the random number generator seed is based on system time, if it is zero or positive it will
 use n as the seed.
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandBasic.#ctor">
<summary>
 Constructs the default random number generator using a time dependent default seed value.
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandThreadSafe.FSharp-Stats-Random-IRandom-NextInt(System.Int32)">
<summary>
maxValue is not part of the possible sampling range (minVal &lt;= x &lt; maxVal)
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandThreadSafe.#ctor(System.Int32)">
<summary>
 If n is negative, the random number generator seed is based on system time, if it is zero or positive it will
 use n as the seed.
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandThreadSafe.#ctor">
<summary>
 Constructs the default random number generator using a time dependent default seed value.
</summary>
</member>
<member name="T:FSharp.Stats.Random.IRandom">
<summary>
 Interface that every uniform random number generator must implement.
</summary>
</member>
<member name="M:FSharp.Stats.Random.GetSampleGenerator">
<summary>
 Returns the random number generator used for sampling.
</summary>
</member>
<member name="M:FSharp.Stats.Random.SetSampleGenerator(FSharp.Stats.Random.IRandom)">
<summary>
 Sets the random number generator used for sampling.
</summary>
</member>
<member name="P:FSharp.Stats.Random.rndgen">
<summary>
 The uniform random source used for sampling functions.
</summary>
</member>
<member name="T:FSharp.Stats.Random">
<summary>
 Uniform random number generators
</summary>
</member>
<member name="P:FSharp.Stats.ServiceLocator.ServiceProvider`1.Providers(FSharp.Stats.ServiceLocator.Provider{`0}[])">
<summary>
 Service Providers
</summary>
</member>
<member name="P:FSharp.Stats.ServiceLocator.ServiceProvider`1.Providers">
<summary>
 Service Providers
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.ServiceProvider`1.Stop">
<summary>
 Disable the service.
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.ServiceProvider`1.StartWith(FSharp.Stats.ServiceLocator.Provider{`0})">
<summary>
 Use the LAPACK service from the given provider.
 If the supporting DLLs are not available, this may fail (now or later).
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.ServiceProvider`1.Start">
<summary>
 Start the service with the first provider that looks loadable.     
</summary>
</member>
<member name="T:FSharp.Stats.ServiceLocator.Provider`1">
<summary>
 Generic provider with unmanaged DLL dependencies.
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.initSearchPaths">
<summary>
 The DLLs search procedure for those DLLs
</summary>
</member>
<member name="T:FSharp.Stats.Intervals.Interval`1">
<summary>
 Closed interval [Start,End]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.liesInInterval``1(``0,FSharp.Stats.Intervals.Interval{``0})">
<summary>
   Does the given value lie in the interval or not.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getValueAt``2(System.Double,FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Get the value at a given percentage within (0.0 - 1.0) or outside (&lt; 0.0, &gt; 1.0) of the interval. Rounding to nearest neighbour occurs when needed.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.intersect``1(FSharp.Stats.Intervals.Interval{``0},FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the intersection of this interval with another.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.isIntersection``1(FSharp.Stats.Intervals.Interval{``0},FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Checking for intersection of both intervals
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.subtract(FSharp.Stats.Intervals.Interval{System.Int32},FSharp.Stats.Intervals.Interval{System.Int32})">
<summary>
 Subtract a given interval from the other interval.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.add(FSharp.Stats.Intervals.Interval{System.Int32},FSharp.Stats.Intervals.Interval{System.Int32})">
<summary>
 Add two given intervals.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.toString``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the interval as a string
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.trySize``2(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the size of an closed interval
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getRange``2(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns range of of Interval [min,max] (max - min)
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getEnd``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns max/end value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getStart``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns min/start value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.values``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns min and max value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.ofSeqBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates closed interval [min,max] of the given data based on the extreme values obtained by applying the projection function
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates closed interval of the given data based on its minimum and maximum 
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.ofSize(System.Int32,System.Int32)">
<summary>
 Creates closed interval [min,max] by given start and size
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.create``1(``0,``0)">
<summary>
 Creates closed interval [min,max] by given min and max
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.ofReal(System.Double)">
<summary>
Creates a complex number of a real number (imaginary part 0)
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.tan(FSharp.Stats.Complex)">
<summary>
Evaluates the tangent of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sin(FSharp.Stats.Complex)">
<summary>
Evaluates the sine of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.cos(FSharp.Stats.Complex)">
<summary>
Evaluates the cosine of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sqrt(FSharp.Stats.Complex)">
<summary>
Evaluates square root of complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.log(FSharp.Stats.Complex)">
<summary>
Evaluates natural logarithm of complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.exp(FSharp.Stats.Complex)">
<summary>
Evaluates the exponent of the complex number to base e
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.pi">
<summary>
Pi as complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.iscale(System.Double,FSharp.Stats.Complex)">
<summary>
Rotates a complex number 90ï¿½ counterclockwise and multiplies by scalar k
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.muls(FSharp.Stats.Complex,System.Double)">
<summary>
Multiplies complex number a by scalar b
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.smul(System.Double,FSharp.Stats.Complex)">
<summary>
Multiplies complex number b by scalar a
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.neg(FSharp.Stats.Complex)">
<summary>
Reverses sign of the real and the imaginary part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.div(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Divides complex number x by complex number y
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mul(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Multiplies two complex numbers
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sub(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Substracts complex number b from complex number a
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.add(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Adds two complex numbers
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.abs(FSharp.Stats.Complex)">
<summary>
Evaluates the absolute value of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.imagPart(FSharp.Stats.Complex)">
<summary>
Gets the imaginary part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.realPart(FSharp.Stats.Complex)">
<summary>
Gets the real part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.phase(FSharp.Stats.Complex)">
<summary>
Evaluates the phase (or the angle) of the complex number in polar form
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.magnitude(FSharp.Stats.Complex)">
<summary>
Evalues magnitude of complex number
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.onei">
<summary>
Complex number with real part 0 and imaginary part 1
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.one">
<summary>
Complex number with real part 1 and imaginary part 0
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.zero">
<summary>
Complex number with real part 0 and imaginary part 0
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.cis(System.Double)">
<summary>
Creates a complex number on the unit circle with b being the radius
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mkPolar(System.Double,System.Double)">
<summary>
Creates a complex number from its polar form where a is the radius and b is the angle
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.conjugate(FSharp.Stats.Complex)">
<summary>
Conjugates a complex number (reverses sign of imaginary part)
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mkRect(System.Double,System.Double)">
<summary>
Creates a complex number of a real part a and an imaginary part b
</summary>
</member>
<member name="T:FSharp.Stats.ComplexModule">
<summary>
Operations for complex number in cartesian form
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.setColM``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces column of index i of matrix a with values of vector v, if vector length matches columnsize
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.getColM``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns col of index i of matrix a as a vector
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.setRowM``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces row of index j of matrix a with values of vector v, if vector length matches rowsize
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.getRowM``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns row of index i of matrix a as a vector
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.mergedNonZeroEntriesM``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Non-zero entries from two sequences
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.mergeSorted``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Merge two sorted sequences
</summary>
</member>
<member name="T:FSharp.Stats.SpecializedGenericImpl">
<summary>
 Generic operations that, when used on floating point types, use the specialized versions in DoubleImpl
</summary>
</member>
<member name="T:FSharp.Stats.DoubleImpl">
<summary>
 Implementations of operations specific to floating point types
</summary>
</member>
<member name="M:FSharp.Stats.GenericImpl.cptMulDenseMatrixGU``1(FSharp.Stats.DenseMatrix{``0},FSharp.Stats.DenseMatrix{``0})">
<summary>
Point-wise multiplication 
</summary>
</member>
<member name="M:FSharp.Stats.GenericImpl.initSparseMatrixGU``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{FSharp.Stats.INumeric{``0}},System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,``0}})">
<summary>
 Create a matrix from a sparse sequence 
</summary>
</member>
<member name="T:FSharp.Stats.GenericImpl">
<summary>
 Implementations of operations that will work for any type
</summary>
</member>
<member name="M:FSharp.Stats.RunningStats.stDevPopulation``2(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.stDev``2(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.var``1(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.varPopulation``1(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.stDevPopulation``3(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.stDev``4(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.var``3(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.varPopulation``2(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.mean``1(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="T:FSharp.Stats.SummaryStats">
<summary>
 Module to compute common statistical measure on 
</summary>
</member>
<member name="M:FSharp.Stats.Array.seqInit(System.Double,System.Double,System.Int32)">
<summary>
 Generates array sequence (like R! seq.int)
</summary>
</member>
<member name="M:FSharp.Stats.Array.shuffleFisherYatesInPlace``1(``0[])">
<summary>
 Shuffels the input array (method: Fisher-Yates) in place
</summary>
</member>
<member name="M:FSharp.Stats.Array.shuffleFisherYates``1(``0[])">
<summary>
 Shuffels the input array (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.Array.sampleWithOutReplacement``1(System.Random,``0[],System.Int32)">
<summary>
 Samples from an array of obj without replacement (without putting back)
</summary>
</member>
<member name="M:FSharp.Stats.Array.sampleWithReplacement``1(System.Random,``0[],System.Int32)">
<summary>
 Samples from an array of obj wit replacement (with putting back)
</summary>
</member>
<member name="M:FSharp.Stats.Array.medianAbsoluteDev(System.Double[])">
<summary>
 Median absolute deviation (MAD)
</summary>
</member>
<member name="M:FSharp.Stats.Array.median``2(``0[])">
<summary>
 Computes the sample median
</summary>
</member>
<member name="M:FSharp.Stats.Array.quickSelect``1(System.Int32,``0[])">
<summary>
 Finds the kth smallest element in an unordered array (note that k is ONE-based)
</summary>
</member>
<member name="M:FSharp.Stats.Array.quickSelectInPlace``1(System.Int32,``0[])">
<summary>
 Finds the kth smallest element in an unordered array (note that k is ONE-based)
 Works in place and can change the order of the elements in the input array
</summary>
</member>
<member name="M:FSharp.Stats.Array.quickSelectInPlaceWith``1(System.Int32,System.Int32,System.Int32,``0[])">
<summary>
 Finds the kth smallest element in an unordered array (note that k is ONE-based)
 Works in place and can change the order of the elements in the input array
</summary>
</member>
<member name="M:FSharp.Stats.Array.partitionSortInPlace``1(System.Int32,System.Int32,``0[])">
<summary>
 Arranges the items between the left and right border, that all items left of the pivot element are smaller and bigger on the right.
 Function works in place and returns the index of the pivote element (using Lomuto&apos;s partitioning algorithm)
</summary>
</member>
<member name="T:FSharp.Stats.Array">
<summary>
 Module to compute common statistical measure on array
</summary>
</member>
<member name="M:FSharp.Stats.Seq.getCvOfReplicates``4(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 calculates the coefficient of variation based on the sample standard deviations with a given number of replicates present in the sequence
</summary>
</member>
<member name="M:FSharp.Stats.Seq.getStDevOfReplicates``4(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 calculates the sample standard deviations with a given number of replicates present in the sequence
</summary>
</member>
<member name="M:FSharp.Stats.Seq.getMeanOfReplicates``2(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 calculates the sample means with a given number of replicates present in the sequence
</summary>
</member>
<member name="M:FSharp.Stats.Seq.stats``3(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns SummeryStats of deq with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="M:FSharp.Stats.Seq.medianAbsoluteDev(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Median absolute deviation (MAD)
</summary>
</member>
<member name="M:FSharp.Stats.Seq.cvPopulationBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of the population (population standard deviation)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of the population</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cvPopulation``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of the population (population standard deviation)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of the population</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cvBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of a sample (Bessel's correction by N-1)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cv``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of a sample (Bessel's correction by N-1)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.stDevPopulationBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population standard deviation (denominator = N)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population standard deviation (denominator = N)</returns>     
</member>
<member name="M:FSharp.Stats.Seq.stDevPopulation``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population standard deviation (denominator = N)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population standard deviation (denominator = N)</returns>     
</member>
<member name="M:FSharp.Stats.Seq.stDevBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample standard deviation
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>standard deviation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.stDev``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample standard deviation
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>standard deviation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varPopulationBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes variance of the given values (denominator N)
 </summary>
    
 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population variance estimator (denominator N)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varPopulation``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes variance of the given values (denominator N)
 </summary>
    
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population variance estimator (denominator N)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample variance (Bessel's correction by N-1)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>variance of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.var``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample variance (Bessel's correction by N-1)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>variance of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.median``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sample Median
</summary>
</member>
<member name="M:FSharp.Stats.Seq.meanTruncatedBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Double,System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the truncated (trimmed) mean
 </summary>

 <param name="items">The input sequence.</param>
 <param name="f">A function applied to transform each element of the sequence.</param>    
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>truncated (trimmed) mean</returns>  
</member>
<member name="M:FSharp.Stats.Seq.meanTruncated``2(System.Double,System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the truncated (trimmed) mean where x percent of the highest, and x percent of the lowest values are discarded (total 2x)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>truncated (trimmed) mean</returns>  
</member>
<member name="M:FSharp.Stats.Seq.meanGeometricBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes gemetric mean
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>gemetric mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanGeometric``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes gemetric mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>gemetric mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanHarmonicBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes harmonic mean
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>harmonic mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanHarmonic``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes harmonic mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>harmonic mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population mean (Normalized by N)s
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population mean (Normalized by N)</returns>   
</member>
<member name="M:FSharp.Stats.Seq.mean``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population mean (Normalized by N)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns default value if data is empty or if any entry is NaN.</remarks>
 <returns>population mean (Normalized by N)</returns>   
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevPopulation``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled population standard deviation of the given values (Bessel's correction by N-1)
 </summary>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevPopulationOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled population standard deviation of the given values (Bessel's correction by N-1)
 </summary>

 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDev``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled standard deviation of the given values.
 </summary>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled standard deviation of the given values
 </summary>

 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarPopulation``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled population variance of the given values (Bessel's correction by N-1)
 </summary>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarPopulationOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled population variance of the given values (Bessel's correction by N-1)
 </summary>
 
 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVar``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled variance of the given values
 </summary>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled variance of the given values
 </summary>
 
 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.sumOfSquares(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes sum of squares
 </summary>

 <param name="items">seq of float</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>sum of squares</returns> 
</member>
<member name="T:FSharp.Stats.Seq.UtilityFunctions">
<summary>
 A module which implements helper functions to provide special statistical measures
</summary>
</member>
<member name="T:FSharp.Stats.Seq">
<summary>
 Module to compute common statistical measure
</summary>
</member>
<member name="M:FSharp.Stats.List.median``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Calculate the median of a list of items.
 The result is a tuple of two items whose mean is the median.
</summary>
</member>
<member name="M:FSharp.Stats.List.mean(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
 computes the population mean (normalized by n)
</summary>
</member>
<member name="T:FSharp.Stats.List">
<summary>
 Module to compute common statistical measure on list
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.innerChoose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
Applies the given function to each element in the inner lists of the jagged List. Returns the jagged list whose inner lists are comprised of the results x for each element where the function returns Some(x)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.innerFilter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
Returns a new jagged list whose inner lists only contain the elements for which the given predicate returns true
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},``0,``2,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
Applies a function to each element of the inner lists of the jagged list, threading an accumulator argument through the computation. 
A second function is the applied to each result of the predeceding computation, again passing an accumulater through the computation 
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.innerFold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
Applies a function to each element of the inner lists of the jagged list, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
Builds a new jagged list whose inner lists are the results of applying the given function to each of their elements. The integer index passed to the function indicates the index of element in the inner list being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``2}})">
<summary>
 Builds a new jagged list whose inner lists are the results of applying the given function to the corresponding elements of the inner lists of the tree jagged lists triplewise. 
 All corresponding inner lists must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Builds a new jagged list whose inner lists are the results of applying the given function to the corresponding elements of the inner lists of the two jagged lists pairwise. 
 All corresponding inner lists must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Builds a new jagged list whose inner lists are the results of applying the given function to each of their elements.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffle``1(``0[][])">
<summary>
 Shuffels a jagged array (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleRowWise``1(``0[][])">
<summary>
 Shuffles each row of a jagged array separately (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleColumnWise``1(``0[][])">
<summary>
 Shuffles each column of a jagged array separately (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleInPlace``1(``0[][])">
<summary>
 Shuffels a jagged array (method: Fisher-Yates) in place
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleRowWiseInPlace``1(``0[][])">
<summary>
 Shuffles each row of a jagged array separately (method: Fisher-Yates) in place
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleColumnWiseInPlace``1(``0[][])">
<summary>
 Shuffles each column of a jagged array separately (method: Fisher-Yates) in place
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.innerChoose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[][])">
<summary>
Applies the given function to each element in the inner arrays of the jagged array. Returns the jagged array whose inner arrays are comprised of the results x for each element where the function returns Some(x)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.innerFilter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[][])">
<summary>
Returns a new jagged array whose inner arrays only contain the elements for which the given predicate returns true
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},``0,``2,``1[][])">
<summary>
Applies a function to each element of the inner arrays of the jagged array, threading an accumulator argument through the computation. 
A second function is the applied to each result of the predeceding computation, again passing an accumulater through the computation 
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.innerFold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``1[][])">
<summary>
Applies a function to each element of the inner arrays of the jagged array, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[][])">
<summary>
Builds a new jagged array whose inner arrays are the results of applying the given function to each of their elements. The integer index passed to the function indicates the index of element in the inner array being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0[][],``1[][],``2[][])">
<summary>
 Builds a new jagged array whose inner arrays are the results of applying the given function to the corresponding elements of the inner arrays of the tree jagged arrays triplewise. 
 All corresponding inner arrays must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[][],``1[][])">
<summary>
 Builds a new jagged array whose inner arrays are the results of applying the given function to the corresponding elements of the inner arrays of the two jagged arrays pairwise. 
 All corresponding inner arrays must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[][])">
<summary>
 Builds a new jagged array whose inner arrays are the results of applying the given function to each of their elements.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.toJaggedSeq``1(``0[][])">
<summary>
 Converts a jagged array into a jagged seq
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.ofJaggedSeq``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts a jagged Seq into a jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.toJaggedList``1(``0[][])">
<summary>
 Converts a jagged array into a jagged list
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.ofJaggedList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Converts a jagged list into a jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.ofArray2D``1(``0[0:, 0:])">
<summary>
 Converts a jagged array into an Array2D
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.toArray2D``1(``0[][])">
<summary>
 Converts from an Array2D into an jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.transpose``1(``0[][])">
<summary>
 Transposes a jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.copy``1(``0[][])">
<summary>
 Copies the jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.zeroCreate``1(System.Int32,System.Int32)">
<summary>
 Creates an jagged array where the entries are initially the default value Unchecked.defaultof
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
<summary>
 Creates an jagged array with the given dimensions and a generator function to compute the elements
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.splitVector``1(System.Int32[],FSharp.Stats.Vector{``0})">
<summary>
 Splits a vector according to given indices. Returns (vector including values according to indices, rest)
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.getCvOfReplicates(System.Int32,FSharp.Stats.Vector{System.Double})">
<summary>
 calculates the coefficient of variation based on the sample standard deviations with a given number of replicates present in the sequence
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.getStDevOfReplicates(System.Int32,FSharp.Stats.Vector{System.Double})">
<summary>
 calculates the sample standard deviations with a given number of replicates present in the sequence
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.getMeanOfReplicates(System.Int32,FSharp.Stats.Vector{System.Double})">
<summary>
 calculates the sample means with a given number of replicates present in the sequence
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.cov(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the sample covariance of two random variables v1 and v2. (Bessel&apos;s correction by N-1) 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.covPopulation(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns an estimator of the population covariance of two random variables v1 and v2 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.stats``3(FSharp.Stats.Vector{``0})">
<summary>
 Returns SummaryStats of vector with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.medianAbsoluteDev(FSharp.Stats.Vector{System.Double})">
<summary>
 Median absolute deviation (MAD)
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.median``2(FSharp.Stats.Vector{``0})">
<summary>
 Computes the sample median
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.mean``2(FSharp.Stats.Vector{``0})">
<summary>
 Computes the population mean (Normalized by N)            
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.interval``1(FSharp.Stats.Vector{``0})">

</member>
<member name="M:FSharp.Stats.VectorModule.raw``1(FSharp.Stats.Vector{``0})">
<summary>
 Returns the raw data array without copy
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_scalar(System.Double)">
<summary>
Builds one dimensional vector from scalar
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_seq(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
Builds vector from sequence
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_list(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
Builds vector from list
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.to_array(FSharp.Stats.Vector{System.Double})">
<summary>
Builds array from vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_array(System.Double[])">
<summary>
Builds vector from array
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplace_scale(System.Double,FSharp.Stats.Vector{System.Double})">
<summary>
Multiply values of vector v1 with scalar.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplace_cptMul(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Multiply values of vector v1 with values of vector v2. Vector v2 stays unchanged.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplace_sub(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Substract values of vector v2 from values of vector v1. Vector v2 stays unchanged
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplace_add(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Add values of vector v2 to values of vector v1. Vector v2 stays unchanged
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplace_mapi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},FSharp.Stats.Vector{System.Double})">
<summary>
Applies the given function to each of the elements of the vector and their corresponding index.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplace_map(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Applies the given function to each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.singleton(System.Double)">
<summary>
Applies the given function to each of the indexes of the vector.
Builds vector of Length 1 from value x
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplaceScale(System.Double,FSharp.Stats.Vector{System.Double})">
<summary>
Multiply values of vector with scalar.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplaceCptMul(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Multiply values of vector1 with values of vector2. Vector2 stays unchanged.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplaceSub(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Substract values of vector2 from values of vector1. Vector2 stays unchanged.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplaceAdd(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Add values of vector2 to values of vector1. Vector2 stays unchanged.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplaceMapi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},FSharp.Stats.Vector{System.Double})">
<summary>
Applies the given function to each of the elements of the vector and their corresponding index. No new vector is created.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplaceMap(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Applies the given function to each of the elements of the vector. No new vector is created.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.inplaceAssign(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Applies the given function to each of the indexes of the vector. No new vector is created.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.toThePower(System.Double,FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of exponentiating each of the elements of the vector with n.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.norm(FSharp.Stats.Vector{System.Double})">
<summary>
Euklidian norm of the vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.prod(FSharp.Stats.Vector{System.Double})">
<summary>
Product of all elements of the vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.sum(FSharp.Stats.Vector{System.Double})">
<summary>
Sum of all elements of the vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.oneCreate(System.Int32)">
<summary>
Creates a vector of length count and fills it with ones
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.zeroCreate(System.Int32)">
<summary>
Creates a vector of length count and fills it with zeros
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.foldi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}}},``0,FSharp.Stats.Vector{System.Double})">
<summary>
Applies a function to each element of the vector and their corresponding index, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}},``0,FSharp.Stats.Vector{System.Double})">
<summary>
Applies a function to each element of the vector, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.mapi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of applying the given function to each of the elements of the vector and their corresponding index.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.copy(FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector that contains the elements of the given vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.map3(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}}},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of applying the given function to the corresponding elements of the two vectors pairwise. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.map2(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of applying the given function to the corresponding elements of the two vectors pairwise. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.map(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of applying the given function to each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.dot(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Dot product of the two vectors
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.neg(FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of multiplying -1 with each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.scale(System.Double,FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of multiplying the given scalar with each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.cptMul(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of multiplying the corresponding elements of the given vectors. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.sub(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of substracting the corresponding elements of vector1 from vector2. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.add(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of adding the corresponding elements of the two vectors pairwise. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofScalar(System.Double)">
<summary>
Creates one dimensional vector of value
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.create(System.Int32,System.Double)">
<summary>
Creates vector of length count and fills it with value 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofSeq(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
Creates vector with values of sequence
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofList(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
Creates vector with values of list 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.toArray(FSharp.Stats.Vector{System.Double})">
<summary>
Creates array with values of vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofArray(System.Double[])">
<summary>
Creates vector with values of array
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.init(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double})">
<summary>
Initiates vector of length count and fills it by applying initializer function on indices
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.nrows(FSharp.Stats.Vector{System.Double})">
<summary>
Returns length of vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.nRows(FSharp.Stats.Vector{System.Double})">
<summary>
Returns length of vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.length(FSharp.Stats.Vector{System.Double})">
<summary>
Returns length of vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.set(FSharp.Stats.Vector{System.Double},System.Int32,System.Double)">
<summary>
Sets the value to the vector at the given index 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.get(FSharp.Stats.Vector{System.Double},System.Int32)">
<summary>
Returns the value of the vector at the given index 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.SummaryStats.ofVector(FSharp.Stats.Vector{System.Int32})">
<summary>
 Returns SummaryStats of vector with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="T:FSharp.Stats.VectorModule.SummaryStats">
<summary>
 Module to compute common statistical measure on 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.sum``1(FSharp.Stats.Vector{``0})">
<summary>
Sum of all elements of the vector a
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.dot``1(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
Dot product of the two vectors
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.oneCreate``1(System.Int32)">
<summary>
Creates a vector of length count and fills it with ones
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.zeroCreate``1(System.Int32)">
<summary>
Creates a vector of length count and fills it with zeros
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.create``1(System.Int32,``0)">
<summary>
Creates vector of length count and fills it with value
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
Initializes vector with count members, based on function f
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Creates vector from seq xss
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Creates vector from list xss
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.length``1(FSharp.Stats.Vector{``0})">
<summary>
Returns length of vector v
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.set``1(FSharp.Stats.Vector{``0},System.Int32,``0)">
<summary>
Sets the value x to the vector a at the given index i
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.get``1(FSharp.Stats.Vector{``0},System.Int32)">
<summary>
Returns the value of the vector a at the given index i
</summary>
</member>
<member name="T:FSharp.Stats.VectorModule">
<summary>
Basic vector operations
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.splitCols``1(System.Int32[],FSharp.Stats.Matrix{``0})">
<summary>
 Splits a matrix along column direction according to given indices. Returns (matrix including cols according to indices, rest)
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.splitRows``1(System.Int32[],FSharp.Stats.Matrix{``0})">
<summary>
 Splits a matrix along row direction according to given indices. Returns (matrix including rows according to indices, rest)
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.removeColAt``1(System.Int32,FSharp.Stats.Matrix{``0})">
<summary>
 Removes a column at a given index
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.removeRowAt``1(System.Int32,FSharp.Stats.Matrix{``0})">
<summary>
 Removes a row at a given index
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.flattenColWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix column wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.flattenRowWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mapiCols``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},``0}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Maps every matrix column using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.enumerateColumnWise``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},``0},FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies function f along column axis
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mapiRows``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.RowVector{System.Double},``0}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Maps every matrix row using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.enumerateRowWise``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},``0},FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies function f along row axis
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.rowSampleCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the row specific sample covariance matrix of a data matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.rowPopulationCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the row specific population covariance matrix of a data matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.columnSampleCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the column specific sample covariance matrix of a data matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.columnPopulationCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the column specific population covariance matrix of a data matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.columnCovarianceMatrixOf(System.Int32,FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the column specific covariance matrix of a data matrix as described at:
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.meanColumnWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the Column wise mean of a Matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.meanRowWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the row wise mean of a Matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.sumColumns(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the Column wise sum of a Matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.sumRows(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the row wise sum of a Matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.toDiagonal(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns diagonal matrix by setting all values beneath and above the diagonal to Zero.
 Warning: diagonal matrices can only be computed for square input matrices.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getLowerTriangular(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns lower triangular Matrix by setting all values beneath the diagonal to Zero.
 Warning: triangular matrices can only be computed for square input matrices.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getUpperTriangular(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns upper triangular Matrix by setting all values beneath the diagonal to Zero.
 Warning: triangular matrices can only be computed for square input matrices.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getRegion(FSharp.Stats.Matrix{System.Double},System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Accesses the m*n matrix a and returns a total of i2 rows and j2 columns starting from row index i1 and colum index j1. The Result is a new
 i2*j2 matrix.
 Only usable if (i1+i2-1) does not exceed m and (j1+j2-1) does not exceed n.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getRows(FSharp.Stats.Matrix{System.Double},System.Int32,System.Int32)">
<summary>
 Accesses the m*n matrix a and returns a total of i2 rows starting from row index i1. The Result is a new
 i2*n matrix.
 Only usable if (i1+i2-1) does not exceed m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getCols(FSharp.Stats.Matrix{System.Double},System.Int32,System.Int32)">
<summary>
 Accesses the m*n matrix a and returns a total of j2 Columns starting from column index j1. The Result is a new
 m*j2 matrix.
 Only usable if (j1+j2-1) does not exceed n.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.setCol``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
 Replaces column of index j of matrix a with values of vector v, if vector length matches columnsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getCol(FSharp.Stats.Matrix{System.Double},System.Int32)">
<summary>
 Returns col of index j of matrix a
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.setRow``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
 Replaces row of index i of matrix a with values of vector v, if vector length matches rowsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getRow(FSharp.Stats.Matrix{System.Double},System.Int32)">
<summary>
 Returns row of index i of matrix a
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ones(System.Int32,System.Int32)">
<summary>
 Creates a dense matrix with i rows and j columns. All values are initialized to one (1.).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.identity(System.Int32)">
<summary>
 Creates a dense identiy m*m matrix. A identity matrix is always squared and the elements are set to zero exept elements
 on the diagonal, which are set to 1.
 e.g.
 [[1.;0.;0.]
  [0.;1.;0.]
  [0.;0.;1.]]
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.zero(System.Int32,System.Int32)">
<summary>
 Creates a dense matrix with i rows and j columns. All values are initialized to yero (0.).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.nonzero_entries(FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the m*n matrix a row wise and returns a list of tuples (mi,ni,v) containing non zero elements of a
 and their row (m) and column (n) indicies.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.initSparse(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,System.Double}})">
<summary>
 Creates a sparse matrix with i rows and j columns. All values are initialized to the value of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.initDense(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,System.Double}})">
<summary>
 Creates a dense matrix with i rows and j columns. All values are initialized to the value of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.toSparse(FSharp.Stats.Matrix{System.Double})">
<summary>
 Transforms the matrix a to a sparse matrix representation
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.toDense(FSharp.Stats.Matrix{System.Double})">
<summary>
 Transforms the matrix a to a dense matrix representation
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.foldi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}}}},``0,FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies a function f row wise to each element of the matrix, threading an accumulator argument through the computation.
 The fold function takes the second argument, and applies the function f to it and the first element of the matrix.
 Then, it feeds this result into the function f along with the second element, and so on. It returns the final result.
 If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0) i1 ...) iN.
 The integers indicies passed to the function indicate row and column position (from 0) the of the element being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}},``0,FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies a function f row wise to each element of the matrix, threading an accumulator argument through the computation.
 The fold function takes the second argument, and applies the function f to it and the first element of the matrix.
 Then, it feeds this result into the function f along with the second element, and so on. It returns the final result.
 If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0) i1 ...) iN.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mapi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix whose elements are the result of row wise applying the given function on each element of a. The integer index
 passed to the function indicates the index (from 0) the of the element being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.copy(FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix whose elements are identical to the elements of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.map(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix whose elements are the result of row wise applying the given function on each element of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.existsi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.foralli(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.exists(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.forall(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.transpose(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns the transpose of matrix a
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.trace(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the trace of matrix a by summing elements of the diagonal.
 Only usable if matrices a is a square matrix (m*m).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.neg(FSharp.Stats.Matrix{System.Double})">
<summary>
 Scales matrix a by element wise mulitplication with minus 1.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.scale(System.Double,FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix where the elements are the result of multiplying every element of the given matrix with the given value
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.cptMin(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise comparison of matrices a and b always preserving the smaller value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.cptMax(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise comparison of matrices a and b always preserving the greater value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.cptMul(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise multiplication of matrices a and b (a+b, Hadamard-Product).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mulRV(FSharp.Stats.RowVector{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a matrix multiplication of the 1*n rowvector a and the m*n matrix b (a*b).
 Only usable if column number (n) of the vector equals the row number (m) of the matrix.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mulV(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Performs a matrix multiplication m*n matrix a and the m*1 vector b (a*b).
 Only usable if column number (n) of the matrix equals the row number (m) of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mul(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a left sided matrix multiplication of a and b (a*b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.sub(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise substraction of matrices a and b (a-b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.add(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise addition of matrices a and b (a+b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getDiag(FSharp.Stats.Matrix{System.Double})">

</member>
<member name="M:FSharp.Stats.MatrixModule.getDiagN(FSharp.Stats.Matrix{System.Double},System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.toJaggedArray(FSharp.Stats.Matrix{System.Double})">

</member>
<member name="M:FSharp.Stats.MatrixModule.toArray2D(FSharp.Stats.Matrix{System.Double})">

</member>
<member name="M:FSharp.Stats.MatrixModule.sparseOfArray2D(System.Double[0:, 0:])">
<summary>
Creates a sparse matrix based on the CSR format
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ofArray2D(System.Double[0:, 0:])">

</member>
<member name="M:FSharp.Stats.MatrixModule.ofScalar(System.Double)">

</member>
<member name="M:FSharp.Stats.MatrixModule.create(System.Int32,System.Int32,System.Double)">

</member>
<member name="M:FSharp.Stats.MatrixModule.constDiag(System.Int32,System.Double)">

</member>
<member name="M:FSharp.Stats.MatrixModule.initDiagonal(FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.MatrixModule.diag(FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.MatrixModule.ofJaggedColArray(System.Double[][])">
<summary>
returns a dense matrix with the inner lists of the input jagged list as its columns
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ofJaggedArray(System.Double[][])">
<summary>
returns a dense matrix with the inner lists of the input jagged list as its rows
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ofJaggedColSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a dense matrix with the inner lists of the input jagged list as its columns
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ofJaggedSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a dense matrix with the inner lists of the input jagged list as its rows
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ofJaggedColList(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Double}})">
<summary>
returns a dense matrix with the inner lists of the input jagged list as its columns
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ofJaggedList(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Double}})">
<summary>
returns a dense matrix with the inner lists of the input jagged list as its rows
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.init(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double}})">
<summary>
returns a dense matrix with m rows and n rows, applying the init function with the two indices as arguments
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.flattenColWise``1(FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix column wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.flattenRowWise``1(FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mapiCols``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{``0},``1}},FSharp.Stats.Matrix{``0})">
<summary>
 Maps every matrix column using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.enumerateColumnWise``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},FSharp.Stats.Matrix{``0})">
<summary>
 Applies function f along colÃºmn axis
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mapiRows``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.RowVector{``0},``1}},FSharp.Stats.Matrix{``0})">
<summary>
 Maps every matrix row using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.enumerateRowWise``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},FSharp.Stats.Matrix{``0})">
<summary>
 Applies function f along row axis
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toScalar``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toRowVector``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toVector``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.ofVector``1(FSharp.Stats.Vector{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.ofRowVector``1(FSharp.Stats.RowVector{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getRegion``1(FSharp.Stats.Matrix{``0},System.Int32,System.Int32,System.Int32,System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getRows``1(FSharp.Stats.Matrix{``0},System.Int32,System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getCols``1(FSharp.Stats.Matrix{``0},System.Int32,System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.setCol``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces column of given index of a matrix with values of a vector, if vector length matches columnsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getCol``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns col of given index of a matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.setRow``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces row of given index of a matrix with values of a vector, if vector length matches rowsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getRow``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns row of given index of a matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.hash``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.compare``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``0,FSharp.Stats.Matrix{``1})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Stats.Matrix{``1})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.initSparse``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,``0}})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.initDense``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,``0}})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toSparse``1(FSharp.Stats.Matrix{``0})">
<summary>
Creates a sparse matrix based on the CSR format
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toDense``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getDiag``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getDiagN``1(FSharp.Stats.Matrix{``0},System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.copy``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.map``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.foralli``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies the function predicate element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.existsi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies the function predicate element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies the function predicate element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies the function predicate element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.inplaceSub``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs an element wise substraction of matrices matrix1 and matrix2 (matrix1 - matrix2).
 Attention: the output overrides matrix1.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.inplaceAdd``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs an element wise addition of matrices matrix1 and matrix2 (matrix1 + matrix2).
 Attention: the output overrides matrix1.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.transpose``1(FSharp.Stats.Matrix{``0})">
<summary>
 Returns the transpose of the matrix.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.norm``1(FSharp.Stats.Matrix{``0})">
<summary>
Frobenius matrix norm
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.prod``1(FSharp.Stats.Matrix{``0})">
<summary>
 Computes the product of all matrix elements.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.sum``1(FSharp.Stats.Matrix{``0})">
<summary>
 Computes the sum of all matrix elements.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.trace``1(FSharp.Stats.Matrix{``0})">
<summary>
 Computes the trace of the matrix by summing elements of the diagonal.
 Only usable if the matrix is a square matrix (m*m).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.neg``1(FSharp.Stats.Matrix{``0})">
<summary>
 Scales the matrix by element wise mulitplication with minus 1.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.dot``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a dot product of matrices matrix1 and matrix2.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.scale``1(``0,FSharp.Stats.Matrix{``0})">
<summary>
 Builds a new matrix where the elements are the result of multiplying every element of the given matrix with the given value
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.cptMin``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise comparison of matrices matrix1 and matrix2 always preserving the smaller value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.cptMax``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise comparison of matrices matrix1 and matrix2 always preserving the greater value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.cptMul``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise multiplication of matrices matrix1 and matrix2 (matrix1 * matrix2, Hadamard-Product).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mulV``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Vector{``0})">
<summary>
 Performs a matrix multiplication of a m*n matrix and the m*1 vector (matrix*vector).
 Only usable if column number (n) of the matrix equals the row number (m) of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mulRV``1(FSharp.Stats.RowVector{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a matrix multiplication of the 1*n rowVector and the m*n matrix (rowVector*matrix).
 Only usable if column number (n) of the vector equals the row number (m) of the matrix.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mul``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a left sided matrix multiplication of matrices matrix1 and matrix2 (matrix1 * matrix2).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.sub``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise substraction of matrices matrix1 and matrix2 (matrix1 - matrix2).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.add``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise addition of matrices matrix1 and matrix2 (matrix1 + matrix2).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.sparseOfArray2D``1(``0[0:, 0:])">
<summary>
Creates a sparse matrix based on the CSR format
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankAverage``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their mean
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankMax``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their maximum  
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankMin``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their minimum  
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankFirst``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Permutation with increasing values at each index of ties.
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rank``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0},``1[])">
<summary>
 Ranks each entry of the given unsorted data array. Use &apos;breakTies function to break ties
</summary>
</member>
<member name="T:FSharp.Stats.Rank">
<summary>
 Module to Calculate the rank. The rank of a number is its size relative to other values in a sequence
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.columnWiseBicor(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the columnwise biweighted midcorrelation matrix for the input matrix 
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.rowWiseBicor(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the rowwise biweighted midcorrelation matrix for the input matrix 
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.columnWisePearson(FSharp.Stats.Matrix{System.Double})">
<summary>
computes the columnwise pearson correlation matrix for the input matrix
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.rowWisePearson(FSharp.Stats.Matrix{System.Double})">
<summary>
computes the rowwise pearson correlation matrix for the input matrix
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.columnWiseCorrelationMatrix(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double}},FSharp.Stats.Matrix{System.Double})">
<summary>
computes a matrix that contains the metric given by the corrFunction parameter applied columnwise for every column against every other column of the input matrix
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.rowWiseCorrelationMatrix(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double}},FSharp.Stats.Matrix{System.Double})">
<summary>
computes a matrix that contains the metric given by the corrFunction parameter applied rowwise for every row against every other row of the input matrix
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.rv2(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the rv2 coefficient.  
</summary>
</member>
<member name="T:FSharp.Stats.Correlation.Matrix">
<summary>
 Contains correlation functions optimized for matrices
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.bicor(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Biweighted Midcorrelation. This is a median based correlation measure which is more robust against outliers.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.xCorr(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 computes the unnormalized (using only the dot product) cross-correlation of signals v1 and v2 at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.normalizedXCorr(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 computes the normalized (using pearson correlation) cross-correlation of signals v1 and v2 at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.autoCovariance(System.Int32,FSharp.Stats.Vector{System.Double})">
<summary>
 computes the sample auto corvariance of a signal at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.autoCorrelation(System.Int32,FSharp.Stats.Vector{System.Double})">
<summary>
 computes the sample auto correlation (using pearson correlation) of a signal at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.correlationOf(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},System.Double}},System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 computes the sample correlation of two signal at a given lag.
 was tested in comparison to: https://www.wessa.net/rwasp_autocorrelation.wasp
</summary>
</member>
<member name="T:FSharp.Stats.Correlation.Vector">
<summary>
 Contains correlation functions optimized for vectors
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.bicor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Biweighted Midcorrelation. This is a median based correlation measure which is more robust against outliers.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.kendall``2(``0[],``1[])">
<summary>
 Kendall Correlation Coefficient 
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.spearman``2(``0[],``1[])">
<summary>
 Spearman Correlation (with ranks)
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.pearsonWeighted``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 weighted pearson correlation (http://sci.tech-archive.net/Archive/sci.stat.math/2006-02/msg00171.html)
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.pearson``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Pearson correlation 
</summary>
</member>
<member name="T:FSharp.Stats.Correlation.Seq">
<summary>
 Contains correlation functions optimized for sequences
</summary>
</member>
<member name="T:FSharp.Stats.Correlation.bicorHelpers">
<summary>
 This module contains normalization and helper functions for the biweighted midcorrelation
</summary>
</member>
<member name="T:FSharp.Stats.Correlation">
<summary>
 Contains correlation functions for different data types 
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.computePercentiles``1(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double[],``0}},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Computes percentiles
 percentiles: Each percentile must be between 0.0 and 1.0 (inclusive)
 CalcMethod should be ofSorted array
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.interQuantileRange``1(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{``0[],System.Double}},``0[])">
<summary>
 Computes the interquartile range (IQR)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.normal(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.mode(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
 R! default
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.nist(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.hazen(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.california(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.nearest(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.empiricalInvCdfAverage(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.empiricalInvCdf(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.compute(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.normal(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.mode(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.nist(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.hazen(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.california(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.nearest(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.empiricalInvCdfAverage(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.empiricalInvCdf(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.compute(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="T:FSharp.Stats.Quantile.OfSorted">
<summary>
 ! Input needs to be sorted
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.normalInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.modeInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.nistInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.hazenInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.californiaInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.nearestInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.empiricalInvCdfAverageInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.empiricalInvCdfInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.computeInplace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="T:FSharp.Stats.Quantile.InPlace">
<summary>
 ! Works inplace and can thus causes the data array to be reordered
</summary>
</member>
<member name="T:FSharp.Stats.Quantile">
<summary>
 Module to estimate different quantile measures
</summary>
</member>
<member name="M:FSharp.Stats.Precision.almostEqualNorm(System.Double,System.Double)">
<summary>
 Compares two float values and determines if they differ by no more than 10.*(2.**(-52.).
</summary>
</member>
<member name="M:FSharp.Stats.Precision.almostEqualNormRelative(System.Double,System.Double,System.Double)">
<summary>
 Compares two float values and determines if they differ by no more than specified by the maximum error.
</summary>
</member>
<member name="T:FSharp.Stats.Precision">
<summary>
 Module to estimate different quantile measures
</summary>
</member>
<member name="T:FSharp.Stats.Geometry">
<summary>
 Module to 
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.upperIncomplete(System.Double,System.Double)">
<summary>
 Returns the incomplete gamma function Q(a,X) = 1 - P(a,X) (regularized gamma) 
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.lowerIncomplete(System.Double,System.Double)">
<summary>
 Returns the incomplete gamma function P(a,X) (regularized gamma) 
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.gammaLn(System.Double)">
<summary>
 Computes the log gamma function using the Lanczos Coefficients described in Numerical Recipes (Press et al)
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.gamma(System.Double)">
<summary>
 Computes the gamma function using the Lanczos Coefficients described in Numerical Recipes (Press et al) 
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Gamma">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Factorial.factorialLn(System.Int32)">
<summary>
 Computes the natural logarithm of the factorial function.
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Factorial.factorial(System.Int32)">
<summary>
 The factorial functions takes an int x and computes x!. This function will not overflow
 the floating point format as long as x is at most 170.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Factorial">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.lowerIncomplete(System.Double,System.Double,System.Double)">
<summary>
 Returns the regularized lower incomplete beta function
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.beta(System.Double,System.Double)">
<summary>
 Computes the beta function.
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.betaLn(System.Double,System.Double)">
<summary>
 Computes the natural logarithm of the beta function.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Beta">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Errorfunction.Erfc(System.Double)">
<summary>
 Computes the complement of the error function. Note that this implementation has only been verified to have a relative error of around 1e-4.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Errorfunction">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Logistic.generic(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Computes the logistic function value for x where 

 x0 is the x-Value of the sigmoid midpoint,

L is the curves maximum value and

k is the steepness of the curve
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Logistic.standard(System.Double)">
<summary>
 Computes the standard logistic function value for x
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Logistic">
<summary>
 Logistic (Sigmoid) Functions
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Binomial">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="T:FSharp.Stats.LapackMKLStubs">
<summary>
 Warning:
 IMPORTANT WARNING NOTICE:
 INTEL MATH KERNEL LIBRARY 9.1 FOR WINDOWS IS THIRD PARTY TECHNOLOGY.
 IT IS CLEARED ONLY FOR USE BY A SPECIFIC MSR RESEARCH TEAM.
 DO NOT USE IT UNTIL YOU HAVE CLEARED ITS USE FOR YOUR PROJECT WITH YOUR LEGAL CONTACT.
 
 The following stubs bind directly to Intel MKL functionality.
 You should not use them without:
 a) Intel MKL developer licenses.
 b) Seeking local legal approval.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.ILinearAlgebra.dsyevd_(FSharp.Stats.Matrix{System.Double})">
<summary>
Computes for a N-by-N real symmetric matrix A, the
eigenvalue decomposition of eigenvalues and right eigenvectors.
The right eigenvector v(j) of A satisfies

                 A * v(j) = lambda(j) * v(j)

where lambda(j) is its eigenvalue.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.ILinearAlgebra.dgesdd_thin_(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the thin Singular Value Decomposition of the input MxN matrix A 

A = U * SIGMA * V**T in the tuple (S, U, V**T), 

where S is an array containing the diagonal elements of SIGMA.
The first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT;
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;S&apos;
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.ILinearAlgebra.dgesdd_(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the full Singular Value Decomposition of the input MxN matrix 

A : A = U * SIGMA * V**T in the tuple (S, U, V**T), 

where S is an array containing the diagonal elements of SIGMA.
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;A&apos;
</summary>
</member>
<member name="T:FSharp.Stats.Algebra.ILinearAlgebra">
<summary>
This is an internal interface and not for user usage.
It exposes a specialised subset of BLAS/LAPACK functionality.
This functionality is used by us to build the exposed APIs.
It is those exposed APIs that should be used.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.EVD.symmetricEvd(System.Double[0:, 0:])">
<summary>
 Computes the 
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.EVD.tql2Inplace(System.Double[],System.Double[],System.Double[0:, 0:])">
<summary>
 Symmetric tridiagonal QL algorithm.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.EVD.tred2Inplace(System.Double[],System.Double[],System.Double[0:, 0:])">
<summary>
 Symmetric Householder reduction to tridiagonal form.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.pseudoInvers(FSharp.Stats.Matrix{System.Double})">
<summary>
 Calculates the pseudo inverse of the matrix
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.leverage(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the leverage directly by QR decomposition of the designmatrix used in ordinary least squares approaches
 and computing of the diagnonal entries of the Hat matrix, known as the leverages of the regressors
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.leverageBy(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the leverages of every dataPoint of a dataSet given by the diagonal of the hat matrix. 
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.hatMatrix(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the hat matrix by the QR decomposition of the designmatrix used in ordinary least squares approaches
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.QR(FSharp.Stats.Matrix{System.Double})">
<summary>
 Matches the union type of the matrix and invokes the according QR factorization function
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.QRSparse(FSharp.Stats.SparseMatrix{System.Double})">
<summary>
 QR factorization function for sparse matrices, returns Q as a product of givens rotations and R as upper triangular
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.QRDense(FSharp.Stats.Matrix{System.Double})">
<summary>
 QR factorization function for dense matrices
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.HouseholderTransform(FSharp.Stats.Matrix{System.Double},System.Int32)">
<summary>
 This method computes and performs a Householder reflection. It will change the
 input matrix and return the reflection vector.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.sign(System.Double)">
<summary>
 Computes the sign of a floating point number.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.unitV(System.Int32)">
<summary>
 Generates a unit vector [1 0 .. 0 ].
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.SolveLinearSystems(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Solves a system of linear equations, Ax = b, with A LU factorized.        
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.SolveLinearSystem(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Solves a system of linear equations, AX = B, with A LU factorized.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.LU(FSharp.Stats.Matrix{System.Double})">
<summary>
 For a matrix A, the LU factorization is a pair of lower triangular matrix L and upper triangular matrix U so that A = L*U.
 The pivot function encode a permutation operation such for a matrix P P*A = L*U.
</summary>
</member>
<member name="T:FSharp.Stats.Algebra.LinearAlgebraManaged">
<summary>
 This module is for internal use only.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Determinant(FSharp.Stats.Matrix{System.Double})">
<summary>
 Compute the determinant of a matrix by performing an LU decomposition since if A = P&apos;LU,
 then det(A) = det(P&apos;) * det(L) * det(U).
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.leverage(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the leverage directly by QR decomposition of the designmatrix used in ordinary least squares approaches
 and computing of the diagnonal entries of the Hat matrix, known as the leverages of the regressors
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.leverageBy(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the hat matrix by the QR decomposition of the designmatrix used in ordinary least squares approaches
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.hatmatrix(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the hat matrix by the QR decomposition of the designmatrix used in ordinary least squares approaches
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.thinSVD(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the thin Singular Value Decomposition of the input MxN matrix A 

A = U * SIGMA * V**T in the tuple (S, U, V), 

where S is an array containing the diagonal elements of SIGMA.
The first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT;
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;S&apos;
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.spectralNorm(FSharp.Stats.Matrix{System.Double})">
<summary>
spectral norm of a matrix (for Frobenius norm use Matrix.norm)
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.SVD(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the full Singular Value Decomposition of the input MxN matrix 

A : A = U * SIGMA * V**T in the tuple (S, U, V**T), 

where S is an array containing the diagonal elements of SIGMA.
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;A&apos;
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.QR(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[m,n] finds Q[m,m] and R[k,n] where k = min m n.
 Have A = Q.R  when m&lt;=n.
 Have A = Q.RX when m&gt;n and RX[m,n] is R[n,n] row extended with (m-n) zero rows.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.LU(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] real matrix.
 Finds P,L,U such that L*U = P*A with L,U lower/upper triangular.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Cholesky(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] real symmetric positive definite.
 Finds the cholesky decomposition L such that L&apos; * L = A.
 May fail if not positive definite.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.LeastSquares(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Given A[m,n] and B[m] solves AX = B for X[n].
 When m=&gt;n, have over constrained system, finds least squares solution for X.
 When m&lt;n, have under constrained system, finds least norm solution for X.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Inverse(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] find it&apos;s inverse.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenSpectrumWhenSymmetric(FSharp.Stats.Matrix{System.Double})">
<summary>
 Compute eigenvalues and eigenvectors for a real symmetric matrix.
 Returns arrays of the values and vectors (both based on reals).
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenValuesWhenSymmetric``2(``0)">
<summary>
 Compute eigenvalues for a real symmetric matrix.
 Returns array of real eigenvalues.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenValues``2(``0)">
<summary>
 Compute eigenvalues of a square real matrix.
 Returns arrays containing the eigenvalues which may be complex.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EVD``2(``0)">
<summary>
Compoutes for an N-by-N real nonsymmetric matrix A, the
eigenvalue decomposition eigenvalues and right eigenvectors.
The right eigenvector v(j) of A satisfies

                 A * v(j) = lambda(j) * v(j)

where lambda(j) is its eigenvalue.
The computed eigenvectors are normalized to have Euclidean norm
equal to 1 and largest component real. Uses the LAPACK subroutine dgeev with arguments JOBVR = &apos;V&apos; and JOBVL = &apos;N&apos;

Returns the real (first array) and imaginary (second array) parts of the eigenvalues and a matrix containing the corresponding eigenvectors
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.preDivideByMatrix(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,m] and B[n,k] solve for X[m,k] such that AX = B
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.preDivideByVector(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Given A[n,m] and B[n] solve for x[m] such that Ax = B
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.tryFindRoot(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">
<summary>
 accuracy is not sufficient to reach a root 
</summary>
</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.tryFindRootWith(System.Double,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.updateBounds``2(Microsoft.FSharp.Core.FSharpFunc{System.Double,``0},System.Double,System.Double,``1,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.attemptInverseQuadraticInterpolation``1(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,``0,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.acceptBisection``2(``0,``1)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.acceptInterPolation``1(``0,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.checkConvergence(System.Double,System.Double,System.Double,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.adjustBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Integration.Differentiation.differentiateThreePoint(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Three-Point Differentiation Helper.
 xValues Sample Points t.
 yValues Sample Values x(t)
 idxT Index of the point of the differentiation.&lt;/param&gt;
 idx0 Index of the first sample.&lt;/param&gt;
 idx1 Index of the second sample.&lt;/param&gt;
 idx2 Index of the third sample.&lt;/param&gt;
</summary>
</member>
<member name="M:FSharp.Stats.Integration.Differentiation.TwoPointDifferentiation.differentiateOptimalH(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double)">
<summary>
Returns the approximation of f&apos;(x) at x by calculating the two point differentiation.
Calculates optimal h for the &quot;differentiate&quot;-function from a preset, suggested array.
h is tested from h = 0.01 to 5e^-100 in [|0.01; 0.005; 0.001; 0.0005; 0.0001 ..|]-increments. 
f is the function and x the point at which numerical differentiation is calculated.
</summary>
</member>
<member name="M:FSharp.Stats.Integration.Differentiation.TwoPointDifferentiation.differentiateOptimalHBy(System.Double[],Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double)">
<summary>
Returns the approximation of f&apos;(x) at x by calculating the two point differentiation.
Finds optimal h from all values given in hArr and calculates &quot;differentiate&quot; -function.
f is the function and x the point at which numerical differentiation is calculated.
</summary>
</member>
<member name="M:FSharp.Stats.Integration.Differentiation.TwoPointDifferentiation.optimalStepSize(System.Double[],Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double)">
<summary>
Returns the optimal size for h from all tested values in hArr. f is the function and x the point at which the numerical differentiation is calculated.
</summary>
</member>
<member name="M:FSharp.Stats.Integration.Differentiation.TwoPointDifferentiation.differentiate(System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double)">
<summary>
Returns the approximation of f&apos;(x) at x by calculating the two point differentiation.
h is the window for the difference calculation. f is the function for which to calculate numerical differentiation. x is the point at which the difference between &quot;x and x+h&quot;/&quot;x-h and x+h&quot; is calculated.
</summary>
</member>
<member name="M:FSharp.Stats.Integration.Differentiation.TwoPointDifferentiation.iterUntili``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Int32,System.Int32,``0[])">
<summary>
 Iterates the data array beginning from the startIdx. 
 The step size and direction are implied by magnitude and sign of stepSize. The function returns
 the idx of the first value for which predicate returns true or the end/start of the collection
 is reached (returning None). The predicate function takes the idx of the current value as an additional
 parameter.
</summary>
</member>
<member name="T:FSharp.Stats.Integration.Differentiation.TwoPointDifferentiation">
<summary>
A two-point estimation is to compute the slope of a nearby secant line through two points.
This gives an approximations of f&apos;(x) at x respectively to two points &quot;x and x+h&quot;/&quot;x-h and x+h&quot;(depending on the used algorithm) of the function f.
Choosing a small number h, h represents a small change in x, and it can be either positive or negative.
</summary>
</member>
<member name="T:FSharp.Stats.Integration.Differentiation">
<summary>
In numerical analysis, numerical differentiation describes algorithms for estimating the derivative of a mathematical function using values of the function and perhaps other knowledge about the function.
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Brent.maximize(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">
<summary>
 Finds the maximum in the given function between the lower and upper boundary with tolerance 10^-7 via brent search. Returns None if 100 iterations are reached.   
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Brent.maximizeWith(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double,System.Double,System.Int32)">
<summary>
 Finds the maximum in the given function between the lower and upper boundary with given tolerance via brent search. Returns None if maxiterations are reached.
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Brent.minimize(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">
<summary>
 Finds the minimum in the given function between the lower and upper boundary with tolerance 10^-7 via brent search. Returns None if 100 iterations are reached.   
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Brent.minimizeWith(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double,System.Double,System.Int32)">
<summary>
 Finds the minimum in the given function between the lower and upper boundary with given tolerance via brent search. Returns None if maxiterations are reached.
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Brent.computeNewStep(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
 Compute stepsize
</summary>
</member>
<member name="P:FSharp.Stats.Optimization.Brent.doubleEpsilon">
<summary>
 TO-DO: Refactor to global (ops)
</summary>
</member>
<member name="P:FSharp.Stats.Optimization.Brent.goldSectionRatio">
<summary>
 (3.9 - sqrt(5)) / 2
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Bisection.tryFindRoot(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double,System.Double,System.Int32)">
<summary>
Finds the value in an interval for which a given function returns a value close to 0 
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.Polynomial.getDerivative(FSharp.Stats.Vector{System.Double},System.Int32,System.Double)">
<summary>
gets derivative at x with given polynomial coefficients. Level1 = fst derivative; Level2 = smd derivative ...
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.Polynomial.fit(FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
takes interpolating
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.Polynomial.coefficients(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
calculates the polynomial coefficients for interpolating the given unsorted data. No duplicates allowed!
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.C1">
<summary>
 First order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.C0">
<summary>
 Zero order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.XValues">
<summary>
 sample points (N+1), sorted ascending
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.differentiate(FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef,System.Double)">
<summary>
 Differentiate at point x
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.interpolate(FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef,System.Double)">
<summary>
 Interpolate at point x
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolate(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from unsorted x,y data     
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolateInplace(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from unsorted x,y data 
 Works in place
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolateSorted(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from sorted x,y data
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.createLinearSplineCoef(System.Double[],System.Double[],System.Double[])">

</member>
<member name="T:FSharp.Stats.Interpolation.CubicSpline.Simple.BoundaryCondition.Clamped">
<summary>
f&apos; at first and last knot are set by user
</summary>
</member>
<member name="T:FSharp.Stats.Interpolation.CubicSpline.Simple.BoundaryCondition.Quadratic">
<summary>
first and last polynomial are quadratic, not cubic
</summary>
</member>
<member name="T:FSharp.Stats.Interpolation.CubicSpline.Simple.BoundaryCondition.NotAKnot">
<summary>
f&apos;&apos;&apos; at second and penultimate knot are continuous
</summary>
</member>
<member name="T:FSharp.Stats.Interpolation.CubicSpline.Simple.BoundaryCondition.Parabolic">
<summary>
f&apos;&apos; at first/second and last/penultimate knot are equal
</summary>
</member>
<member name="T:FSharp.Stats.Interpolation.CubicSpline.Simple.BoundaryCondition.Periodic">
<summary>
f&apos; at first point is the same as f&apos; at the last point
</summary>
</member>
<member name="T:FSharp.Stats.Interpolation.CubicSpline.Simple.BoundaryCondition.Natural">
<summary>
most used spline variant: f&apos;&apos; at borders is set to 0
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Simple.fitForce(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
forces a spline fit even outside of the interval defined in x_Values
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Simple.fit(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
Fits a cubic spline with given coefficients. Only defined within the range of the given x_Values
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Simple.coefficients(FSharp.Stats.Interpolation.CubicSpline.Simple.BoundaryCondition,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
computes all coefficients for piecewise interpolating splines. In the form of [a0;b0;c0;d0;a1;b1;...;d(n-2)]. 
where: fn(x) = (an)x^3+(bn)x^2+(cn)x+(dn)
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Simple.Hermite.getSlopesTryMonotonicity(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
if the knots are monotone in/decreasing, the spline also is monotone (http://www.korf.co.uk/spline.pdf)
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Simple.Hermite.getSimpleSlopes(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
calculates the slopes by averaging the slopes of neighbouring tangents
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Simple.Hermite.cubicHermite(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
calculates a function to interpolate between the datapoints with given slopes (y_Data&apos;).
the data has to be sorted ascending
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients.C3">
<summary>
 Third order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients.C2">
<summary>
 Second order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients.C1">
<summary>
 First order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients.C0">
<summary>
 Zero order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients.XValues">
<summary>
 sample points (N+1), sorted ascending
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.definiteIntegral(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.integrate(FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.computeIndefiniteIntegral(FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.secondDerivative(FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.firstDerivative(FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.interpolateAtX(FSharp.Stats.Interpolation.CubicSpline.Differentiable.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.akimaCoefficients(System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.leftSegmentIdx``1(``0[],``0)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.interpolateHermiteSorted(System.Double[],System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.Differentiable.createSplineCoefficients(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.Approximation.approx(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double})">
<summary>
 Return a sequence of points which linearly interpolate given data points, or a function performing the linear interpolation.
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.Approximation.regularizeValues(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double})">
<summary>
 Regularize (like R! regularize.values) used in approx
 1. pairs x -y values 
 2. filters nan on both sides and sortby x
 3. handels ties by given function
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.pad``1(System.Tuple{``0,System.Double}[],System.Double,System.Double,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}},System.Int32,FSharp.Stats.Signal.Padding.BorderPaddingMethod,FSharp.Stats.Signal.Padding.InternalPaddingMethod,FSharp.Stats.Signal.Padding.HugeGapPaddingMethod)">
<summary>
Adds additional data points to the beginning and end of data set (number: borderpadding; x_Value distance: minDistance; y_Value: random).
Between every pair of data point where the difference in x_Values is greater than minDistance, additional datapoints are generated as defined in internalPaddingMethod.
If huge data chunks are missing (missing gap &lt; maxDistance), data points are added as defined in hugeGapPaddingMethod.
default: internalPaddingMethod=LinearInterpolation; hugeGapPaddingMethod=Random (like in border cases)
getDiff: get the difference in x_Values as float representation (if &apos;a is float then (-))
addToXValue: function that adds a float to the x_Value (if &apos;a is float then (+))
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.Discrete.padZero``1(``0[],System.Int32)">
<summary>
Adds additional data points to the beginning and end of data set (number: borderpadding; y_Value: random).
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.Discrete.padRnd``1(``0[],System.Int32)">
<summary>
Adds additional data points to the beginning and end of data set (number: borderpadding; y_Value: random).
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.Discrete.ThreeDimensional.pad``1(``0[0:, 0:],System.Int32,FSharp.Stats.Signal.Padding.Discrete.ThreeDimensional.Padding3DMethod)">
<summary>
 padds artificial data points to the borders of the given Array2D. increment=1; n=borderpadding
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.getMinimumSpacing``1(System.Tuple{``0,System.Double}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}})">
<summary>
minimum spacing of the data points
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.getMedianSpacing``1(System.Tuple{``0,System.Double}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}})">
<summary>
median spacing of the data points
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.getAvgSpacing``1(System.Tuple{``0,System.Double}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}})">
<summary>
average spacing of the data points
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.Int.addToXValueInt(System.Int32,System.Double)">
<summary>
addToXValue: adds toAdd to a
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.Int.getDiffInt(System.Int32,System.Int32)">
<summary>
getDiff: calculates the difference of the two events
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.Float.addToXValueFloat(System.Double,System.Double)">
<summary>
addToXValue: adds toAdd to a (+)
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.Float.getDiffFloat(System.Double,System.Double)">
<summary>
getDiff: calculates the difference of the two events (-)
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.Time.addToXValueHours(System.DateTime,System.Double)">
<summary>
addToXValue: adds minutes to the date
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.Time.addToXValueMinutes(System.DateTime,System.Double)">
<summary>
addToXValue: adds minutes to the date
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Padding.HelperFunctions.Time.getDiffMinutes(System.DateTime,System.DateTime)">
<summary>
getDiff: calculates the time span between the two events as total minutes (float)
</summary>
</member>
<member name="T:FSharp.Stats.Signal.Padding">
<summary>
padds data points to the beginning, the end and on internal intervals of the data
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.inverseSymmetricScalingInPlace(System.Double[])">
<summary>
 Universal; Symmetric scaling and common exponent (used in Maple) Default
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.inverseAsymmetricScalingInPlace(System.Double[])">
<summary>
 Only scale by 1/N in the inverse direction; No scaling in forward direction.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.symmetricScalingInPlace(System.Double[])">
<summary>
 Universal; Symmetric scaling and common exponent (used in Maple) Default InverseExponent
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.asymmetricScalingInPlace(System.Double[])">
<summary>
 No scaling in forward direction.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.bluestein(FSharp.Stats.Complex[])">
<summary>
 Bluesteinï¿½s convolution algorith
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.bitrev``1(``0[])">
<summary>
 Reorder the elements of the input array in lexicographic order by the bits of their indices
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.mapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
<summary>
 Applying the given function to each of the elements of the array and returns the value in place.
</summary>
</member>
<member name="T:FSharp.Stats.Signal.FFT">
<summary>
 FFT analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa.
</summary>
</member>
<member name="T:FSharp.Stats.Signal.Wavelet.Marr">
<summary>
3D-wavelet
</summary>
</member>
<member name="T:FSharp.Stats.Signal.Wavelet.Ricker">
<summary>
Ricker, or Mexican hat wavelet
</summary>
</member>
<member name="M:FSharp.Stats.Signal.ContinuousWavelet.transformDefaultZero(System.Tuple{System.Double,System.Double}[],FSharp.Stats.Signal.Wavelet.Ricker)">
<summary>
minDistance is half the overall minimum spacing; maxDistance is infinity; internal padding=zero; hugeGap padding=zero (but redundant)
</summary>
</member>
<member name="M:FSharp.Stats.Signal.ContinuousWavelet.transformDefault(System.Tuple{System.Double,System.Double}[],FSharp.Stats.Signal.Wavelet.Ricker)">
<summary>
minDistance is half the median spacing; maxDistance is 10 times the median spacing; internal padding=linear interpolation; hugeGap padding=random
</summary>
</member>
<member name="M:FSharp.Stats.Signal.ContinuousWavelet.transform``1(System.Tuple{``0,System.Double}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},System.Int32,FSharp.Stats.Signal.Wavelet.Ricker)">
<summary>
calculates the continuous wavelet transform: 
data: data to transform (x_Value,y_Value) [];
getDiff: get the difference in x_Values as float representation (if &apos;a is float then (-))
borderpadding: define the number of points padded to the beginning and end of the data (has to be the same as used in padding)
wavelet: used wavelet
</summary>
</member>
<member name="M:FSharp.Stats.Signal.ContinuousWavelet.HelperFunctions.Int.getDiffInt(System.Int32,System.Int32)">
<summary>
getDiff: calculates the difference of the two events
</summary>
</member>
<member name="M:FSharp.Stats.Signal.ContinuousWavelet.HelperFunctions.Float.getDiffFloat(System.Double,System.Double)">
<summary>
getDiff: calculates the difference of the two events (-)
</summary>
</member>
<member name="M:FSharp.Stats.Signal.ContinuousWavelet.HelperFunctions.Time.getDiffMinutes(System.DateTime,System.DateTime)">
<summary>
getDiff: calculates the time span between the two events as total minutes (float)
</summary>
</member>
<member name="T:FSharp.Stats.Signal.ContinuousWavelet">
<summary>
Continuous wavelet transform on non discrete data
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.baselineAls'(System.Int32,System.Int32,System.Double,System.Double[])">
<summary>
 Asymmetric Least Squares Smoothing using sparse Matrix
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.baselineAls(System.Int32,System.Int32,System.Double,System.Double[])">
<summary>
 Asymmetric Least Squares Smoothing by P. Eilers and H. Boelens in 2005
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.diff(System.Int32,System.Double[0:, 0:])">
<summary>
 Calculate the n-th order discrete difference along given axis.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.diag``1(System.Int32,``0)">
<summary>
 Creates a diagonal 2-D array with the given order and set all diagonal values to x
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Filtering.optimizeWindowWidth(System.Int32,System.Int32[],System.Double[],System.Double[])">
<summary>
 Estimates the autocorrelation at lag 1 of a blank signal (containing only noise). Subsequently, the signal of interest is smoothed
 several times by a savitzky golay filter using constant polynomial order and variing windowWidth. For each iteration, the deviation
 of the smoothed to the original signal is computed and the autocorrelation at lag 1 of this residual noise is computed. The function returns the optimized
 window width yielding a autocorrelation at lag 1 closest to the value computed for the blank signal.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Filtering.savitzky_golay(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[])">
<summary>
 Smooth (and optionally differentiate) data with a Savitzky-Golay filter.
 The Savitzky-Golay filter is a type of low-pass filter and removes high frequency noise from data.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Convolution.convolve(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Computes a complete non-circular convolution of x and y. This function does not use
 the fast fourier transformation to calculate the convolution and can be slow if x and y are large.
 This function does not perform a padding of x and y. 
</summary>
</member>
<member name="T:FSharp.Stats.Signal.PeakDetection.IdentifiedPeak">

</member>
<member name="T:FSharp.Stats.Signal.PeakDetection.PeakFeature">

</member>
<member name="T:FSharp.Stats.Signal.PeakDetection.Extrema">

</member>
<member name="T:FSharp.Stats.Signal.PeakDetection.Tag`2">

</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.labelPeaks(System.Double,System.Double,System.Double[],System.Double[])">
<summary>
 Returns a collection of local Maxima and Minima. Attention: The algorithm is very sensitive to noise   
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.idxOfClosestPeakBy(System.Double[],System.Double[],System.Double)">
<summary>
 Returns Index of the highestPeak flanking a given mzValue
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.idxOfHighestPeakBy(System.Double[],System.Double[],System.Double)">
<summary>
 Returns Index of the highestPeak flanking a given x value (xt)
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.localMinimaIdx(System.Double[],System.Double[])">
<summary>
 Returns a collection of indices corresponding to local minima. Attention: The algorithm is very sensitive to noise   
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.localMinima(System.Double[],System.Double[])">
<summary>
 Returns a collection of local minima. Attention: The algorithm is very sensitive to noise   
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.localMaximaIdx(System.Double,System.Double[],System.Double[])">
<summary>
 Returns a collection of indices corresponding to local maxima. Attention: The algorithm is very sensitive to noise and behaves irregulary for negative Y-values.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.localMaxima(System.Double,System.Double[],System.Double[])">
<summary>
 Returns a collection local maxima. Attention: The algorithm is very sensitive to noise and behaves irregulary for negative Y-values.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.createIdentifiedPeak(FSharp.Stats.Signal.PeakDetection.PeakFeature,Microsoft.FSharp.Core.FSharpOption{FSharp.Stats.Signal.PeakDetection.PeakFeature},FSharp.Stats.Signal.PeakDetection.PeakFeature,Microsoft.FSharp.Core.FSharpOption{FSharp.Stats.Signal.PeakDetection.PeakFeature},FSharp.Stats.Signal.PeakDetection.PeakFeature,System.Boolean,System.Boolean,System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.createPeakFeature(System.Int32,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.iterUntili``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Int32,System.Int32,``0[])">
<summary>
 TODO: Add FSharpAux reference
 Iterates the data array beginning from the startIdx. 
 The step size and direction are implied by magnitude and sign of stepSize. The function returns
 the idx of the first value for which predicate returns true or the end/start of the collection
 is reached (returning None). The predicate function takes the idx of the current value as an additional
 parameter.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.iterUntil``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Int32,System.Int32,``0[])">
<summary>
 TODO: Add FSharpAux reference
 Iterates the data array beginning from the startIdx. 
 The step size and direction are implied by magnitude and sign of stepSize. The function returns
 the idx of the first value for which predicate returns true or the end/start of the collection
 is reached (returning None). 
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.SecondDerivative.getPeaks(System.Double,System.Int32,System.Int32,System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.SecondDerivative.filterpeaks``1(System.Double,System.Double[],FSharp.Stats.Signal.PeakDetection.Tag{FSharp.Stats.Signal.PeakDetection.Extrema,``0}[])">

</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.SecondDerivative.characterizePeak(System.Double[],System.Double[],System.Double[],FSharp.Stats.Signal.PeakDetection.Tag{FSharp.Stats.Signal.PeakDetection.Extrema,System.Tuple{System.Double,System.Double}}[],System.Int32)">

</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.SecondDerivative.findRightBorderOf(System.Double[],System.Double[],System.Double[],FSharp.Stats.Signal.PeakDetection.Tag{FSharp.Stats.Signal.PeakDetection.Extrema,System.Tuple{System.Double,System.Double}}[],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Given a noisy data set, the labled negative second derivative, the index of a putative peak and the index of the peak lift of position, the function iterates
 in the positive direction returns a tuple. The first value of the tuple indicates if the peak is isolated (true indicates yes) and the second value is the 
 index index of the determined peak end. 
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.SecondDerivative.findLeftBorderOf(System.Double[],System.Double[],System.Double[],FSharp.Stats.Signal.PeakDetection.Tag{FSharp.Stats.Signal.PeakDetection.Extrema,System.Tuple{System.Double,System.Double}}[],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Given a noisy data set, the labled negative second derivative, the index of a putative peak and the index of the peak lift of position, the function iterates
 in the positive direction returns a tuple. The first value of the tuple indicates if the peak is isolated (true indicates yes) and the second value is the 
 index index of the determined peak end. 
</summary>
</member>
<member name="M:FSharp.Stats.Signal.PeakDetection.SecondDerivative.tryFindPeakEnd(System.Int32,System.Double[],System.Double[],System.Double[],FSharp.Stats.Signal.PeakDetection.Tag{FSharp.Stats.Signal.PeakDetection.Extrema,System.Tuple{System.Double,System.Double}}[],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Given a noisy data set, the labled negative second derivative, the index of a putative peak and the index of the peak lift of position, the function iterates
 in the direction given by the step parameter and returns a tuple. The first value of the tuple indicates if the peak is isolated (true indicates yes) and the second value is the 
 index index of the determined peak end. 
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Distribution`2">
<summary>
 Interface which every probability distribution must implement.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.uLSCV(System.Double[],Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Least squares cross-validation of bandwidth (unbiased)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.nrd0(System.Double[])">
<summary>
 Implements Silverman&apos;s ârule of thumbâ for choosing the bandwidth of a Gaussian kernel density estimator.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.freedmanDiaconis(System.Double[])">
<summary>
 Calcultes bandwidth based on the FreedmanâDiaconis rule
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.scottNormal(System.Double[])">
<summary>
 Calcultes bandwidth according to Scott&apos;s normal reference rule
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.forHistogram(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Simple bandwidth for histogram
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.fromBinNumber``3(``0,``1,``2)">
<summary>
 Calculates the bandwidth from min max and number of bins
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.riceRule(System.Double)">
<summary>
The Rice Rule is presented as a simple alternative to Sturges&apos;s rule.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.sturges(System.Double)">
<summary>
 Sturges&apos; formula is derived from a binomial distribution and implicitly assumes an approximately normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.sqrt(System.Double)">
<summary>
 Square-root choice
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.fromBandwidth(System.Double,System.Double,System.Double)">
<summary>
 Compute the number of bins from bandwidth
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Bandwidth.BinNumber">
<summary>
 Compute the number of bins for a histogram
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Bandwidth">
<summary>
 Bandwidth selectors 
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.isSubset(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32},Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Checks whether the values in this histogram A are a subset of the values in the histogram B
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.frequencies(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Gets an unsorted sequence of frequencies
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.frequencyAt(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32},System.Double)">
<summary>
 Gets the frequency associated with the value x
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.maxLike(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Gets the largest frequency in the map.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.average(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns the average of the frequencies in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.sum(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns the total of the frequencies in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.getZip(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns tuple of (sorted value sequence, frequence sequence)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.create(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates probability mass function (histogram)    
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.createGeneric``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Given the list [a,b,a,c,b,b], produce a map {a:2, b:3, c:1} which contains the count of each unique item in the list
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Frequency">
<summary>
 Represents a histogram (map from values to integer frequencies).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.create(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates probability mass function    
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.exp(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Exponentiates the probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.log(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Log transforms the probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.var(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the variance of a PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.varAround(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the variance of a PMF around mu
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.mean(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the mean of a PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.random(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Chooses a random element from this PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizePDD(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF by the bandwidth to area equals 1.  (n/N)/Îx
 Probability Denisty Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizeBandwidth(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF by the bandwidth n/Îx
 Frequency Denisty Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizePercentage(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals 100 percent 
 Discrete Percentage Probability Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalize(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals 1. 
 Discrete Probability Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizewith(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals fraction
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.probabilities(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Gets an unsorted sequence of probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.probabilityAt(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double},System.Double)">
<summary>
 Gets the probability associated with the value x
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getYValues(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns distinct values from pmf
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getXValues(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns distinct values from pmf
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.maxLike(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns the largest probability in the map.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.sum(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns the total of the probabilities in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getZip(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns: tuple of (sorted value sequence, probability sequence)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.ofHistogram``1(Microsoft.FSharp.Collections.FSharpMap{``0,System.Int32})">
<summary>
 Creates Pmf of a Histogram (normalize by n)
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Empirical">
<summary>
 Represents a probability mass function (map from values to probabilities).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.PDF``1(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Estimate(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Estimates the log-normal distribution parameters from sample data with maximum-likelihood.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.CDF``2(System.Double,System.Double,``0)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.LogNormal">
<summary>
 Log-Normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: (0., Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.F">
<summary>
 F-distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Variance(System.Double,System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Support(System.Double,System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: (Negative Infinity, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.StandardDeviation(System.Double,System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Sample(System.Double,System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.PDF(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Mean(System.Double,System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.CDF(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.StudentT">
<summary>
 Student&apos;s T-distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0.0, 1.0).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Beta">
<summary>
 Beta distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Gamma">
<summary>
 Gamma distribution
 Sampling implementation based on:
     &quot;A Simple Method for Generating Gamma Variables&quot; - Marsaglia &amp; Tsang
     ACM Transactions on Mathematical Software, Vol. 26, No. 3, September 2000, Pages 363-372.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Sample(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Exponential">
<summary>
 Exponential distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.init(System.Double,System.Double)">
<summary>
 Initializes a Normal distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Estimate(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Estimates the Normal distribution parameters from sample data with maximum-likelihood.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Normal">
<summary>
 Normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Uniform">
<summary>
 Uniform distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Sample(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.PDFLn(System.Double,System.Double)">
<summary>
 Computes the logarithm of probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.ChiSquared">
<summary>
 ChiSquared distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.logNormal(System.Double,System.Double)">
<summary>
 Initializes a Normal distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.f(System.Double,System.Double)">
<summary>
 Initializes a F-distribution         
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.studentT(System.Double,System.Double,System.Double)">
<summary>
 Initializes a Student&apos;s T-distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.beta(System.Double,System.Double)">
<summary>
 Initializes a Beta distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.gamma(System.Double,System.Double)">
<summary>
 Initializes a Gamma distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.exponential(System.Double)">
<summary>
 Initializes a Exponential distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.normal(System.Double,System.Double)">
<summary>
 Initializes a Normal distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.uniform(System.Double,System.Double)">
<summary>
 Initializes a uniform distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.chiSquared(System.Double)">
<summary>
 Initializes a ChiSquared distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.Variance``1(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.Support``1(System.Double)">
<summary>
 Returns the support of the Binomial distribution: (0., n).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.StandardDeviation``1(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.SampleUnchecked``1(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.Sample``1(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.PDF(System.Double,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.Mean``1(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Poisson.CDF``1(System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Poisson">
<summary>
Binomial distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Variance(System.Double,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Support(System.Double,System.Int32)">
<summary>
 Returns the support of the Binomial distribution: (0., n).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.StandardDeviation(System.Double,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.SampleUnchecked(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Sample(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.PDF(System.Double,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Mean(System.Double,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.CDF(System.Double,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Wilcoxon">
<summary>
Wilcoxon distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Variance(System.Double,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Support(System.Double,System.Int32)">
<summary>
 Returns the support of the Binomial distribution: (0., n).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.StandardDeviation(System.Double,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.SampleUnchecked(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Sample(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.PDF(System.Double,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Mean(System.Double,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.CDF(System.Double,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Binomial">
<summary>
Binomial distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Variance(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Support(System.Int32,System.Int32,System.Int32)">
<summary>
 Returns the support of the hypergeometric distribution: (0., Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.StandardDeviation(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.SampleUnchecked(System.Int32,System.Int32,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Sample(System.Int32,System.Int32,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.PDF(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Mean(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.CDF(System.Int32,System.Int32,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Hypergeometric">
<summary>
Hypergeometric distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Sample``1(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Bernoulli">
<summary>
 Bernoulli distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.poisson(System.Double)">
<summary>
 Initializes a Binomial distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.wilcoxon(System.Double,System.Int32)">
<summary>
 Initializes a Wilcoxon distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.binomial(System.Double,System.Int32)">
<summary>
 Initializes a Binomial distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.hypergeometric(System.Int32,System.Int32,System.Int32)">
<summary>
 Initializes a hypergeometric distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.bernoulli(System.Double)">
<summary>
 Initializes a uniform distribution        
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete">
<summary>
 Discrete probability distributions
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.mapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
<summary>
 Applying the given function to each of the elements of the array and returns the value in place.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.cosine(System.Double,System.Double)">
<summary>
 Cosine kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.biweight(System.Double,System.Double)">
<summary>
 Biweight kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.epanechnikov(System.Double,System.Double)">
<summary>
 Epanechnikov kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.triangular(System.Double,System.Double)">
<summary>
 Triangular kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.rectangular(System.Double,System.Double)">
<summary>
 Rectangular kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.gaussian(System.Double,System.Double)">
<summary>
 Gausian kernel
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.KernelDensity">
<summary>
 Module to perform Kernel density estimation
</summary>
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.ChiSquareStatistics">
 <summary>
   Computes the Chi-Square test statistics for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="Statistic">The test statistic.</param>
 <param name="DegreesOfFreedom">The degrees of freedom for the numerator.</param>    
 <param name="PValueLeft">One Tailed/Sided.</param>
 <param name="PValueRight"> One Tailed/Sided.</param>   
 <param name="PValue">Two Tailed/Sided.</param>   
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.FTestStatistics">
 <summary>
   Creates a new F-Test for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="statistic">The test statistic.</param>
 <param name="d1">The degrees of freedom for the numerator.</param>
 <param name="d2">The degrees of freedom for the denominator.</param>
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.TTestStatistics">
 <summary>
   Creates a new T-Test for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="Statistic">The test statistic.</param>
 <param name="DegreesOfFreedom">The degrees of freedom for the numerator.</param>    
 <param name="PValueLeft">One Tailed/Sided.</param>
 <param name="PValueRight"> One Tailed/Sided.</param>   
 <param name="PValue">Two Tailed/Sided.</param>   
</member>
<member name="M:FSharp.Stats.Testing.Anova.twoWayANOVA(FSharp.Stats.Testing.Anova.TwoWayAnovaModel,System.Double[][][])">
<summary>
 Calculates two-way ANOVA as an extension of the one-way ANOVA for two independent variables.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.Anova.oneWayAnova``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculates one-way analysis of variance (one-way ANOVA) which is a technique used to compare means of two or more samples (using the F distribution)
 The ANOVA tests the null hypothesis that samples in two or more groups are drawn from populations with the same mean values.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.TTest.twoSamplePaired(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 which observations in one sample can be paired with observations in the other sample.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.TTest.twoSample(System.Boolean,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Computes a t-test or a Welch test (unequal variances)
</summary>
</member>
<member name="M:FSharp.Stats.Testing.TTest.noAssumtion(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
 Equal or unequal sample sizes, assume nothing about variance.
 input: (mean1,variance1,N1) (mean2,variance2,N3)
</summary>
</member>
<member name="M:FSharp.Stats.Testing.ChiSquareTest.compute(System.Int32,System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Computes the Chi-Square test
</summary>
</member>
<member name="T:FSharp.Stats.Testing.ChiSquareTest">
 <summary>
   Two-Sample (Goodness-of-fit) Chi-Square Test (Upper Tail)
 </summary>
 
 <remarks>
 <para>
   A chi-square test (also chi-squared or Ï2  test) is any statistical
   hypothesis test in which the sampling distribution of the test statistic
   is a <see cref="ChiSquareDistribution">chi-square distribution</see> when
   the null hypothesis is true, or any in which this is asymptotically true,
   meaning that the sampling distribution (if the null hypothesis is true) 
   can be made to approximate a chi-square distribution as closely as desired
   by making the sample size large enough.</para>
 <para>
   The chi-square test is used whenever one would like to test whether the
   actual data differs from a random distribution. </para>
   
 <para>
   References:
   <list type="bullet">
     <item><description><a href="http://en.wikipedia.org/wiki/Chi-square_test">
        Wikipedia, The Free Encyclopedia. Chi-Square Test. Available on:
        http://en.wikipedia.org/wiki/Chi-square_test </a></description></item>
   
     <item><description><a href="http://www2.lv.psu.edu/jxm57/irp/chisquar.html">
        J. S. McLaughlin. Chi-Square Test. Available on:
        http://www2.lv.psu.edu/jxm57/irp/chisquar.html </a></description></item>
   </list></para>
 </remarks>
 
</member>
<member name="M:FSharp.Stats.Testing.Bartlett.compute``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Bartlett&apos;s test for equality of variances
 Tests the null hypothesis that all group variances are equal
</summary>
</member>
<member name="M:FSharp.Stats.Testing.PostHoc.tukeyHSD(System.Double[][],System.Double[][])">
<summary>
 Tukey-Kramer approach
</summary>
</member>
<member name="M:FSharp.Stats.Testing.MultipleTesting.benjaminiHochbergFDRBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,System.Double}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Benjamini-Hochberg Correction (BH)
 &apos;projection&apos; should return a tuple of any identifier and the pValues as float, when applied to &apos;rawP&apos;
 This function applies the Benjamini-Hochberg multiple testing correcture and returns all False Discovery Rates to which the given p-values are still 
 significant.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.MultipleTesting.Qvalues.ofPValues(System.Double,System.Double[])">
<summary>
 Calculates q-values from given p-values and returns an array of qValues in the same order.
 &apos;pi0&apos; can be calculated with &apos;pi0Bootstrap&apos; or &apos;pi0BootstrapWithLambda&apos;.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.MultipleTesting.Qvalues.ofPValuesRobust(System.Double,System.Double[])">
<summary>
 Calculates q-values from given p-values and returns an array of qValues in the same order.
 &apos;pi0&apos; can be calculated with &apos;pi0Bootstrap&apos; or &apos;pi0BootstrapWithLambda&apos;.
 See Storey JD (2002) JRSS-B 64: 479-498.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.MultipleTesting.Qvalues.bindBy(System.Double[],System.Double[])">
<summary>
 When used for QValues.ofPValues(Robust) it iterates through the pValues in ascending order and compares their new QValues.
 To do this it compares the QValues in the ascending order of the PValues (QValues are sorted by their related PValues so that the first QValue is the one which is related to the previously smalles PValue). 
 Should the QValue related to the second PValue (QValue.[1]) be smaller the the QValue related to the smallest PValue (QValue.[0]) the later QValue is 
 replaced by the first QValue (QValue.[1] &lt;- (QValue.[0])). Should all following QValues be smaller than that QVal, all will be replaced by it.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.MultipleTesting.Qvalues.pi0Bootstrap(System.Double[])">
<summary>
 Estimates pi0 from given p-Values by Storeys bootstrap method using default lambda&apos;s
 pi0 is the value to which, one can find certain values of the distribution at random.
 If this returns 0. default lambda needs to be smaller. One should use &apos;pi0BootstrapWithLambda&apos; in this case.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.MultipleTesting.Qvalues.pi0BootstrapWithLambda(System.Double[],System.Double[])">
<summary>
 Estimates pi0 from given p-Values by Storeys bootstrap .
 pi0 is the value to which, one can find certain values of the distribution at random.
 If this returns 0. lambda needs to be smaller.
 Math Definition for lambda = [0,1) . Contains values from 0 to 1, but not 1.
</summary>
</member>
<member name="T:FSharp.Stats.Testing.MultipleTesting.Qvalues">
<summary>
 Estimate the q-values for a given set of p-values. The q-value of a test measures the proportion of false positives incurred (called the false discovery rate) when that particular test is called significant. 
</summary>
</member>
<member name="T:FSharp.Stats.Testing.MultipleTesting">
<summary>
 This module contains functions to adjust for multiple testing errors in statistical tests.
</summary>
</member>
<member name="P:FSharp.Stats.Testing.SAM.SAM.Statistics">
<summary>
 test statistics
</summary>
</member>
<member name="P:FSharp.Stats.Testing.SAM.SAM.Si">
<summary>
 pooled standard error 
</summary>
</member>
<member name="P:FSharp.Stats.Testing.SAM.SAM.Ri">
<summary>
 relative diffence of mean
</summary>
</member>
<member name="T:FSharp.Stats.Testing.SAM.SAM">
<summary>
 Represents the relative difference, the pooled standard error and the test statistics
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.getSymmetricCuts(FSharp.Stats.Testing.SAM.SAM[],FSharp.Stats.Testing.SAM.SAM[])">
<summary>
Finds all pairs of symmetric cutoffs
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.getAsymmetricCuts(FSharp.Stats.Testing.SAM.SAM[],FSharp.Stats.Testing.SAM.SAM[])">
<summary>
Finds all pairs of asymmetric cutoffs according to the differences between di and dEi
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.estimatePi0(FSharp.Stats.Testing.SAM.SAM[],FSharp.Stats.Testing.SAM.SAM[][])">
<summary>
 Estimates pi0. Chosen to minimize the coefficient of variation of the test statistics 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.countIf``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Iterates over elements of the input array and increase the counter if the function returens true
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.permutationImbalanced``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Int32,``0,System.Double[][],System.Double[][])">
<summary>
 Permutes all the samples. Different treatments are mixed.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.permutationBalanced``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Int32,``0,System.Double[][],System.Double[][])">
<summary>
 Permutes all the samples. Different treatments are mixed.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.permutationWithin``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Int32,``0,System.Double[][],System.Double[][])">
<summary>
Permutes all the samples. Different treatments are NOT mixed. Then the statistics for the permuatations is calculated.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.calculateTwoClassUnpaired(System.Double,System.Double[][],System.Double[][])">
<summary>
 Calculates SAM test statistics for two class unpaired data
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.createSAM(System.Double,System.Double,System.Double)">
<summary>
 Creates the type SAM
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.estimateFrom(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Double[][],System.Double[][])">
<summary>
 Estimates s0 from given data set. Chosen to minimize the coefficient of variation of the test statistics 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.estimate(FSharp.Stats.Testing.SAM.SAM[])">
<summary>
 Estimates s0. Chosen to minimize the coefficient of variation of the test statistics 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.median(FSharp.Stats.Testing.SAM.SAM[])">
<summary>
 Creates s0 by calulating the mean of si (pooled standard error )
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.nearestRank(System.Double,FSharp.Stats.Testing.SAM.SAM[])">
<summary>
 Computes s0 using the nearest rank method
</summary>
</member>
<member name="T:FSharp.Stats.Testing.SAM.S0">
<summary>
 Module with different estimation methods computing s0 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.test(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Pearson correlation (nan support by JackKnife leave one out)
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.stdFisherHotellingZ(System.Int32)">
<summary>
 Standart deviation Fisher-Z transformation for Pearson correlation coefficient
 after Hotelling (1953) for n&lt; 50
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.transformFisherHotellingZ(System.Double,System.Double)">
<summary>
 Fisher-Z transformation for Pearson correlation coefficient    
 after Hotelling (1953) for n &lt; 50
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.stdFisherZ(System.Int32)">
<summary>
 Standart deviation Fisher-Z transformation for Pearson correlation coefficient
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.transformFisherZ(System.Double)">
<summary>
 Fisher-Z transformation for Pearson correlation coefficient    
</summary>
</member>
<member name="T:FSharp.Stats.Testing.FisherHotelling">
<summary>
 Fisher-Z transformation for Pearson correlation coefficient after Hotelling (1953) for n&lt; 50
</summary>
</member>
<member name="M:FSharp.Stats.Testing.RMT.compute(System.Double,System.Double,System.Double,System.Double[0:, 0:])">
<summary>
Computes the critical Threshold for which the NNSD of the matrix significantly abides from the Wigner-Surmise
 bwQuantile uses % data to calculate a more robust histogram //0.9 0.01 0.05
</summary>
</member>
<member name="M:FSharp.Stats.Testing.RMT.computeWithInterval(System.Double,System.Double,System.Double,System.Double[0:, 0:],System.Double,System.Double)">
<summary>
Computes the critical Threshold for which the NNSD of the matrix significantly abides from the Wigner-Surmise
 bwQuantile uses % data to calculate a more robust histogram //0.9 0.01 0.05
 to reduce the search space for the threshold you can restrict the range to [leftBorder,rightBorder]
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.CrossValidation.Error.rmse(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Computes root mean square error (RMSE)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.CrossValidation.Error.ssr(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Computes sum of squared residuals (SSR)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.RobustRegression.Linear.theilSenEstimator(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Calculates the robust Theil-Sen estimator for linear regression in the form of [|intercept; slope;|]
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.RobustRegression.Linear.theilEstimator(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Calculates theil&apos;s incomplete method in the form of [|intercept; slope;|]
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.RobustRegression.Linear">
<summary>
 Simple linear regression y : x -&gt; a + bx
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.cooksDistance(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Fits a polynomial model of user defined order to the data and returns the cooks distance for every data pair present in the
 input collections as an estimator for the influence of each data point in coefficient estimation.  
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.getDerivative(FSharp.Stats.Vector{System.Double},System.Int32,System.Double)">
<summary>
gets derivative at x with given polynomial coefficients. Level1 = fst derivative; Level2 = smd derivative ...
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.fit(System.Int32,FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.coefficientsWithWeighting(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the coefficients for polynomial regression with given weighting
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.coefficient(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the coefficients for polynomial regression
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial">
<summary>
 Simple polynomial regression
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RidgeRegression.fit(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Multivariable.fit(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Multivariable.coefficients(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the coefficients for linear regression
 in the form of [|intercept; slope;|]
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Univariable.cooksDistance(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Fits a model (y(x) = b + m * x) to the data and returns the cooks distance for every data pair present in the
 input collections as an estimator for the influence of each data point in coefficient estimation.  
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Univariable.fit(FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Univariable.coefficient(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the coefficients for linear regression
 in the form of [|intercept; slope;|]
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.fit(System.Double,System.Double)">
<summary>
 Fit to x
 coefficient is beta only
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.fitFunc(System.Double,System.Double)">
<summary>
 Returns the regression function
 coefficient is beta only
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.coefficient(Microsoft.FSharp.Collections.FSharpList{System.Double},Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
 Calculates the coefficients for linear regression through the origin 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.coefficientOfVector(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the coefficients for linear regression through the origin 
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO">
<summary>
 Regression through the origin (y : x -&gt; bx)
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear">
<summary>
 Simple linear regression y : x -&gt; a + bx
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.NonLinearRegression.SolverOptions">

</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Model.GetGradientValue">
<summary>
Gradient: Vector of partial derivations of function body
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Model.GetFunctionValue">
<summary>
originally GetValue; contains function body
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.NonLinearRegression.Model">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.solverConverged(FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Collections.Generic.List{FSharp.Stats.Vector{System.Double}})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.shouldTerminate(System.Double,System.Double,System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Fitting.NonLinearRegression.SolverOptions)">
<summary>
 Returns true if convergence criteria are met or a user defined number of iiterations has been carried out
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.updateResidualVectorInPlace(FSharp.Stats.Fitting.NonLinearRegression.Model,System.Double[],System.Double[],FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the residual vector, each row i contains the difference between the yEst_i and the yData_i. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.getRSS(FSharp.Stats.Fitting.NonLinearRegression.Model,System.Double[],System.Double[],FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the residual sum of squares (RSS) as a measure of discrepancy between the data and the used estimation model.
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.createSolverOption(System.Double,System.Double,System.Int32,System.Double[])">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.createModel(System.String[],Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Double,FSharp.Stats.Vector{System.Double}}}})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.standardErrorOfPrediction(System.Double,System.Double[],System.Double[])">

</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.LogisticFunctionVarYAscending">
<summary>
 Logistic function of the form &quot;y = L/(1+e^(-k(t-x)))+N&quot;
 Modified version of the Logistic function model with a variable curve minimum.
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.LogisticFunctionVarYDescending">
<summary>
 Logistic function of the form &quot;y = L/(1+e^(k(t-x)))+N&quot;
 Modified version of the Logistic function model with a variable curve minimum.
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.LogisticFunctionAscending">
<summary>
 Logistic function of the form &quot;y = L/(1+e^(-k(t-x)))&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.LogisticFunctionDescending">
<summary>
 Logistic function of the form &quot;y = L/(1+e^(k(t-x)))&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.LogisticFunction">
<summary>
 Logistic function of the form &quot;y = L/(1+e^(k(t-x)))&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.hillModel">
<summary>
 Hill equation &quot;y = Vm * x^n / (k^n+x^n)&quot;
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.Table.findZ(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Exponentially modified Gaussian (EMG) of the form &quot;y =  ((amp*std)/tau) * sqrt(PI/2.) * exp(1./2. * ((std/tau)**2.) - ((x-meanX)/tau)) * Erfc((1./sqrt(2.)) * ((std/tau)-((x-meanX)/std)))&quot;
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.Table.expSolverOptions(System.Double[],System.Double[])">
<summary>
Takes the result of the linearization as initialGuessParams
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.expModel">
<summary>
 Exponential function of the form &quot;y = a * exp(b * x)&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.gaussModel">
<summary>
 Gaussian function of the form &quot;y = amp * exp( -1. * ( ( ( (x-meanX)**2. ) / (2.*std**2.)) ) )&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.parabolaModel">
<summary>
 paraboola model of the form &quot;y = a * x^2 + b * x + c&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.lineModel">
<summary>
 Line  
 Line model of the form &quot;y = a * x + b&quot;
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.initialParamsOverRange(System.Double[],System.Double[],System.Double[])">
<summary>
 Returns an estimate for an initial parameter for the linear least square estimator for a given dataset (xData, yData).
 The steepness is given as an array and not estimated. An initial estimate is returned for every given steepness.
 The initial estimation is intended for a logistic function.
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.initialParam(System.Double[],System.Double[],System.Double)">
<summary>
 Returns an estimate for an initial parameter for the linear least square estimator for a given dataset (xData, yData).
 The initial estimation is intended for a logistic function.
 The returned parameters are the max y value, the steepness of the curve and the x value in the middle of the slope.
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.estimatedParamsWithRSS(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double,System.Double,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},System.Double[],System.Double[])">
<summary>
 Returns a parameter vector tupled with its residual sum of squares (RSS) as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given
 model function.
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.estimatedParams(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double,System.Double,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},System.Double[],System.Double[])">
<summary>
 Returns a parameter vector as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.estimatedParamsVerbose(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double,System.Double,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},System.Double[],System.Double[])">
<summary>
 Returns an collection of parameter vectors as a possible solution for least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.scaleGradient(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.scaleJacobian(FSharp.Stats.Vector{System.Double},FSharp.Stats.Matrix{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.calculateJacScaleFactors(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.toExternalParameters(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.toInternalParameters(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained.validateBounds(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="T:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardtConstrained">
<summary>
 This LevenbergMarquardt implementation supports the usage of box constrains. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardt.estimatedParams(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double,System.Double,System.Double[],System.Double[])">
<summary>
 Returns a parameter vector as a possible solution for least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardt.estimatedParamsVerbose(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double,System.Double,System.Double[],System.Double[])">
<summary>
 Returns an collection of parameter vectors as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.GaussNewton.estimatedParams(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double[],System.Double[])">
<summary>
 Returns a parameter vector as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.GaussNewton.estimatedParamsVerbose(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double[],System.Double[])">
<summary>
 Returns an collection of parameter vectors as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares.Count">
<summary>
 Count N
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares.Total">
<summary>
 Total sum of squares (SST - total)
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares.Error">
<summary>
 Error sum of squares (SSE - unexplained)
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares.Regression">
<summary>
 Regression sum of squares (SSR - explained) 
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares">
<summary>
 Three sum of squares 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calculateANOVA(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 explained = total - unexplained
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calculateSST(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates SST: sum of squares total
 also: total sum of squares
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calculateSSE(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates SSE: sum of squares of errors
 also: unexplained sum of squares    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.getResiduals(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the residuals
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calcBIC(System.Double,System.Double,System.Double)">
<summary>
 Calculates Bayesian information criterion (BIC) which is a measure of the relative quality of a regression model for a given set of data
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calcAIC(System.Double,System.Double,System.Double)">
<summary>
 Calculates Akaike information criterion (AIC) which is a measure of the relative quality of a regression model for a given set of data    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calculateDeterminationAdj(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
<summary>
 Gets the adjusted coefficient of determination, as known as the R-Squared (RÂ²adj). It is adjusted by the number of used variables (not including the constant term) (https://ebrary.net/1008/economics/adjusted_coefficient_determination_adjusted)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calculateDeterminationFromValue(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Gets the coefficient of determination, as known as the R-Squared (RÂ²)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.stDevIntercept(FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares)">
<summary>
 Standard deviation of intercept (alpha)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.stDevSlope(FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares)">
<summary>
 Standard deviation of slope (beta)    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.stDevY(FSharp.Stats.Fitting.GoodnessOfFit.SumOfSquares)">
<summary>
 Standard deviation of y(x) 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.calculateSumOfSquares(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.OrdinaryLeastSquares.Polynomial.CrossValidation.kfcv(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},System.Int32,System.Int32)">
<summary>
k-fold cross validation
Calculates the average SSE of given data, the order used to fit the polynomial and the subset you want to leave out (k).
Consider to choose k that n%k=0 for equally bin sizes.
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.OrdinaryLeastSquares.Polynomial.CrossValidation.loocv(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},System.Int32)">
<summary>
calculates LeaveOneOutCrossValidation
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.GoodnessOfFit.OrdinaryLeastSquares.Linear.RTO.calculateANOVA(System.Double,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.LogisticRegression.Multivariable.fit(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the regression function
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LogisticRegression.Multivariable.fitFunc(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the regression function
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LogisticRegression.Multivariable.coefficient(System.Double,System.Double,FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the weights for logistic regression.
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LogisticRegression.Univariable.fit(FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
 Returns the regression function
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LogisticRegression.Univariable.coefficient(System.Double,System.Double,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the weights for logistic regression.
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LogisticRegression">
<summary>
 Functions for creating and using logistic regression models.
Implementation taken from Mathias Brandewinder 

https://github.com/mathias-brandewinder/Machine-Learning-In-Action/blob/master/MachineLearningInAction/MachineLearningInAction/LogisticRegression.fs
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.QuantileNormalization.quantileNorm(System.Collections.Generic.IEnumerable{System.Double[]})">
<summary>
 Computes the quantile normalization of a given dataset  
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Spline.smoothingSpline(System.Tuple{System.Double,System.Double}[],System.Double[])">
<summary>
 Creates a smoothing spline through some data. Takes as spline points the x-values given by basispts
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Spline.preprocess(System.Tuple{System.Double,System.Double}[])">
<summary>
 Some preprocessing of the input data
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.Potentials">

</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.MolecularPhenotypes">

</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.SingularValues">
<summary>
Vector containing the singular values resulting from the thin SVD of the input matrix in descending order
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.SingularValuesDiag">
<summary>
diagonal matrix containing the singular values resulting from the thin SVD of the input matrix
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.RightSingularVectors">
<summary>
right singular vectors resulting from the thin SVD of the input matrix
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.LeftSingularVecors">
<summary>
left singular vectors resulting from the thin SVD of the input matrix
</summary>
</member>
<member name="T:FSharp.Stats.ML.SurprisalAnalysis.SAResult">
<summary>
Summary type for the results of applying Surprisal Analysis to a dataset
</summary>
</member>
<member name="M:FSharp.Stats.ML.SurprisalAnalysis.compute(FSharp.Stats.Matrix{System.Double})">
<summary>
performs Surprisal Analysis on the input matrix A. For meaningfull results, A should be 
of the following form:
The rows contain measurements for a single unique entity,
corresponding to timepoints represented by the columns
</summary>
</member>
<member name="T:FSharp.Stats.ML.SimilarityMetrics.Similarity`1">
<summary>
 Signiture type for similarity functions
</summary>
</member>
<member name="M:FSharp.Stats.ML.SimilarityMetrics.Set.tverskySymmetric``1(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Computes the symmetric variant of the Tversky index. https://www.aclweb.org/anthology/S13-1028
</summary>
</member>
<member name="M:FSharp.Stats.ML.SimilarityMetrics.Set.tversky``1(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Computes the Tversky index, an asymmetric similarity measure on sets that compares a variant to a prototype. 
The Tversky index can be seen as a generalization of Sorencsen-Dice coefficient and Jaccard index.

ATTENTION: this is an asymmetric similarity measure. Use tverskySymmetric if symmetry is needed.
</summary>
</member>
<member name="M:FSharp.Stats.ML.SimilarityMetrics.Set.sorensenDice``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Computes the Sorensenï¿½Dice coefficient similarity measure for two finite sets

ATTENTION: The Sorensenï¿½Dice coefficient doesn&apos;t satisfy the triangle inequality.
The corresponding difference function (1 - sorensenDice) is not a proper distance measure.
</summary>
</member>
<member name="M:FSharp.Stats.ML.SimilarityMetrics.Set.overlap``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Computes the overlap coefficient, or Szymkiewiczï¿½Simpson coefficient, 

The Overlap coefficient measures the overlap between two finite sets. It is related to the Jaccard index and is 
defined as the size of the intersection divided by the smaller of the size of the two sets.

If set X is a subset of Y or the converse then the overlap coefficient is equal to 1.
</summary>
</member>
<member name="M:FSharp.Stats.ML.SimilarityMetrics.Set.jaccard``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Computes the Jaccard index of two finite sets, also known as Intersection over Union. 

The Jaccard coefficient measures similarity between finite sample sets, 
and is defined as the size of the intersection divided by the size of the union of the sample sets
</summary>
</member>
<member name="T:FSharp.Stats.ML.DistanceMetrics.Distance`1">
<summary>
 Signiture type for distance functions
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.wagnerFischerLazy(System.String,System.String)">
<summary>
 Levenshtein distance between
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.dissimilarity``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 &quot;Dissimilarity&quot; uses 1. - pearsons correlation coefficient 
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.cityblockNaN(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Cityblock distance of two coordinate float sequences
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.cityblock``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Cityblock distance of two coordinate float sequences
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.euclideanNaNSquared(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Squared Euclidean distance of two coordinate float sequences (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.euclideanNaN(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Euclidean distance of two coordinate float sequences (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.euclidean``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Euclidean distance of two coordinate sequences
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.cityblockNaN(System.Double[],System.Double[])">
<summary>
 Cityblock distance of two coordinate float arrays (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.cityblock``2(``0[],``0[])">
<summary>
 Cityblock distance of two coordinate arrays
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.euclideanNaNSquared(System.Double[],System.Double[])">
<summary>
 Squared Euclidean distance of two coordinate float arrays (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.euclideanNaN(System.Double[],System.Double[])">
<summary>
 Euclidean distance of two coordinate float arrays (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.euclidean``3(``0[],``0[])">
<summary>
 Euclidean distance of two coordinate arrays
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.cityblockNaN(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Cityblock distance of two vectors
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.cityblock``2(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
 Cityblock distance of two vectors
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.euclideanNaN(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Euclidean distance between 2 vectors (ignores nan) 
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.euclideanSquared``3(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
 Squared Euclidean distance between 2 vectors
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.euclidean``3(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
 Euclidean distance between 2 vectors
</summary>
</member>
<member name="T:FSharp.Stats.ML.DistanceMetrics">
<summary>
Functions for computing distances of elements or sets
</summary>
</member>
<member name="T:FSharp.Stats.ML.Impute.MatrixBaseImputation`2">
<summary>
 Type definintion for a vector based imputation
 The imputed values are based on the given whole dataset
</summary>
</member>
<member name="T:FSharp.Stats.ML.Impute.VectorBaseImputation`1">
<summary>
 Type definintion for a vector based imputation.
 The imputed values are based only on the given array
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.imputeBy``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0[]},Microsoft.FSharp.Core.FSharpFunc{``0[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Imputes rows by matrix-based imputation
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.imputeRowWiseBy``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Imputes row-wise by vector-based imputation
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.imputeColWiseBy``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Imputes column-wise by vector-based imputation
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.kNearestImpute(System.Int32,System.Collections.Generic.IEnumerable{System.Double[]},System.Double[],System.Int32)">
<summary>
 Imputation by k-nearest neighbour
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.normal(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
<summary>
 Imputation by sampling from a gausian normal distribution based on the input vector
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.rnd``1(System.Random,System.Collections.Generic.IEnumerable{``0},System.Int32)">
<summary>
 Imputation by random sampling from the input vector
</summary>
</member>
<member name="T:FSharp.Stats.ML.Impute">
<summary>
 Module for data imputation and missing value filtering
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.PCA.AdjustmentFactory">
<summary>
 AdjustmentFactorygiven,given a dataset, 
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.PCA.Component">
<summary>
 Represents a principle component 
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.zipScree(FSharp.Stats.ML.Unsupervised.PCA.Component[])">
<summary>
 Returns xy-coordinates for scree plot in a tuple (component number vs. EigenValue)    
 Scree plot: represents the ability of PCs to explain de variation in data
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.revert(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.ML.Unsupervised.PCA.AdjustmentDirection,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double}}},FSharp.Stats.ML.Unsupervised.PCA.Component[],FSharp.Stats.Matrix{System.Double})">
<summary>
   Reverts a set of projected data into it&apos;s original form. Complete reverse
   transformation is only possible if all components are present, and, if the
   data has been standardized, the original standard deviation and means of
   the original matrix are known.
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.transform(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.ML.Unsupervised.PCA.AdjustmentDirection,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double}}},FSharp.Stats.ML.Unsupervised.PCA.Component[],FSharp.Stats.Matrix{System.Double})">
<summary>
 Projects a given matrix into principal component space (projections or factor scores)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.getCommunality(FSharp.Stats.ML.Unsupervised.PCA.Component[])">
<summary>
 Returns communality
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.getFeatureMatrixOfComponents(FSharp.Stats.ML.Unsupervised.PCA.Component[])">
<summary>
 Returns feature matrix (eigenvector matrix) from components
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.compute(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.ML.Unsupervised.PCA.AdjustmentDirection,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes a principal componant analysis
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.computeOfMatrix(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes a principal componant analysis of a given covariance matrix
 !Attention: Matrix needs to be centered before
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.createComponentsOf(FSharp.Stats.Matrix{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates the principle components of eigenVectors and eigenValues
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.createComponent(System.Double[],System.Double,System.Double[],System.Double,System.Double,System.Int32)">
<summary>
 Creates a principle component type
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustCorrelation(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory which centers and standardize the data
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustStandardize(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory which centers and standardize the data
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustCovariance(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory as covariance matrix
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustCenter(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory which centers the data
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.PCA">
<summary>
 Principle component analysis 
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.DistanceMetric">
<summary>
 Used distance metric
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.ClosestDistances">
<summary>
 Indices and Distances to closest centroid
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.Classifier">
<summary>
 Classifier function returns cluster index and data point
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.Centroids">
<summary>
 Centroids with index and data
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1">
<summary>
 Result of a kmeans clustering
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.DispersionOfClusterResult``1(FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult{``0})">
<summary>
 Calculates the average squared distance from the data points
 to the cluster centroid (also refered to as error)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.Dispersion``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},Microsoft.FSharp.Collections.FSharpList{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculates the average squared distance from the data points
 to the cluster centroid (also refered to as error)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.nearestDistance``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},``0[],``0)">
<summary>
 Calculates the distance from the data point to the centroid 
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.createKClusteringResult``1(System.Tuple{System.Int32,``0}[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Int32,``0}},System.Tuple{System.Int32,System.Double}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}})">
<summary>
 Creates a k-clustering  result
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.DistanceCaching`1">
<summary>
 Class for chaching already calculated distances to speed up cluster build
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.printHClust``1(FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Converts clusters into string seq
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.cutHClust``1(System.Int32,FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Cuts a tree, as resulting from hclust, into several groups by specifying the desired number(s).
 If the desired number is odd the function cut the cluster with maximal distance
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.flattenHClust``1(FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Returns a flatten list containing Leafs
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.getClusterMemberLabels``1(FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Returns 
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.generate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32,System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}}}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Builds a hierarchy of clusters of data containing cluster labels
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.LancWilliamsLinker">
<summary>
 Signiture type for Lance and Williams Linker functions
 D(A u B,C) = alpa1 d(A,C) +  alpa2 d(B,C) + beta d(A,B) + gamma |d(A,C) - d(BC))|
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.wardLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Ward linkage criterion (UPGMA)
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.centroidLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Centroid linkage criterion (UPGMA)
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.upgmaLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Unweighted Group Average linkage criterion (UPGMA)
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.weightedGroupAverageLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Weighted Group Average linkage criterion
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.medianLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Median linkage criterion
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.completeLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Complete linkage criterion
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.singleLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Single linkage criterion
 Calculates the minimal distance between all elements of a cluster
 d(A u B, C)
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker">
<summary>
 The linkage criterion determines the distance between sets of observations as a function of the pairwise distances between observations
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering">
<summary>
 Agglomerative hierarchical clustering
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.GapStatistics.dispersion``1(Microsoft.FSharp.Core.FSharpFunc{``0[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double}},``0[],System.Int32)">
<summary>
 Not used.
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.ClusterNumber.calcAIC(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult{System.Double[]}},System.Int32)">
<summary>
 Akaike Information Criterion (AIC)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.ClusterNumber.k_ruleOfThumb``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Simple estimator for number of cluster (k) // can be used as the upper bound for other methods
</summary>
</member>
</members>
</doc>
